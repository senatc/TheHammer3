//*****************************************************************************************
// Copyright (c) 2000 Michael Kurz
// All rights reserved.
// If you want to use this source in your applications conatct: <MichaelKurz@gmx.at>
//
// $FileName    : cEditorEdit.Pkg
// $ProjectName : CODEMAX EDITOR
// $Author      : Michael Kurz <MichaelKurz@gmx.at>
// $Created     : 01-25-2001 @ 19:00
//
// Contents:
//      Properties for Editor, stored in an INI file, based on cIniHandler.
//
// $Rev History
//
//*****************************************************************************************
//TH-RevisionStart
// 05.02.2003 13:38  Redesigned all Autosuggestion-Lists   BP     APBP
//                   to new codelist control. Cleaned up
//                   obsolete code
// 07.02.2003 08:14  Implementen Character Translation     BP     APBP
//                   for Keyboard Input
// 18.04.2003 08:37  MarkScopeBlock: Marks the lines       BP     APBP
//                   between ScopeStart/ScopeEnd blocks
//                   with a thin line
// 18.04.2003 08:39  RemoveRemarkFromLine,                 BP     APBP
//                   IsKeywordInLine are
//                   helper functions for the
//                   MarkScopeBlock feature
// 27.06.2003 21:10  Get a free channel for insert headers WvA
// 11.07.2004        Adds support for "Send <method> Of <object> WvA
// 21.06.2005 10.00  Fixed Function isReasonForFieldList   RRS
//                   The ability to Popup FieldList wherever in line, rather then only last item
//TH-RevisionEnd

Use cArray2D.pkg                // Class: cArray2D
Use mFileTime.pkg               // TimeStamp of a file
Use ASDB_Ext.pkg                // Access functions and constants for the ASDB db.
Use cSrcLineParser.Pkg          // For Parsing VDF src code lines.
Use cCPPDataConverter.Pkg       // Used to convert a C Struct to a VDF TYPE-END_TYP Statement.
Use cDllImportToVDF.pkg         // Used to convert a C Dll call into a VDF format.
Use cStructHandlerCreater.Pkg   // Used to create easy handling code for VDF TYPEs
Use cIndexListEx.Pkg            // Abilities to read Indexes of a given file.
Use Colr_Dlg.pkg                // For selecting colors
Use Seq_chnl.pkg                // Sequential file access
Use Strings.pkg
Use cHtmlHelp.pkg
Use FindFile.pkg
Use vWin32fh.pkg

Indicate MKNoParsing False

Define MK_LW_NO             For 0
Define MK_LR_OBJECTS        For 1
Define MK_LR_PROCEDURES     For 2
Define MK_LR_CREATOR        For 3
Define MK_LR_VARS           For 4
Define MK_LR_KEYS           For 5
Define MK_LR_FUNCTIONS      For 6
Define MK_LR_SETPROCEDURES  For 7
Define MK_LR_DATABASEFIELDS For 8
Define MK_LR_CLASSES        For 9
Define MK_LR_INDEXES        For 10
Define MK_LR_IDETAGS        For 11
Define MK_LR_DATAFILES      for 12
Define MK_LR_COMMANDS       for 13
Define MK_LR_TYPES          for 14
Define MK_LR_ATTRIBUTES     for 15

Register_Function phoElements Returns Integer
Register_Object oTextGetter //@RRS
Register_procedure Define_EditorHotKeys // in cEditorEditView


Class cPopupGridMixin Is a Mixin
    Procedure Define_cPopupGridMixin
        Property Integer piFoundColor       Public (RGB(255,255,128))
        Property Integer piNotFoundColor    Public (RGB(230,230,230))

        Set ItemIsFitting        To True
        Set Highlight_Row_State  To True
        Set Select_Mode          To no_select
        Set Gridline_Mode        To Grid_Visible_none
        Set Header_Visible_State To False
    End_Procedure

    Procedure Set ItemIsFitting Integer iFlag
        Integer iColor
        If iFlag Move (piFoundColor(Self))     To iColor
        Else     Move (piNotFoundColor(Self))  To iColor
        Set Highlight_Row_Color  To iColor
        Set Current_Item_Color   To iColor
        Set Dynamic_Update_State To True
    End_Procedure
    Function ItemIsFitting Returns Integer
        Integer iColor
        Get Current_Item_Color   To iColor
        Function_Return (iColor Eq piFoundColor(Self))
    End_Function
    Procedure FitSizeToParent
        Set GuiSize To (Hi(Client_Size(Parent(Self)))) (Low(Client_Size(Parent(Self))))
        Set Form_guiWidth Item 0 To (Low(Client_Size(Parent(Self)))-15)
    End_Procedure
End_Class


    // Makes all charachters of a string lowercase and the 1st Uppercase.
Function NormaLizeString Global String sStr Returns String
    String sRet sChr
    Integer iPos iLen
    Move (Append(Uppercase(Left(sStr,1)),Lowercase(Right(sStr,Length(sStr)-1)))) To sRet
    For iPos From 1 To (Length(sRet))
      If (Mid(sRet,1,iPos)="_") Begin
        Increment iPos
        Move (Uppercase(Mid(sRet,1,iPos))) To sChr
        Move (Overstrike(sChr,sRet,iPos)) To sRet
      End
    Loop
    Function_Return sRet
End_Function

    //@RRS Normalizes Sentence
Function NormalizeText Global String sText Returns String
   Integer ix iPos
   String sRet sComments sWord

   Move (Pos(("/"+"/"),sText)) To iPos
   If (iPos) Begin
     Move (Right(sText,Length(sText)-iPos+1)) To sComments
     Move (Left(sText,iPos-1)) To sText
   End
   Move sText To sRet
   For ix From 1 To (HowManyWords(sText," "))
     Move (ExtractWord(sText," ",ix)) To sWord
     Move (Replace(sWord,sRet,(NormalizeString(sWord)))) To sRet
   Loop
   Move (sRet+sComments) To sRet
   Function_Return sRet
End_Function

    // Reduces a reference for an Object.
Function ReduceReference Global String sRef String sCurRef Returns String
    Integer hoID1 hoID2 iC iFrom iStart
    String sRet
    Object oLP1 Is a cLineParser
        Move Self   To hoID1
        Set psSepCharacter  To "."
    End_Object
    Object oLP2 Is a cLineParser
        Move Self   To hoID2
        Set psSepCharacter  To "."
    End_Object
    Send ParseLine  To hoID1 (FlipStrLR(sRef))
    Send ParseLine  To hoID2 (FlipStrLR(sCurRef))
    For iC From 0 To (Item_Count(hoID1)-1)
        If Not iStart If (Value(hoID1,iC)) Ne (Value(hoID2,iC)) Begin
            Move iC     To iFrom
            Move 1      To iStart
        End
        If iStart Begin
            If sRet Ne "" Append sRet "."
            Append sRet (Value(hoID1,iC))
        End
    End
    Send Request_Destroy_Object To hoID1
    Send Request_Destroy_Object To hoID2
    Move (FlipStrLR(sRet))  To sRet
    Function_Return sRet
End_Function

    // Replaces a Part of a string in a string within a given Start and EndToken.
Function RemovePartFromString Global String sVal String sStartPart String sEndPart Returns String
    Integer iPosStart iPosEnd
    String  sPart
    Move (Pos(sStartPart,sVal))                 To iPosStart

    Move (Right(sVal,Length(sVal)-iPosStart))   To sPart
    Move (Pos(sEndPart,sPart))                  To iPosEnd
    If iPosStart Gt 0 If iPosEnd Gt iPosStart Begin
        Move (Remove(sVal,iPosStart,iPosEnd)) To sVal
    End
    Function_Return sVal
End_Function

    // Replaces a Method out of an reference.
Function ReplaceMethod Global Integer iType String sVal Returns String
    String  sRet sSub
    Integer iEnde
    If iType Eq MK_Function          Move "@F"   To sSub
    Else If iType Eq MK_Procedure    Move "@P"   To sSub
    Else If iType Eq MK_SetProcedure Move "@S"   To sSub
    Else Function_Return sVal
    Repeat
        Move (RemovePartFromString(sVal,sSub,"."))  To sRet
        If sRet Eq sVal Move 1 To iEnde
        Else Move (Replace("..",sRet,"."))          To sRet
        Move sRet                                   To sVal
    Until (iEnde)
    Function_Return sVal
End_Function
    // Replaces all Methods out of a Reference.
Function ReplaceAllMethods Global String sVal Returns String
    Move (ReplaceMethod(MK_Function     ,sVal))  To sVal
    Move (ReplaceMethod(MK_Procedure    ,sVal))  To sVal
    Move (ReplaceMethod(MK_SetProcedure ,sVal))  To sVal
    Function_Return sVal
End_Function

    // Converts a Ref like Object1.Object2 to (Object1(Object2(Self)))
    // If VdfVersion>7.2 then don't insert self for objects that are within
    // the current object scope.
Function ReferenceToObject Global String sVal Returns String
    Number  nVdfVersion
    Boolean bChanged

    Get fnCurrentVdfVersion of ghoWorkSpaceHandlerEx To nVdfVersion
    If (nVdfVersion<=72) Begin
      If sVal Eq "" Move "Self"  To sVal
      Else Begin
          If (Right(Trim(sVal),1)) Eq "." Append sVal "Self"
          Else                            Append sVal "(Self)"
          While (sVal Contains ".")
              Move (Replace(".",sVal,"("))    To sVal
              Append sVal ")"
          End
          Move (Append("(",sVal)) To sVal
          Append sVal ")"
      End
    End
    Else Begin
      Move False To bChanged
      If sVal Eq "" Move "Self"  To sVal
      Else Begin
          If (Right(Trim(sVal),1)) Eq "." Begin
            Append sVal "Self"
            Move True To bChanged
          End
          //Else                            Append sVal "(Self)"
          While (sVal Contains ".")
              Move (Replace(".",sVal,"("))    To sVal
              Append sVal ")"
          End
          If (bChanged) Begin
            Move (Append("(",sVal)) To sVal
            Append sVal ")"
          End
      End
    End
    Function_Return sVal
End_Function

    // This Grid allows a search on the items.
    // with more then the 1st character.
Class cSearchAndControlGrid Is a Grid
    Import_Class_Protocol cPopupGridMixin
    Procedure Construct_Object
        Forward Send Construct_Object
        Property String     psOffsetChar    Public ""
        Property Integer    piOffsetX       Public 0
        Property String     psRef           Public ""
        Property Integer    piSearchState   Public True
        Property String     psSearchValue   Public ""
        Property String     psHeaderLabel0  Public ""
        Property Integer    piMaxTextLen    Public 0

        // Added to support the FindGe Message with unsorted data (i.e. the index-list)
        // 2.5.2002 Bernhard
        Property Integer    piIsSorted      Public True
        Send Define_cPopupGridMixin
        Set  autosize_height_state          To False
        Set horz_scroll_bar_visible_state   To False
        On_Key kEnter   Send Mouse_Click
        On_Key KEY_TAB  Send Mouse_Click
        On_Key KCANCEL  Send CloseList
    End_Procedure
        // To allow selection with mouse dblClick
    Procedure mouse_click Integer iPara0 Integer iPara1
        //If (Invoking_Object_ID(self)) Send Request_SimulateKey to (Invoking_Object_ID(self)) 0 VK_TAB ""
        //If (Invoking_Object_ID(self)) Send Activate to (Invoking_Object_ID(self))
    End_Procedure
    Procedure CloseList
        //If (Invoking_Object_ID(self)) Send Request_SimulateKey to (Invoking_Object_ID(self)) 0 VK_RIGHT ""
        //If (Invoking_Object_ID(self)) Send Activate to (Invoking_Object_ID(self))
    End_Procedure

        // Create a String with Blanks with an length of min. iL pixels.
    Function CreateStringWithLength Integer iL Returns String
        Integer iLS
        String  sStr
        Repeat
            Move (Append(sStr," ")) To sStr
            Get Text_Extent sStr    To iLS
            Move (Low(iLS))         To iLS
        Until (iLS>iL)
        Set piOffsetX               To iLS
        Function_Return sStr
    End_Function
        // Sets an offset string.
    Procedure Set TextOffsetX Integer iX
        String sStr
        Move (CreateStringWithLength(Self,iX))  To sStr
        Set psOffSetChar    To sStr
    End_Procedure
        // Delivers the current value in a format which can be inserted.
    Function CurrentValue Returns String
        Function_Return ""
    End_Function
        // Finds an entry.
    Procedure FindGE String sStr Returns Integer
        Integer iC iCur iL iStart
        String  sVal
        If (Item_Count(Self)) Eq 0 Procedure_Return
        Get Current_Item       To iCur
        Move (Trim(sStr))      To sStr
        Move (Uppercase(sStr)) To sStr
        Move (CString(sStr))   To sStr
        Get value Item iCur    To sVal
        Move (LTrim(sVal))     To sVal
        Move (Uppercase(Value(Self,iC)))                        To sVal
        Move (Left(sVal,il))                                    To sVal
        If (Left(sStr,1)) Eq "(" Move (Replace("(",sStr,""))    To sStr
        Move (Replaces("(",sStr,"."))                           To sStr
        Move (Replaces(")",sStr,""))                            To sStr
        Move (Length(sStr))    To iL
        For iC From iStart To (Item_Count(Self)-1)
            Move (LTrim(Uppercase(Value(Self,iC)))) To sVal
            If (Left(sVal,iL)) Eq sStr Begin
                Set ItemIsFitting   To True
                Set Current_Item    To iC
                Procedure_Return 1          // Delivers true if item is fittin!
            End
            // Don't cancel if the data is unsorted
            // 2.5.2002 Bernhard
            If ( (piIsSorted(Self)) And ( (Left(sVal,iL)) Gt sStr) ) Move (Item_Count(Self)) To iC
        End
        Set ItemIsFitting To False
    End_Procedure
        // Append the offset char.
    Procedure Add_Item Integer iMsg String sVal
        Integer iL
        Move (Append(psOffsetChar(Self),sVal))  To sVal
        Forward Send Add_Item iMsg sVal
        Get Text_Extent sVal                            To iL
        Move (Low(iL))                                  To iL
        If (iL > piMaxTextLen(Self)) Set piMaxTextLen   To iL
    End_Procedure
        // Storing keys in the Header_Label
    Procedure AddKey Integer iKey
        String sValue sTmp
        Get psSearchValue   To sValue
        Append sValue (Character(iKey))
        Set psSearchValue   To sValue
        Get psHeaderLabel0  To sTmp
        Append sTmp " - " sValue
        Send FindGE sValue
        Set Header_Label Item 0 To sTmp
    End_Procedure
        // Deleting keys from the Header_Label.
    Procedure RemoveKey
        String sValue sTmp
        Get psSearchValue                       To sValue
        Move (Left(sValue,Length(sValue)-1))    To sValue
        Set psSearchValue                       To sValue
        Get psHeaderLabel0                      To sTmp
        Append sTmp " - " sValue
        Send FindGE sValue
        Set Header_Label Item 0 To sTmp
    End_Procedure
    Procedure ResetKey
        Set Header_Label Item 0 To (psHeaderLabel0(Self))
        Set psSearchValue   To ""
    End_Procedure

        // To reset the search text during close and reactivate.
    Procedure page_object Integer iMode
        Send ResetKey
        Forward Send page_object iMode
    End_Procedure

    Function isDisplayAbleKey Integer iKey Returns Integer
        If iKey Eq (Ascii("_"))                         Function_Return 1
        If iKey Ge (Ascii("A")) If iKey Le (Ascii("Z")) Function_Return 1
        If iKey Ge (Ascii("a")) If iKey Le (Ascii("z")) Function_Return 1
        If iKey Ge (Ascii("0")) If iKey Le (Ascii("9")) Function_Return 1
    End_Function
    Procedure Key Integer iKey
        Integer iTKey iFwd
        Move 1 To iFwd
        If (Focus(Desktop)) Eq Self Begin
            Move 0  To iFwd
            If (iKey Iand 1024) Move (iKey-1024)    To iTKey
            Else Move iKey                          To iTKey
            If (isDisplayAbleKey(Self,iTKey)) Send AddKey iKey
            Else If iKey Eq KEY_BACK_SPACE Send RemoveKey
            Else Move 1 To iFwd
        End
        If iFwd Begin
            Send ResetKey
            If      iKey Eq (Key_Ctrl+Key_Home)    Set Current_Item To 0
            Else If iKey Eq (Key_Ctrl+Key_End )    Set Current_Item To (Item_Count(Self)-1)
            Else Forward Send Key iKey
        End
        Set ItemIsFitting   To True
    End_Procedure

        // Sends a message to the parent without causing an error if not known.
    Procedure TryToSendMessage2Parent Integer iMsg Integer iP1 Integer iP2
        Integer iDel
        Get Delegation_Mode     Of (Parent(Self))                   To iDel
        Set Delegation_Mode     Of (Parent(Self))                   To No_Delegate_Or_Error
        Send iMsg               To (Parent(Self)) iP1 iP2
        Set Delegation_Mode     Of (Parent(Self))                   To iDel
    End_Procedure

    Procedure End_Construct_Object
        Set psHeaderLabel0 To (Header_Label(Self,0))
        Forward Send End_Construct_Object
    End_Procedure
End_Class

    // Grid with objects.
Class cObjectList Is a cSearchAndControlGrid
    Procedure Construct_Object
        Forward Send Construct_Object
        Property Integer phoOwnedObjectListID   Public 0
        Property Integer piAddExtElementsState  Public False
    End_Procedure

        // Delivers the current value in a format which can be inserted.
    Function CurrentValue Returns String
        String sVal
        Integer isVar
        If Not (ItemIsFitting(Self)) Function_Return ""
        If (phoOwnedObjectListID(Self)) If (Value2D(phoOwnedObjectListID(Self),Current_Item(Self),2)) Eq  MK_VARIABLE Move 1 To isVar
        Get Value                                       To sVal
        If isVar Function_Return (Trim(sVal))
        Move (LTrim(sVal))                              To sVal

        Move (ReduceReference(sVal,psRef(Self)))        To sVal
        Move (ReferenceToObject(sVal))                  To sVal
        Function_Return sVal
    End_Function
        // Fills the list from an Object 2D Array.
    Procedure FillList Integer hoParser Integer iLine String sRef Integer hoIDVarsE
        Integer iC iItem  iTextMaxX iTextX iDel iCur
        Integer hoIDVars hoIDParas hoIDDestroy hoID iVarType
        String  sObj sCls sVarName

        If (phoOwnedObjectListID(Self)) Send Request_Destroy_Object To (phoOwnedObjectListID(Self)) // Destroy the old list when owned!

        Get GetObjectList            Of hoParser    To hoID         // Objects
        If (piAddExtElementsState(Self)) Begin
            Get DuplicateArray Of hoID                      To hoIDDestroy
            Move hoIDDestroy                                To hoID
            Set value2D Of hoID Item (Item_Count(hoID)) 0   To "Desktop"    // Add "Desktop"

            //____Add_Variables_to_Object_List...______________
            Get GetVariablenListFromLine Of hoParser iLine  To hoIDVars     // Variables
            For iC From 0 To (Item_Count(hoIDVars)-1)
                Get value2D Of hoIDVars Item iC 0           To sVarName
                Get value2D Of hoIDVars Item iC 1           To iVarType
                If ((iVarType Eq MK_INTEGER) Or (iVarType Eq MK_HANDLE)) If (Left(Uppercase(sVarName),2)) Eq "HO" Begin
                    Set value2D Of hoID Item (Item_Count(hoID)) 0 To sVarName
                End
            End
            //____Add_Parameters_to_Object_List...______________
            Get GetParameterListFromLine Of hoParser iLine  To hoIDParas    // Parameters
            For iC From 0 To (Item_Count(hoIDParas)-1)
                Get value2D Of hoIDParas Item iC 0          To sVarName
                Get value2D Of hoIDParas Item iC 1          To iVarType
                If ((iVarType Eq MK_INTEGER) Or (iVarType Eq MK_HANDLE)) If (Left(Uppercase(sVarName),2)) Eq "HO" Begin
                    Set value2D Of hoID Item (Item_Count(hoID)) 0 To sVarName
                End
            End
        End
        Set phoOwnedObjectListID    To hoIDDestroy
        Set psRef                   To sRef
        Set piMaxTextLen            To 0
        If hoID Begin
            If (piOffsetX(Self)) Eq 0 Set TextOffsetX               To 16
            If (Item_Count(hoID)) Eq 0 Procedure_Return 1
            Send Sort_Items                                         To hoID ascending
            Send Delete_Data
            For iC From 0 To (Item_Count(hoID)-1)
                Get Value2D Of hoID Item iC 0                       To sObj
                Get Value2D Of hoID Item iC 1                       To sCls
                Get Text_Extent (sObj+psOffsetChar(Self))           To iTextX
                Move (Low(iTextX))                                  To iTextX
                If iTextX Gt iTextMaxX Move iTextX                  To iTextMaxX
                Move (ReplaceAllMethods(sObj)) To sObj              // Remove Procedures and Functions
                Send add_item msg_none sObj
                Set entry_state Item (Item_Count(Self)-1)           To False
                Set Form_Bitmap Item iC                             To (ClassBitmaps(desktop,sCls,MK_CLASS))
                If (Trim(sObj)) Eq sRef Move iC                     To iCur
            End
        End
        Set Current_Item                                            To iCur
        //if hoIDDestroy send Request_Destroy_Object                  to hoIDDestroy
    End_Procedure
End_Class

Define MK_PROC_NONE         For 0
Define MK_PROC_PROCEDURE    For 1
Define MK_PROC_FUNCTION     For 2

#IFNDEF TH_SCINTILLA
    //This class is the Marker-Textbox for BracketMarking
    //15.05.2001 Bernhard
Class cBracketMarker Is a TextBox
    Procedure construct_object
        Forward Send construct_object
        Set typeface To "Arial"
        Set fontsize To 14 0
        Set label To "^"
        Set Auto_size_state To False
        Set guiSize To 7 5
        Set visible_state To False
        Set object_color To clWhite clRed
    End_Procedure
    Procedure ShowBracketMarker Integer iY Integer iX
        Set GuiLocation    To iY iX
        Send Adjust_Logicals
        Send Page_Object True
        Set Visible_State       To True
    End_Procedure
    Procedure RemoveBracketMarker
        If (Visible_state(Self)) Set visible_state To False
    End_Procedure
End_Class
#ENDIF

Open VDFProp

    // Shall Insert multiline revision marks.
Class cPrintStack Is a cLineParser
    Procedure construct_object
        Forward Send Construct_Object
        Set psSepCharacter To "\n"
    End_Procedure
    Procedure PushItem String sWert
        Set value Item (item_count(Self))   To sWert
    End_Procedure
    Function PullItem Returns String
        String sRet
        Get value   Item 0 To sRet
        Send Delete_Item 0
        Function_Return sRet
    End_Function

        // Delivers a sub string from the left side at a specific
        // length, but tries to cut only at blanks.
    Function LeftWithWholeWord String sStr Integer iL Returns String
        Integer iLAlt
        String  sHilf
        If (Length(Trim(sStr))) Le iL Function_Return (Trim(sStr))
        Move iL                     To iLAlt
        Move (Left(sStr,iL))        To sHilf
        While (((Right(sHilf,1)) Ne " ") And (iL Gt 10))
            Move (iL-1)             To iL
            Move (Left(sStr,iL))    To sHilf
        End
        If iL Le 10 Move (Left(sStr,iLAlt)) To sHilf
        Function_Return sHilf
    End_Function


        // Should break the lines on the length of the given mask.
    Procedure AutoLineBreak Integer iL
        Integer iC hoTmp iC2
        String  sVal sSub
        Object oTmpArray Is an Array
            Move Self   To hoTmp
        End_Object
        For iC From 0 To (Item_Count(Self)-1)
            Get value Item iC   To  sVal
            While (Length(sVal) Gt iL)
                Move (LeftWithWholeWord(Self,sVal,iL))  To sSub
                Move (Replace(sSub,sVal,""))            To sVal
                Set value Of hoTmp Item iC2             To sSub
                Increment iC2
            End
            Set value Of hoTmp Item iC2                 To sVal
            Increment iC2
        End
        Send Delete_Data
        For iC From 0 To (Item_Count(hoTmp)-1)
            Set value Item iC To (Value(hoTmp,iC))
        End
        Send Request_Destroy_Object To hoTmp
    End_Procedure
        // Fills all lines from the given line.
    Procedure FillFromLine String sLine Integer iLE
        String  sPart
        Integer iL iDidIt
        Send ParseLine sLine    // Parses the Line
        If NUM_Arguments Gt 1 Move iLe  To iL
        If iL Gt 0 Begin
            Send AutoLineBreak iL
        End
    End_Procedure


    Procedure RunUntilReady Integer iZielID Integer iSektion
        Integer iCount
        If Not iZielID Procedure_Return
        While (Item_Count(Self) Gt 0)
            Get Item_Count      To iCount
            //Send OUTPUT_Sektion To iZielID iSektion
            //If (Item_Count(Self)) Ge iCount Procedure_Return
        End
    End_Procedure
End_Class


    // To Handle the Revision masks and create the necc. inserting strings.
Class cRevisionMaskHandler Is an Array
    Procedure Construct_Object
        Forward Send Construct_Object

        Property String psMaskLine  Public ""
        Object oMaskElements Is a cLineParser
            Set psSepCharacter  To " "
        End_Object
        Object oDataElements Is a cLineParser
            Set psSepCharacter  To " "
        End_Object
        Object oPrintStack Is a cPrintStack
        End_Object
    End_Procedure

        // Loads a Revsion mask from a file.
    Function LoadRevisionMaskFromFile String sFile Returns Integer
        String sLine sMask sData
        Direct_Input sFile
        [seqeof] Function_Return False
        Repeat
            Readln sLine
            If (Uppercase(Trim(sLine))) Eq ("/"+"/TH-REVISIONSTART") Begin
                Readln sMask
                Readln sData
                Send FillMask sMask sData
                Close_Input
                Function_Return 1
            End

        Until [seqeof]
        Close_Input
        Function_Return 0
    End_Function
        // Tries 1st to load the mask from the userlocal .TPL and the from the global.
    Procedure LoadRevisionMask
        If (LoadRevisionMaskFromFile(Self,("Header"+gsUserName+".tpl"))) Procedure_Return 1
        If (LoadRevisionMaskFromFile(Self,("Header.tpl")))                   Procedure_Return 1
    End_Procedure
        // Fills the Revisionmask.
    Procedure FillMask String sMask String sData
        Set psMaskLine  To sMask
        Send ParseLine  To (oMaskElements(Self)) sMask
        Send ParseLine  To (oDataElements(Self)) sData
    End_Procedure

        // Creates the Data from the
    Function EvalData String sData String sMask String sTxt  Returns String
        Integer iDescLen
        String sDY sDM sDD sTH sTM sTS sTHUSER

        If sData Eq "@DESCRIPTION@"     Begin
            Move (Length(sMask))        To iDescLen
            Send  FillFromLine To (oPrintStack(Self)) sTxt iDescLen
            Get value Of (oPrintStack(Self)) Item 0 To sTxt
            Function_Return sTxt
        End
        If sData Eq "@USERNAME@"        Function_Return gsUserName
        If sData Eq "@COMPUTERNAME@"    Function_Return gsComputerName

        // Date parts.
        Sysdate4 sDY sTH sTM sTS
        Move (Mid(sDY,2,1))     To sDD
        Move (Mid(sDY,2,4))     To sDM
        Move (Mid(sDY,4,7))     To sDY
        Move (Replaces("@DD@"         ,sData,sDD))          To sData  // Day
        Move (Replaces("@DM@"         ,sData,sDM))          To sData  // Month
        Move (Replaces("@DY@"         ,sData,sDY))          To sData  // Year

        // Time parts.
        Move (Right("0"+sTH,2)) To sTH
        Move (Right("0"+sTM,2)) To sTM
        Move (Right("0"+sTS,2)) To sTS
        Move (Replaces("@TH@"         ,sData,sTH))          To sData  // Hour
        Move (Replaces("@TM@"         ,sData,sTM))          To sData  // Minute
        Move (Replaces("@TS@"         ,sData,sTH))          To sData  // Second

        //@ Custom Data
        If sData Eq "@ISSUE@"  Get StringP2 Of (oTextGetter(Self)) To sData //@
        If sData Eq "@THUSER@" Move gsUserName to sData //@

        Function_Return sData
    End_Function
        // Formats a string to a specific length with an alignment
    Function FormatString String sStr Integer iL Integer iMode Returns String
        If iMode Begin  // Right aligned
            Move (Right( (Repeat(" ",iL)+(RTrim(sStr))),iL)) To sStr
        End
        Else Begin      // Leftaligned
            Move (Left( ((LTrim(sStr)+Repeat(" ",iL))),iL))  To sStr
        End
        Function_Return sStr
    End_Function
        // Should create the Line to Insert.
    Function CreateMaskedValue String sTxt Returns String
        String sMask sData sMaskLine s2ndLine sMaskDesc
        Integer iC iRight iDescLen
        Get psMaskLine                                              To sMaskLine
        Move sMaskLine                                              to s2ndLine
        For iC From 0 To (Item_Count(oMaskElements(Self))-1)
            Get value Of (oMaskElements(Self)) Item iC              To sMask
            If sMask Eq ("/"+"/") Increment iC
            Get value of (oMaskElements(Self)) item iC              to sMask
            If (Pos('_', sMask)) Begin
                Get value of (oDataElements(Self)) item iC              to sData            // its the name of the value
                If sData Eq "@DESCRIPTION@" Begin
                    Move (Repeat("X",Length(sMask)))                            to sMaskDesc
                    Move (Replace(sMask,s2ndLine,Repeat("X",Length(sMask))))    to s2ndLine
                End
                Else Move (Replace(sMask,s2ndLine,Repeat(" ",Length(sMask))))   to s2ndLine
                Move (EvalData(Self,sData,sMask,sTxt))                  to sData            // Not its the real value
                If "." In sMask Move 1                                  to iRight           // Align it right
                Else            Move 0                                  to iRight           // Align it left
                Move (FormatString(Self,sData,Length(sMask),iRight))    to sData            // Not the DataString is formated!
                Move (Replace(sMask,sMaskLine,sData))                   to sMaskLine    // Now the Data is inserted into the Line!
            End // Mask, not a text (eg. "by __________")
        End
        For iC From 1 To (Item_Count(oPrintStack(Self))-1)
            Get value Of (oPrintStack(Self)) Item iC    To sData
            If "." In sMaskDesc Move 1                                  To iRight           // Align it right
            Else                Move 0                                  To iRight           // Align it left
            Move (FormatString(Self,sData,Length(sMaskDesc),iRight))    To sData            // Not the DataString is formated!
            Append sMaskLine "\n" (Replace(sMaskDesc,s2ndLine,sData))
        End
        Function_Return sMaskLine
    End_Function
End_Class

    // Delivers the WindowText of a
Function EditWindowText For Desktop Integer iEditID Returns String
   Integer iTextLen iRetval
   Handle hWnd
   String sFullText
   Pointer lpsFullText

   Get Window_Handle Of iEditID                         To hWnd
   If (hWnd <> 0) Begin
      Move (SendMessage (hWnd, WM_GETTEXTLENGTH, 0, 0)) To iTextLen
      If (iTextLen <> 0) Begin
         Increment iTextLen
         ZeroString iTextLen To sFullText
         GetAddress Of sFullText To lpsFullText
         Move (SendMessage (hWnd, WM_GETTEXT, iTextLen, lpsFullText)) To iRetval
      End
   End
   Function_Return sFullText
End_Function // EditWindowText

Use Tools\AddRevisionEntry.dg

Class cEditExtentionsMixin Is a Mixin
    Procedure Define_cEditExtentionsMixin
        Integer hoID
        Property Integer phoParser      Public hoID

        Property Integer piInListCol    Public 0
        Property Integer piInListLine   Public 0
        Property Integer piOnce         Public 0

        Property Integer piBeginLineMarked Public 0
        Property Integer piEndLineMarked   Public 0

        Object oLineParser Is a cLineParser // USed to Parse some lines.
        End_Object

#IFNDEF TH_SCINTILLA
            //Create my Bracket Marker
            //15.05.2001 Bernhard
        Object oBracketMarker Is a cBracketMarker
        End_Object
#ENDIF        

        Object oItems Is a Set
        End_Object
        Object oItemHandles Is an Array
        End_Object
        Object oItemsTouched Is an Array
        End_Object
        Object oUsedFiles Is a Set
        End_Object

            // Used to show the fields of a DataFile, by reading the *.FD file.
        Object oFDFileReader Is a cFDFileReader
            Set  piSortMode         To ascending    // Sort for searching during type.
            Set  piNormalizeEntries To True         // Normalize entry instead of all Uppercase.
        End_Object
            // Used to show all available Indexes for a special file
        Object oIndexReader Is a cIndexListEx
            Set  pbFillIndexString  To True // Use the Interface needed for the Hammer.
        End_Object

//        On_Key key_alt+key_f1 Send
    End_Procedure

        // Used to access the general LineParser Object oLineParser
    Function ParseLineTmp String sSepCharacter Integer iSkipEmptyParts String sLine Returns Integer
        Integer hoID
        Move (oLineParser(Self))    To hoID
        Send Init                   To hoID sSepCharacter iSkipEmptyParts
        Send ParseLine              To hoID sLine
        Function_Return hoID
    End_Function

         // Toggle Mark.
    Procedure ToggleComment
        Integer iStart iEnd iLine iRet iCol iCurrLine
        String sVal sChk
        Append sChk "/" "/"
        Get CM_GetSel False To iRet
        Get piSelEndCol                                                     To iCol
        Get piSelStartLine                                                  To iStart
        Get piSelEndLine                                                    To iEnd
        Move iEnd                                                           To iCurrLine
            // Is the selection Is done From bottom To top, exchange the Values.
        If (iStart Gt iEnd) Begin
            Move iStart                                                     To iLine
            Move iEnd                                                       To iStart
            Move iLine                                                      To iEnd
        End
            // Run all lines and toggle the comment mark.
        For iLine From iStart To iEnd
            Get value Item iLine                                            To sVal
            If (Left(LTrim(sVal),2)) Eq sChk Move (Replace(sChk,sVal,""))   To sVal
            Else Move (Append(sChk,sVal))                                   To sVal
            Set value Item iLine                                            To sVal
        End
            // Reset the position, line and col.
        Move (CM_SetSel(Self,iCurrLine,iCol,iCurrLine,iCol,False))          To iRet
    End_Procedure

    //
    // Remove end-of-line whitespace in the entire edit buffer.
    // This will temporarily set the normalizecase to off as otherwise
    // your entire text would end up normalized and not just the lines changed.
    // (Actually the "temp disable normalize case" might not have any effect as it
    //  looks like all text is changed anyways if that's on)
    //
    // The reason for this code is not so much the feature as well as this is the
    // default behavior of the Studio editor nowadays and it is a good time saver
    // in source control if text edited by either one have little differences
    // (eg. editing with the studio tends to trigger loads of whitespace differences)
    //
    Procedure BufferTextRTrim
        Integer iLine iRet
        Integer iCount
        Integer iCaseEnabled
        String  sLine sRTLine

        Move (CM_IsNormalizeCaseEnabled(Self)) To iCaseEnabled
        If (iCaseEnabled) Begin
          Get CM_EnableNormalizeCase False To iRet
        End
        
        Get Item_Count To iCount
        If (iCount>0) Begin
          Decrement iCount
          For iLine From 0 To iCount
            Get value Item iLine To sLine
            Move (CString(sLine)) To sLine
            Move (RTrim(sLine)) To sRTLine
            If (sRTLine<>"" and length(sRTLine)<>Length(sLine)) Begin
              // only change if not indented white text line only
              // and if has whitespace at the end of the line.
              Set Value Item iLine To sRTLine
            End
          Loop
        End
        
        If (iCaseEnabled) Begin
          // Reset the normalize case feature to the orginal value.
          Get CM_EnableNormalizeCase iCaseEnabled To iCaseEnabled
        End
    End_Procedure // BufferTextRTrim

        // Converts a On_item "" Block to send Add_Item
        // Or if a block of send Add_Item converts it to on_item statements.
    Procedure Toggle_OnItem_AddItem
        Integer iStart iEnd iLine iRet iCol iCurrLine iPos hoParser iIndent iLen
        String sVal sCmt sChk sTmp sMsg
        Append sChk "/" "/"
        Get CM_GetSel False To iRet
        Get piSelEndCol                                                     To iCol
        Get piSelStartLine                                                  To iStart
        Get piSelEndLine                                                    To iEnd
        Move iEnd                                                           To iCurrLine
            // Is the selection Is done From bottom To top, exchange the Values.
        If (iStart Gt iEnd) Begin
            Move iStart                                                     To iLine
            Move iEnd                                                       To iStart
            Move iLine                                                      To iEnd
        End
        Object oTmpParser Is a cSrcLineParser
            Set psSepCharacter      To " "
            Set piSkipEmptyParts    To True
            Move Self               To hoParser
        End_Object
            // Run all lines and toggle the comment mark.
        For iLine From iStart To iEnd
            Get value Item iLine                                            To sVal
            Move (Length(sVal)-Length(LTrim(sVal)))                         To iIndent
            Move (Pos(sChk,sVal))                                           To iPos
            Move ""                                                         To sCmt
            If iPos Gt 0 Begin
                Move (Right(sVal,Length(sVal)-iPos))                        To sCmt
                Move (Left(sVal,iPos-1))                                    To sVal
            End
            Send ParseLine To hoParser sVal
            If (Uppercase(Value(hoParser,0))) Eq "SEND" If (Uppercase(Value(hoParser,1))) Eq "ADD_ITEM" Begin
                Move "" To sTmp
                Append sTmp (Repeat(" ",iIndent))
                Append sTmp "On_Item "
                Get value Of hoParser Item 2    To sMsg
                Append sTmp (Value(hoParser,3)) " Send " (Right(sMsg,Length(sMsg)-4)) " " sCmt
                Set Value Item iLine        To sTmp
            End
            If (Uppercase(Value(hoParser,0))) Eq "ON_ITEM" Begin
//                0       1      2    3       4  5
//                On_Item "Name" Send Message To Object
                Move "" To sTmp
                Append sTmp (Repeat(" ",iIndent))
                Append sTmp "Send Add_Item "
                Append sTmp "Msg_" (Value(hoParser,3)) " " (Value(hoParser,1)) " " sCmt
                Set Value Item iLine        To sTmp
                If (Uppercase(Value(hoParser,4))) Eq "TO" Begin
                    Move (Length(sTmp))         To iLen
                    Move ""                     To sTmp
                    Append sTmp (Character(13)) (Character(10)) (Repeat(" ",iIndent)) "Set aux_value item (Item_Count(Self)-1) to "
                    Append sTmp  (Value(hoParser,5))
                    Move (CM_InsertText(Self,sTmp,iLine,iLen)) To iRet
                    Increment iEnd
                    Increment iLine
                End
            End
        End
            // Reset the position, line and col.
        Move (CM_SetSel(Self,iCurrLine,iCol,iCurrLine,iCol,False))          To iRet
        Send request_destroy_object To hoParser
    End_Procedure

// 18.04.2003 08:39  RemoveRemarkFromLine,                 BP     APBP
//                   IsKeywordInLine are
//                   helper functions for the
//                   MarkScopeBlock feature

    Function RemoveRemarkFromLine String sLine Returns String
        Move (Replaces(Character(9),sLine,"")) To sLine
        If (Pos(("/"+"/"),sLine)) Ne 0 Move (Left(sLine,((Pos(("/"+"/"),sLine)) -1))) To sLine
        Function_Return ( " " + (uppercase(Trim(sLine))) + " ")
    End_Function

    // helper function for MarkScopeBlock, when a keyword is found in a string declaration
    // it will skew the scope block marking, so remove all strings
    Function RemoveStringsFromLine String sLine Returns String
      Integer iLength
      Integer iPos
      Boolean bSep1
      Boolean bSep2
      String  sChar
      String  sSep1
      String  sSep2
      String  sReturn

      Move "'" To sSep1
      Move '"' To sSep2
      Move ""  To sReturn
      Move false To bSep1
      Move false To bSep2
      Move (length(sLine)) To iLength
      For iPos From 1 To iLength
        Move (Mid(sLine,1,iPos)) To sChar
        If (bSep1=false and bSep2=false) Begin
          If (sChar=sSep1) Move True to bSep1
          Else If (sChar=sSep2) Move True To bSep2
          If (bSep1=false and bSep2=false) Move (sReturn+sChar) To sReturn
        End
        Else Begin
          If (bSep1) Begin
            If (sChar=sSep1) Move false To bSep1
          End
          Else If (bSep2) Begin
            If (sChar=sSep2) Move false To bSep2
          End
        End
      Loop
      Function_Return sReturn
    End_Function // RemoveStringsFromLine

    Function IsKeywordInLine String sKeywords String sLine String sLanguage Returns String
        String sKeyword

        Get RemoveRemarkFromLine sLine To sLine
        Get RemoveStringsFromLine sLine To sLine
        While sKeywords Ne ""
            Move (Left(sKeywords,(Pos("|",sKeywords)))) To sKeyword
            Move (Replace(sKeyword,sKeywords,"")) To sKeywords
            Move (uppercase(Trim(Replace("|",sKeyword,"")))) To sKeyword
            If ( (sLanguage Eq "VDF") And (sKeyword Eq "FOR") ) Begin   // Handle VDF For in a special way
                If (Left(sLine,5)) Eq " FOR " Function_Return sKeyword
            End
            Else If ( (sKeyword<>"") And ((Pos((" " + sKeyword + " "),sLine))<>0) ) Function_Return sKeyword
        End
        Function_Return ""
    End_Function

// 18.04.2003 08:37  MarkScopeBlock: Marks the lines       BP     APBP
//                   between ScopeStart/ScopeEnd blocks
//                   with a thin line

    Procedure MarkScopeBlock
        Integer iRet iEndLine iCurLine iFound iLine iStartLine iDepth iLanguage
        String sLine sLanguage sScopeStartKeywords sScopeEndKeywords

        Get psLanguage Of ghoEditorProperties To sLanguage
        If (Trim(sLanguage)) Eq "" Procedure_Return
        Get FindLanguage Of ghoEditorProperties sLanguage To iLanguage
        If (iLanguage < 0) Procedure_Return

        Send cursor_wait To cursor_control

        Move (psLanguages.szScopeKeywords1(ghoEditorProperties,iLanguage)) To sScopeStartKeywords
        Move (psLanguages.szScopeKeywords2(ghoEditorProperties,iLanguage)) To sScopeEndKeywords
        Move ("|" + (Trim(Replaces("\n",sScopeStartKeywords,"|"))) + "|") To sScopeStartKeywords
        Move ("|" + (Trim(Replaces("\n",sScopeEndKeywords,"|"))) + "|") To sScopeEndKeywords

        If (piBeginLineMarked(Self)) Ne 0 Begin
            Get CM_GetDivider (piBeginLineMarked(Self)) To iRet
            If (Not(iRet)) Begin
                For iLine From 0 To (CM_GetLineCount(Self))
                    Get CM_SetDivider iLine FALSE To iRet
                Loop
                Set piEndLineMarked To 0
            End
            Else Get CM_SetDivider (piBeginLineMarked(Self)) FALSE To iRet
            Set piBeginLineMarked To 0
        End
        If (piEndLineMarked(Self)) Ne 0 Begin
            Get CM_GetDivider (piEndLineMarked(Self)) To iRet
            If (Not(iRet)) Begin
                For iLine From 0 To (CM_GetLineCount(Self))
                    Get CM_SetDivider iLine FALSE To iRet
                Loop
            End
            Else Get CM_SetDivider (piEndLineMarked(Self)) FALSE To iRet
            Set piEndLineMarked To 0
        End
        Get CM_GetSel True To iRet
        Get piSelEndLine   To iCurLine
        Move iCurLine To iLine
        Move -1 To iEndLine
        Move 0 To iFound
        Move 0 To iDepth
        While (iFound Eq 0)
            Get value Item iLine To sLine
            If (IsKeywordInLine(Self,sScopeStartKeywords,sLine,sLanguage)) Ne "" Begin
                If iLine Ne iCurLine Increment iDepth
            End
            Else If (IsKeywordInLine(Self,sScopeEndKeywords,sLine,sLanguage)) Ne "" Begin
                If iDepth Le 0 Begin
                    Move 1 To iFound
                    Move iLine To iEndLine
                End
                Else Decrement iDepth
            End
            Increment iLine
            If iLine Gt (CM_GetLineCount(Self)) Move 1 To iFound
        End

        If iEndLine Ne -1 Begin
            Move iCurLine To iLine
            Move -1 To iStartLine
            Move 0 To iFound
            Move 0 To iDepth
            While (iFound Eq 0)
                Get value Item iLine To sLine
                If (IsKeywordInLine(Self,sScopeEndKeywords,sLine,sLanguage)) Ne "" Begin
                    If iLine Ne iCurLine Increment iDepth
                End
                Else If (IsKeywordInLine(Self,sScopeStartKeywords,sLine,sLanguage)) Ne "" Begin
                    If iDepth Le 0 Begin
                        Move 1 To iFound
                        Move iLine To iStartLine
                    End
                    Else Decrement iDepth
                End
                Decrement iLine
                If iLine Lt 0 Move 1 To iFound
            End
            If iStartLine Ne -1 Begin
                Get CM_SetDivider (iStartLine -1) TRUE To iRet
                Get CM_SetDivider iEndLine TRUE To iRet
                Set piBeginLineMarked To (iStartLine -1)
                Set piEndLineMarked To iEndLine
            End
        End
        Send cursor_ready To cursor_control
    End_Procedure

        // Converts a Selected C Struct to a VDF Type.
    Procedure ConvertVDFTypeToHandler
        Integer hoID iStart iEnd iLine iRet
        String  sLine sRet
        Get CM_GetSel False                                                 To iRet
        Get piSelStartLine                                                  To iStart
        Get piSelEndLine                                                    To iEnd
            // Is the selection Is done From bottom To top, exchange the Values.
        If (iStart Gt iEnd) Begin
            Move iStart                                                     To iLine
            Move iEnd                                                       To iStart
            Move iLine                                                      To iEnd
        End
        Object oStructHandlerCreater Is a cStructHandlerCreater
            Move Self   To hoID
        End_Object
            // Fill...
        For iLine From iStart To iEnd
            Get value Item iLine                                            To sLine
            Send AddItem To hoID sLine
        End
        Get CreateCode Of hoID To sRet
        Move (CM_InsertText(Self,sRet,iEnd+1,0)) To iRet
    End_Procedure

        // Converts a C DLLImport declaration into a VDF format.
    Procedure ConvertCDllCallToVDF
        String sLine sLineNew
        Integer iLine iRet
        Get Current_Item                            To iLine
        Get value Item iLine                        To sLine    // Should delive the current line.
        Move (gfsConvertCDllCallToVDF(sLine))       To sLineNew
        Move ("/"+"/"+sLine)                        To sLine
        Set value                                   To sLine
        Append sLineNew (Character(13)) (Character(10))
        Move (CM_InsertText(Self,sLineNew,iLine,0)) To iRet
    End_Procedure

        // Converts a Selected C Struct to a VDF Type.
    Procedure ConvertCStructToVDF
        Integer hoID iStart iEnd iLine iRet
        String  sLine
        Get CM_GetSel False                                                 To iRet
        Get piSelStartLine                                                  To iStart
        Get piSelEndLine                                                    To iEnd
            // Is the selection Is done From bottom To top, exchange the Values.
        If (iStart Gt iEnd) Begin
            Move iStart                                                     To iLine
            Move iEnd                                                       To iStart
            Move iLine                                                      To iEnd
        End
        Object oCPPDataConverter Is a cCPPDataConverter
            Move Self   To hoID
        End_Object
            // Fill the cCPPDataConverter
        For iLine From iStart To iEnd
            Get value Item iLine                                            To sLine
            Send AddItem To hoID sLine
        End
            // Convert the contents.
        Send Convert To hoID
            // And insert it again into the Edit.
        For iLine From 0 To (Item_Count(hoID)-1)
            Get value Of hoID Item iLine                                    To sLine
            Set Value Item (iLine+iStart)                                   To sLine
        End
    End_Procedure


        // Fills in the Info of the Element in the given Line.
        // With iType you can force an ElementType
        // eg.: (MK_OBJECT+MK_CLASS) only Object or class are filled, if the current is
        // a Procedure it tries to find the parent element until the forced type is sathiesfied.
    Function GetElementFromLine Integer iType Integer iLine Returns Integer
        Integer iRet
        Get LineToItemEx  Of (phoParser(Self)) iType iLine To iRet
        Function_Return iRet
    End_Function

        // Fills in the Info of the Element in the currentLine
        // With iType you can force an ElementType
        // eg.: (MK_OBJECT+MK_CLASS) only Object or class are filled, if the current is
        // a Procedure it tries to find the parent element until the forced type is sathiesfied.
    Function GetCurrentElement Integer iType Returns Integer
        Integer iRet
        Get CM_GetSel False To iRet
        If iRet Begin
            Get LineToItemEx  Of (phoParser(Self)) iType (piSelEndLine(Self))   To iRet
            Function_Return iRet
        End
        Function_Return 0
    End_Function


        // Delivers the reference of the current element.
        // Like: ProcedureXXX.ObjectXX.ParentObjectXX
    Function GetCurrentRef Returns String
        String sRef
        If (GetCurrentElement(Self,MK_OBJECT)) Get psCEl_psRef Of (phoParser(Self)) To sRef
        Function_Return sRef
    End_Function
        // Delivers the Reference from the given Line (only object)
    Function GetRefFromLine Integer iLine Returns String
        String sRef
        If (GetElementFromLine(Self,MK_Object,iLine)) Get psCEl_psRef Of (phoParser(Self)) To sRef
        Function_Return sRef
    End_Function



    Function GetCurrentRefComplete Returns String
        String sRef
        If (GetCurrentElement(Self,0)) Get psCEl_psRef Of (phoParser(Self)) To sRef
        Function_Return sRef
    End_Function

    Procedure ShowLanguageList Integer iFlag Integer iMode
        Integer iRet hoParser iLine hoID hoListObject iCmd
        String  sRef sLine sTest
        Pointer pTest
        Get phoParser           To hoParser
        If iFlag Begin
            Move (GetCurrentRefComplete(Self))  To sRef // No matter which type.
            Move (ReplaceAllMethods(sRef))      To sRef // Remove Procedures and Functions
            Send FillCurrentPosition                    // Retrieve the Obsolute Position of the cursor
            Get CM_GetSel False To iRet                 // Retrieve Line and Column in the Edit.
            Set  piInListCol    To (piSelEndCol(Self))  // and
            Set  piInListLine   To (piSelEndLine(Self)) // save them.
            Move (piSelEndLine(Self))   To iLine

            Case Begin
                Case (iMode Eq MK_LR_OBJECTS)
                    // only for forcing a flyout (copy text to small buffer ;-)
                    //Move (Character(0)) to sTest
                    //getaddress Of sTest to pTest
                    //Move (SendMessage(Window_Handle(self), CMM_GETTEXT, 0, pTest ) ) to iRet

                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_OBJECTS
                    Set piSourceObject Of hoListObject To hoParser
                    Set piSourceLine Of hoListObject To iLine
                    Set psSourceRefVal Of hoListObject To sRef
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode Eq MK_LR_VARS)
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_VARS
                    Set piSourceObject Of hoListObject To hoParser
                    Set piSourceLine Of hoListObject To iLine
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode Eq MK_LR_KEYS)
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_KEYS
                    Set piSourceObject Of hoListObject To (oKeysArray(Self))
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode Eq MK_LR_IDETAGS)
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_IDETAGS
                    Set piSourceObject Of hoListObject To (oIDETagsArray(Self))
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode Eq MK_LR_COMMANDS)
                    Get phoCodelisthandler to hoListObject
                    Set piListReason of hoListObject to MK_LR_COMMANDS
                    Set piSourceObject of hoListObject to (oCommandsArray(Self))
                    Get CM_ExecuteCmd CMD_CODELIST 0 to iCmd
                    Case Break
                Case (iMode Eq MK_LR_TYPES)
                    Get phoCodelisthandler to hoListObject
                    Set piListReason of hoListObject to MK_LR_TYPES
                    Set piSourceObject of hoListObject to (oTypesArray(Self))
                    Get CM_ExecuteCmd CMD_CODELIST 0 to iCmd
                    Case Break
                Case (iMode Eq MK_LR_ATTRIBUTES)
                    Get phoCodelisthandler to hoListObject
                    Set piListReason of hoListObject to MK_LR_ATTRIBUTES
                    Set piSourceObject of hoListObject to (oAttrArray(Self))
                    Get CM_ExecuteCmd CMD_CODELIST 0 to iCmd
                    Case Break
                Case (iMode Eq MK_LR_PROCEDURES)
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_PROCEDURES
                    Set piSourceObject Of hoListObject To hoParser
                    Set piSourceLine Of hoListObject To iLine
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode Eq MK_LR_FUNCTIONS)
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_FUNCTIONS
                    Set piSourceObject Of hoListObject To hoParser
                    Set piSourceLine Of hoListObject To iLine
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode Eq MK_LR_DATABASEFIELDS)
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_DATABASEFIELDS
                    Set piSourceObject Of hoListObject To (oFDFileReader(Self))
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode Eq MK_LR_CLASSES)
                    Get Value           To sLine
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_CLASSES
                    Set psSourceLine Of hoListObject To sLine
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
                Case (iMode = MK_LR_DATAFILES)
                    Get phoCodelisthandler to hoListObject
                    Set piListReason of hoListObject to MK_LR_DATAFILES
                    Set piSourceObject of hoListObject to (oDataFilesArray(Self))
                    Send Fill to (oDataFilesArray(Self))
                    Get CM_ExecuteCmd CMD_CODELIST 0 to iCmd
                    Case Break
                Case (iMode Eq MK_LR_INDEXES)
                    Get phoCodelisthandler To hoListObject
                    Set piListReason Of hoListObject To MK_LR_INDEXES
                    Set piSourceObject Of hoListObject To (fhoIndexArray(oIndexReader(Self)))
                    Get CM_ExecuteCmd CMD_CODELIST 0 To iCmd
                    Case break
            Case End
        End
    End_Procedure

    Function isReasonForCommandList Integer iLastKey String sLine Returns Integer
        If (not(pbShowCommands(ghoEditorProperties))) Function_Return 0
        Integer iLine iRet
        Move (Uppercase(Trim(sLine)))   To sLine
        If (iLastKey <> VK_Space) Begin
            If ((sLine<>"")and(Left(sLine,1)<>"/")and(Pos(' ', sLine)=0)and(Length(sLine)=1)) Begin
                Function_Return 1
            End
        End
        Function_Return 0
    End_Function
    
    Function isReasonForDataFileList Integer iLastKey String sLine Returns Integer
        If (not(pbShowCommands(ghoEditorProperties))) Function_Return 0
        String sCmd
        Handle hoLine
        Move (Trim(Uppercase(sLine))) to sLine
        If (iLastKey = VK_Space) Begin
            Get ParseLineTmp " " True sLine to hoLine
            Get Value of hoLine item 0        to sCmd
            If (("OPEN"=sCmd) or ("CLOSE"=sCmd) or ("REREAD"=sCmd) or ("CLEAR"=sCmd) or ;
                ("SAVE"=sCmd) or ("SAVERECORD"=sCmd) or ("DELETE"=sCmd) or ;
                ("RELATE"=sCmd)  or ("ATTACH"=sCmd))                        Function_Return 1
            If ((sCmd = "FIND") and (Item_Count(hoLine)=2))                 Function_Return 1
            If ((sCmd = "CONSTRAINED_FIND") and (Item_Count(hoLine)=2))     Function_Return 1
            If ((sCmd = "CONSTRAINED_CLEAR") and (Item_Count(hoLine)=2))    Function_Return 1
            If ((sCmd = "FOR_ALL") and (Item_Count(hoLine)=1))              Function_Return 1
        End
        Function_Return 0
    End_Function
    
    Function isReasonForAttrList Integer iLastKey String sLine Returns Integer
        If (not(pbShowAttributes(ghoEditorProperties))) Function_Return 0
        Move (Trim(Uppercase(sLine))) to sLine
        If (("GET_ATTRIBUTE"=sLine) or ("SET_ATTRIBUTE"=sLine)) Function_Return 1
        Function_Return 0
    End_Function

    Function isReasonForTypeList Integer iLastKey String sLine Returns Integer
        Handle hoID
        String sCmd
        If (not(pbShowTypes(ghoEditorProperties))) Function_Return 0
        If (iLastKey = VK_Space) Begin
            Move (Uppercase(Trim(sLine)))   to sLine
            Get ParseLineTmp " " True sLine to hoID
            Get Value of hoID item 0        to sCmd
            Move (Uppercase(sCmd))          to sCmd
            If ((sCmd="PROCEDURE") or (sCmd="FUNCTION")) Begin
                Get Value of hoID item (Item_Count(hoID)-1) to sCmd
                Move (Uppercase(sCmd))          to sCmd
                If (sCmd="RETURNS") Function_Return 1
            End
        End
        Function_Return 0
    End_Function

    //  Does the current typing request an autosuggester - IndexList
    //  Uh made it ab bit smarter
    //@ RRS made it a bit more smarter - hopefully
    Function isReasonForIndexList Integer iLastKey String sLine Returns Integer
        String sFile
        Integer hoID iOk iLine iRet
        String sCmd sNext sChr
        If (Not(pbShowIndexes(ghoEditorProperties))) Function_Return 0
        Move (Uppercase(Trim(sLine)))   To sLine
        If (iLastKey = VK_Space) Begin
            Move (Replaces("  ", sLine, " ")) To sLine
            Move (Replaces("( ", sLine, "(")) To sLine
            Move (Replaces(" )", sLine, ")")) To sLine
            Get ParseLineTmp " " True sLine To hoID
            Get Value Of hoID Item 0        To sCmd
            Move (Uppercase(sCmd))          To sCmd
            Move 0                          To iOk
            If ((sCmd = "FIND")And(Item_Count(hoId)=4)) Begin
                Get Value Of hoID Item 2 To sFile
                Move 1 To iOk
            End
            If ((sCmd = "CONSTRAINED_FIND")And(Item_Count(hoId)=4)) Begin //@
                Get Value Of hoID Item 2 To sFile
                Move 1 To iOk
            End
            If ((sCmd = "CONSTRAINED_CLEAR")And(Item_Count(hoId)=4)) Begin //@
                Get Value Of hoID Item 2 To sFile
                Move 1 To iOk
            End
            If ((sCmd = "FOR_ALL")And(Item_Count(hoId)=3))  Begin
                Get Value Of hoID Item 1 To sFile
                Move 1 To iOk
            End
            If ((sCmd = "SEND")And(Item_Count(hoId)=5))  Begin
                Get Value Of hoID Item 1 To sNext
                If (sNext="FIND") Begin
                    Get Value Of hoID Item 2 To sNext
                    If (sNext="TO") Get Value Of hoID Item 3 To sFile
                    Else            Get Value Of hoID Item 2 To sFile
                    Ifnot "_DD" In sFile Function_Return 0
                    Move "" To sNext
                    While (Length(sFile)<>0)
                        Move (Left(sFile, 1))               To sChr
                        Move (Replace(sChr, sFile, ""))     To sFile
                        If (sChr<>"(") Move (sNext+sChr)   To sNext
                        Else Begin
                            If "_DD" In sNext Move "" To sFile
                            Else              Move "" To sNext
                        End
                    Loop
                    Ifnot "_DD" In sNext Function_Return 0
                    Move (Replace("_DD", sNext,"")) To sFile
                    Send mInitObjectEx To (oIndexReader(Self)) (CurrentFileListPath(ghoWorkSpaceHandlerEx)) (CurrentDataPath(ghoWorkSpaceHandlerEx)) sFile 1 // No prefix
                    Move 0 To iOk
                    If (Item_Count(oIndexReader(Self))) Function_Return 1
                End
            End
            If (iOk) Begin
              //@RRS Start
              Get CM_GetSel False To iRet
              Move (piSelEndLine(Self)) To iLine
              Get value Item iLine To sLine
              Move (NormalizeText(sLine)) To sLine
              Get CM_DeleteLine iLine To iRet
              Get CM_InsertLine iLine sLine To iRet
              Set piSelEndCol To (Length(sLine))
              // **WvA; Scintilla needs the cursor position restored, or else your cursor ends up at the start of the line
              Get CM_SetSel iLine (piSelEndCol(Self)) iLine (piSelEndCol(Self)) False to iRet
              //@RRS End
              Send mInitObjectEx To (oIndexReader(Self)) (CurrentFileListPath(ghoWorkSpaceHandlerEx)) (CurrentDataPath(ghoWorkSpaceHandlerEx)) sFile 0
              If (Item_Count(oIndexReader(Self))) Function_Return 1
            End
        End
        Function_Return 0
    End_Function

    Function FindFileInSearchPath String sPath String sFile Returns String
        String sInd
        If ";" In sPath Begin
            While ";" In sPath
                Move (Left(sPath, (Pos(";", sPath)-1))) To sInd
                Move (Trim(Replace((sInd+";"), sPath, ""))) To sPath
                // **WvA: 07-06-2006 fix error on typing dots if file not exists
                // ignore file not open errors
                Send Ignore_Error of Error_Object_Id 33
                Direct_Input (sInd+"\"+sFile)
                Send Trap_Error of Error_Object_Id 33
                    If (Not(seqeof)) Begin
                        Close_Input
                        Function_Return (sInd+"\"+sFile)
                    End
                Close_Input
            Loop
        End
        Send Ignore_Error of Error_Object_Id 33
        Direct_Input (sPath+"\"+sFile)
        Send Trap_Error of Error_Object_Id 33
            If (Not(seqeof)) Begin
                Close_Input
                Function_Return (sPath+"\"+sFile)
            End
        Close_Input
        Function_Return ""
    End_Function

    Function ExtractDataFileName String sPart Returns String
        Integer iCnt
        String  sFile sChr
        // Reduce the string first... expected "FILENAME."
        Move (Left(sPart, (Length(sPart)-9) )) To sFile
        If (sFile<>"") Move (Replace(sFile, sPart, "")) To sPart
        If (sPart="")  Move sFile To sPart
        Move "" To sFile
        For iCnt From 1 To (Length(sPart)-1)
            Move (Mid(sPart, 1, iCnt)) To sChr
            If (Uppercase(sChr)) In "QWERTYUIOPASDFGHJKLZXCVBNM_0123456789" Move (sFile+sChr) To sFile
            Else Move "" To sFile
        Loop
        Function_Return (sFile+".FD")
    End_Function

        // Does the current typing request an autosuggester - FieldList
        // ** SVN fix for FD files search... (do not popups TH files if same name)
    //@ RRS Mod to Function isReasonForFieldList
    Function isReasonForFieldList Integer iLastKey String sLine Returns Integer
        String  sPart sPath

        If (Not(pbShowFields(ghoEditorProperties))) Function_Return 0
        If (MapVirtualKey(iLastKey,2)) Eq (Ascii(".")) Begin
            Get CM_GetCurrentWord3 To sPart
            If (Right(Trim(sPart),1)) Eq "." Begin
              Get ExtractDataFileName sPart To sPart
              If sPart Ne "" Begin
                Get FindFileInSearchPath (CurrentDDSrcPath(ghoWorkSpaceHandlerEx)) sPart To sPath
                If (sPath="")  Get FindFileInSearchPath (CurrentAppSrcPath(ghoWorkSpaceHandlerEx)) sPart To sPath
                If (sPath="")  Get FindFileInSearchPath (CurrentDataPath(ghoWorkSpaceHandlerEx)) sPart   To sPath
                If (sPath<>"") Begin
                  Send ReplaceCurrentWord2 (NormaLizeString(Replace(".FD",sPart,"")))
                  Send Fill To (oFDFileReader(Self)) sPath
                  Function_Return 1
                End
              End
            End
        End
    End_Function

    
    //
    // Tests the word under the cursor against the current datafiles.
    // If it is a match for a table name then it will return the path to the table
    // The full path will return a .int or .dat filename. (tests are in that order
    // we do not verify what's in the filelist at this stage)
    //
    Function isCurrentWordaTable String sWord Returns String
        Boolean bExists
        String  sPart sPath
        String  sTableName

        Move "" To sTableName
        If (Pos(".",sWord)) Begin
          Move (Left(sWord,Pos(".",sWord)-1)) To sPart
        End
        Else Move sWord To sPart

        Get ExtractDataFileName (sPart+".") To sPart   // got a .FD filename here
        If (sPart <> "") Begin
          Get FindFileInSearchPath (CurrentDDSrcPath(ghoWorkSpaceHandlerEx)) sPart To sPath
          If (sPath="")  Get FindFileInSearchPath (CurrentAppSrcPath(ghoWorkSpaceHandlerEx)) sPart To sPath
          If (sPath="")  Get FindFileInSearchPath (CurrentDataPath(ghoWorkSpaceHandlerEx)) sPart   To sPath
          If (sPath<>"") Begin
            Move (Replace(".FD",sPart,".INT")) To sPart
            Get FindFileInSearchPath (CurrentDataPath(ghoWorkSpaceHandlerEx)) sPart To sPath
            // Does the file exist?
            If (sPath<>"") Begin
              Get vFilePathExists sPath To bExists
              If (bExists) Begin
                Move sPath To sTableName
              End
            End
            Else Begin
              Move (Replace(".INT",sPart,".DAT")) To sPart
              Get FindFileInSearchPath (CurrentDataPath(ghoWorkSpaceHandlerEx)) sPart To sPath
              If (sPath<>"") Begin
                Get vFilePathExists sPath To bExists
                If (bExists) Begin
                  Move sPath to sTableName
                End
              End
            End
          End
        End
        Function_Return sTableName
    End_Function

    //@ New Function
    Function IsReasonForNormalizeDBText Integer iLastKey String sLine Returns Integer
        Integer hoID iRet iLine isOK
        String sCmd sPart sPath

        If iLastKey Eq VK_RETURN Move 1 To isOK
        If (isOK=0) If iLastKey Eq VK_SPACE   Move 1 To isOK
        //If (isOK=0) If iLastKey Eq VK_DOWN  Move 1 To isOK
        //If (isOK=0) If iLastKey Eq VK_UP    Move 1 To isOK

        If (isOK) Begin
          //Move (piSelEndLine(Self)) To iLine
          //Get value Item iLine To sLine
          //showln iLine ' : ' sLine

          Move (Uppercase(Trim(sLine)))   To sLine
          Move (Replaces("  ", sLine, " ")) To sLine
          Move (Replaces("( ", sLine, "(")) To sLine
          Move (Replaces(" )", SLINE, ")")) To SLINE

          Get CM_GetSel False To iRet
          Get PARSELINETMP " " True SLINE To HOID
          Get Value Of hoID Item 0        To sCmd

          If (sCmd="OPEN"   Or ;
              sCmd="CLEAR"  Or ;
              sCmd="RELATE" Or ;
              sCmd="REREAD" Or ;
              sCmd="SAVE"   Or ;
              sCmd="SAVERECORD"   Or ;
              sCmd="DELETE"       Or ;
              sCmd="DELETERECORD" Or ;
              sCmd="CLOSE"        Or ;
              sCmd="FILE_MODE"    Or ;
              sCmd="FILE_SIZE")  Begin

              //@START
              Get Value Of hoID Item 1 To sPart
              If (sPart<>'') Begin
                Move (sPart+'.FD') To sPart
                //@showln 'IsReasonForNormalizeDBText.sPart=' sPart //@
                Get FindFileInSearchPath (CurrentDDSrcPath(ghoWorkSpaceHandlerEx)) sPart To sPath
                If (sPath="")  Get FindFileInSearchPath (CurrentAppSrcPath(ghoWorkSpaceHandlerEx)) sPart To sPath
                If (sPath="")  Get FindFileInSearchPath (CurrentDataPath(ghoWorkSpaceHandlerEx)) sPart   To sPath
                //@ showln 'IsReasonForNormalizeDBText.sPath=' sPath //@
                If (sPath<>"") Begin
                  Set piSelEndCol To (Length(sLine))
                  Send ReplaceCurrentWord2 (NormaLizeString(Replace(".FD",sPart,"")))
                End
              End
              //@End
          End
        End
        //Set pbShowKeys of ghoEditorProperties to True
    End_Function


        // Does the current typing request an autosuggester - OBJECTLIST
    Function isReasonForObjectList Integer iLastKey String sLine Returns Integer
        If (Not(pbShowObjects(ghoEditorProperties))) Function_Return 0
        If iLastKey Eq VK_Space Begin
            If  (("GET " Eq Uppercase(Left(sLine,4))) Or ("SET " Eq Uppercase(Left(sLine,4)))) Begin
                If (Right(sLine,3)) Eq " of" Function_Return 1
            End
            If "SEND " Eq (Uppercase(Left(sLine,5))) Begin
                If (Right(sLine,3)) Eq " to" Function_Return 1
                Else  // **WvA: 11-07-2004 Adds support for "Send <method> Of <object>"
                If (Right(sLine,3)) Eq " of" Function_Return 1
            End
        End
    End_Function
        // Does the current typing request an autosuggester - KEYLIST
    Function isReasonForKeyList Integer iLastKey String sLine Returns Integer
        If (Not(pbShowKeys(ghoEditorProperties))) Function_Return 0
        If iLastKey Eq VK_Space Begin
            If "ON_KEY" Eq (Uppercase(Trim(sLine))) Begin
                Function_Return 1
            End
            If "ON_KEY " Eq (Uppercase(Left(sLine,7))) Begin
                If (Right(sLine,1)) Eq "+" Function_Return 1
            End
        End
        If iLastKey Eq VK_ADD Begin
            If "ON_KEY " Eq (Uppercase(Left(sLine,7))) Begin
                Function_Return 1
            End
        End
    End_Function

        // Does the current typing request an autosuggester - IDETAG List
    Function isReasonForIDETAGList Integer iLastKey String sLine Returns Integer
        String sUpStartLine
        If (not(pbShowIDETags(ghoEditorProperties))) Function_Return 0
        If iLastKey Eq VK_Space Begin
            Move (Uppercase(Trim(sLine))) To sUpStartLine
            If ( ("/"+"/A" Eq sUpStartLine) Or ("/"+"/D" Eq sUpStartLine) Or ("/"+"/I" Eq sUpStartLine)) Begin
                Function_Return 1
            End
        End
    End_Function

        // Does the current typing request an autosuggester - CREATOR
    Function isReasonForCreator Integer iLastKey String sLine Returns Integer
        String sTmp
        If iLastKey Eq VK_RETURN Begin
            Append sTmp "@" (Lowercase(Trim(sLine))) "@"
            If sTmp In "@get@set@move@send@" Function_Return 1
        End
    End_Function
        // Does the current typing request an autosuggester - PROCEDURELIST
    Function isReasonForProcedureList Integer iLastKey String sLine Returns Integer
        If (Not(pbShowMethods(ghoEditorProperties))) Function_Return 0
        If iLastKey Eq VK_SPACE If (Uppercase(Trim(sLine))) Eq "PROCEDURE" Function_Return 1
    End_Function
        // Does the current typing request an autosuggester - PROCEDURELIST
    Function isReasonForFunctionList Integer iLastKey String sLine Returns Integer
        If (Not(pbShowMethods(ghoEditorProperties))) Function_Return 0
        If iLastKey Eq VK_SPACE If (Uppercase(Trim(sLine))) Eq "FUNCTION" Function_Return 1
    End_Function
        // Does current typing request an autosuggester - CLASSLIST
    Function isReasonForClassList Integer iLastKey String sLine Returns Integer
        Integer iOK
        If (Not(pbShowClasses(ghoEditorProperties))) Function_Return 0
        If iLastKey Ne VK_SPACE Function_Return 0
        Move (Uppercase(Trim(sLine)))   To sLine
        If ((Right(sLine,2) Eq " A") Or (Right(sLine,3) Eq " AN")) Begin
            If (Left(sLine,6)) Eq "CLASS "  Function_Return 1
            If (Left(sLine,7)) Eq "OBJECT " Function_Return 1
        End
    End_Function

    Function isReasonForCodeTip Integer iLastKey String sLine Returns Integer
        If iLastKey Ne VK_SPACE Function_Return 0
        If (Not(pbCodeTipAutoPopup(phoIniHandler(Self)))) Function_Return 0
        Move (uppercase(" " + sLine)) To sLine
        If (Pos(" GET ",sLine)) Ne 0 Function_Return 1
        If (Pos(" SEND ",sLine)) Ne 0 Function_Return 1
    End_Function

        // Tests if the auto list shall come up.
    Function isListReason Integer iLastKey Returns Integer
        String sLine sTmp
        Get value               To sLine
        Move (Lowercase(sLine)) To sLine
        Move (Trim(sLine))      To sLine
        If (isReasonForObjectList(Self,iLastKey,sLine))     Function_Return MK_LR_OBJECTS
        If (isReasonForCreator(Self,iLastKey,sLine))        Function_Return MK_LR_CREATOR
        If (isReasonForProcedureList(Self,iLastKey,sLine))  Function_Return MK_LR_PROCEDURES
        If (isReasonForFunctionList(Self,iLastKey,sLine))   Function_Return MK_LR_FUNCTIONS
        If (isReasonForKeyList(Self,iLastKey,sLine))        Function_Return MK_LR_KEYS
        If (isReasonForFieldList(Self,iLastKey,sLine))      Function_Return MK_LR_DATABASEFIELDS
        If (isReasonForClassList(Self,iLastKey,sLine))      Function_Return MK_LR_CLASSES
        If (isReasonForDataFileList(Self,iLastKey,sLine))   Function_Return MK_LR_DATAFILES
        If (isReasonForIndexList(Self,iLastKey,sLine))      Function_Return MK_LR_INDEXES
        If (isReasonForIDETAGList(Self,iLastKey,sLine))     Function_Return MK_LR_IDETAGS
        If (isReasonForCommandList(Self,iLastKey,sLine))    Function_Return MK_LR_COMMANDS
        If (isReasonForTypeList(Self,iLastKey,sLine))       Function_Return MK_LR_TYPES
        If (isReasonForAttrList(Self,iLastKey,sLine))       Function_Return MK_LR_ATTRIBUTES
        If (isReasonForCodeTip(Self,iLastKey,sLine)) Begin
            Send CodeTip
            Function_Return MK_LW_NO
        End
        If (IsReasonForNormalizeDBText(Self,iLastKey,sLine)) Function_Return 0
    End_Function

    Procedure DestroyObject_Extentions
        Send Request_Destroy_Object
    End_Procedure

    Procedure StartFillList
        String sFile
        //send Delete_Data    to (oObjects(Self))
        Get GetFileName     To sFile
        Send StartFillList  To (phoElements(Self)) sFile
    End_Procedure
    Procedure EndFillList
        Integer iC iCount
        Move 0 To iC
        // Changed this loop that items that are no longer valid (deleted) are really deleted
        // and not only set to "" (speeds up the search a little bit)
        // 28.1.2003 BP
        While (iC Lt (item_count(oItems(Self))))
            If (Value(oItemsTouched(Self),iC)) Ne "J" Begin
                Send DeleteEntry    To (phoElements(Self)) (Value(oItemHandles(Self),iC))
                Send delete_item To (oItemsTouched(Self)) iC
                Send delete_item To (oItemHandles(Self)) iC
                Send delete_item To (oItems(Self)) iC
            End
            Else Begin
                Set value Of (oItemsTouched(Self)) Item iC To ""
                Increment iC
            End
        End
        Send EndFillList To (phoElements(Self))
    End_Procedure

    Procedure NewUsedFile String sFile
        Integer iC
        Get Find_Element Of (oUsedFiles(Self)) sFile        To iC
        If iC Lt 0 Send Add_Element To (oUsedFiles(Self)) sFile
        Send AddFile To (phoElements(Self)) sFile False
    End_Procedure

    Procedure RemoveAllFiles
        Integer hoID iC
        String  sFile
        Move (oUsedFiles(Self)) To hoID
        For iC From 0 To (Item_Count(hoID)-1)

            Send RemoveFile To (phoElements(Self)) (Value(hoID,iC))
        End

        Get GetFileName To sFile
        Send RemoveFile To (phoElements(Self)) sFile
    End_Procedure

    Procedure AddNewListEntry String sName String sClass String sRef Integer iParent Integer iPrev Integer iLine Integer iType Integer pElement
        Integer iRet iOldItem iC iItemCount
        Move (CString(sRef))    To sRef
        Move (CString(sClass))  To sClass
        Get Find_Element Of (oItems(Self)) sRef                         To iC
        If iC Ge 0 Get Value Of (oItemHandles(Self)) Item iC            To iOldItem
        Else       Get Item_Count Of (oItems(Self))                     To iC
        Set value Of (oItemsTouched(Self))  Item iC To "J"
        If iOldItem Begin
            Send UpdateLineNr To (phoElements(Self)) iOldItem iLine
            Procedure_Return iOldItem
        End
        Get Msg_AddNewListEntry Of (phoElements(Self)) iPrev sName sClass iParent iLine iType pElement To iRet
        Set Value Of (oItems(Self))         Item iC To sRef
        Set value Of (oItemHandles(Self))   Item iC To iRet
        Procedure_Return iRet
    End_Procedure

        // Rebuilds the
    Procedure ForceReBuildCodeView
        Send Delete_Data To (oItemsTouched(Self))
        Send EndFillList
        Send Delete_Data To (oItems(Self))
        Send Delete_Data To (oItemHandles(Self))
        Send ParseBuffer
    End_Procedure
    
    //
    // Currently the parser only understands dataflex, do not try to parse
    // another language and then choke on that.
    //
    Function CanParseCurrentLanguage Returns Boolean
      Boolean bCanParse
      String  sLang
      
      Move False To bCanParse
      // ShowLanguageInfo
      Get CM_GetLanguage To sLang
      If (sLang="VDF" Or Uppercase(sLang)="PASCAL") Begin
        Move True To bCanParse
      End
      Function_Return bCanParse
    End_Function

        // Parses the Buffer and fills the TreeView.
    Procedure ParseBuffer
      Boolean bCanParse
      Integer hoID hoEd
      String  sLang

      //Procedure_return    // Skip parsing for the moment.
      [MKNoParsing] Procedure_Return
      Get CanParseCurrentLanguage To bCanParse
      If (bCanParse) Begin
        Set piOnce                  To True // For internal use...
        Move (phoParser(Self))      To hoID
        Move Self                   To hoED
        Get CM_GetLanguage          To sLang
        Set Language        of hoID To sLang
        Send CreateParseTask        To hoID hoED
        Send DoParsing          To hoID
      End
    End_Procedure


        // Is sent when a file was opened succesful.
        // and Rebuilds the object list.
    Procedure onPreOpenFile String sFile   //@
        //@SHOWLN (Name(self)) '::OnPreOpenFile:' sFile //@
        Send SetLanguage sFile             //@
    End_Procedure                          //@

    //@Procedure onPostOpenFile String sFile
    //@    SHOWLN (Name(self)) '::OnPostOpenFile:' sFile //@
    //@    Send SetLanguage sFile
    //@End_Procedure

        // Some Procedures to support a FloatingPopupMenu
        // 17.05.01 Bernhard
    Procedure FloatPaste
        Integer iRet
        Get CM_PASTE To iRet
    End_Procedure
    Procedure FloatCopy
        Integer iRet
        Get CM_COPY To iRet
    End_Procedure
    Procedure FloatCut
        Integer iRet
        Get CM_CUT To iRet
    End_Procedure
    Procedure FloatToggleWhitespace
        Integer iRet
        Get CM_EnableWhitespaceDisplay (Not(CM_IsWhitespaceDisplayEnabled(Self))) To iRet
    End_Procedure
    Procedure FloatMakeUppercase
        Integer iRet
        Get CM_ExecuteCmd CMD_UPPERCASESELECTION 0 To iRet
    End_Procedure
    Procedure FloatMakeLowercase
        Integer iRet
        Get CM_ExecuteCmd CMD_LOWERCASESELECTION 0 To iRet
    End_Procedure
    Procedure FloatUndo
        Integer iRet
        Get CM_UNDO To iRet
    End_Procedure
    Procedure FloatRedo
        Integer iRet
        Get CM_REDO To iRet
    End_Procedure
    Procedure FloatBookmarkToggle
        Integer iRet
        Get CM_ExecuteCmd CMD_BOOKMARKTOGGLE 0 To iRet
    End_Procedure
    Procedure FloatBookmarkClearAll
        Integer iRet
        Get CM_ExecuteCmd CMD_BOOKMARKCLEARALL 0 To iRet
    End_Procedure
    Procedure FloatBookmarkFirst
        Integer iRet
        Get CM_ExecuteCmd CMD_BOOKMARKJUMPTOFIRST 0 To iRet
    End_Procedure
    Procedure FloatBookmarkLast
        Integer iRet
        Get CM_ExecuteCmd CMD_BOOKMARKJUMPTOLAST 0 To iRet
    End_Procedure
    Procedure FloatBookmarkNext
        Integer iRet
        Get CM_ExecuteCmd CMD_BOOKMARKNEXT 0 To iRet
    End_Procedure
    Procedure FloatBookmarkPrevious
        Integer iRet
        Get CM_ExecuteCmd CMD_BOOKMARKPREV 0 To iRet
    End_Procedure
    Procedure FloatGotoIndentation
        Integer iRet
        Get CM_ExecuteCmd CMD_GOTOINDENTATION 0 To iRet
    End_Procedure
    Procedure FloatGotoMatchBrace
        Integer iRet
        Get CM_ExecuteCmd CMD_GOTOMATCHBRACE 0 To iRet
    End_Procedure

        // Macro procedures...
    Procedure FloatRecordMacro
        Integer iRet
        Get CM_ExecuteCmd CMD_RECORDMACRO 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro1
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO1 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro2
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO2 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro3
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO3 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro4
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO4 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro5
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO5 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro6
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO6 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro7
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO7 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro8
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO8 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro9
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO9 0 To iRet
    End_Procedure
    Procedure FloatPlayMacro10
        Integer iRet
        Get CM_ExecuteCmd CMD_PLAYMACRO10 0 To iRet
    End_Procedure

        // **SVN 18-01-2003
    Procedure CodeTip
        Integer iRet
        If (Not(pbCodeTipAutoPopup(phoIniHandler(Self)))) Procedure_Return
        If (piCodeTipHandle(Self)) Procedure_Return
        Get CM_ExecuteCmd CMD_CODETIP 0 To iRet
    End_Procedure

        // Conversion routines mapped to the poupmenu.
    Procedure FloatToggle_OnItem_AddItem
        Send Toggle_OnItem_AddItem
    End_Procedure
    Procedure FloatConvertCStructToVDF
        Send ConvertCStructToVDF
    End_Procedure
    Procedure FloatConvertCDllCallToVDF
        Send ConvertCDllCallToVDF
    End_Procedure
    Procedure FloatConvertVDFTypeToHandler
        Send ConvertVDFTypeToHandler
    End_Procedure
        // Inserts a colorvalue into the codemax edit
    Procedure FloatInsertColor
        Send InsertColorValue
    End_Procedure
        // Inserts a Bitmap reference into the codemax edit
    Procedure FloatInsertBitmap
        Send InsertBitmapValue
    End_Procedure
End_Class





#IFNDEF TH_SCINTILLA
    // Inits the control!
Move (CMRegisterControl(CM_VERSION))    To WindowIndex              // Registers the codemaxcontrol.

    // Registers commands for CodeMax so that these function can accesed in macros and keyAssignments
    // This does only the registration! the processing of these commands need to
    // done in the "Procedure onRegisteredCmd Integer iCmd"

    // File Menu. 1-9
CMDeclareCommand CMD_FileOpenFile               1 "FileOpenFile"            "Opens a file"
CMDeclareCommand CMD_FileSaveFile               2 "FileSaveFile"            "Saves the file"
CMDeclareCommand CMD_FileSaveFileAs             3 "FileSaveFileAs"          "Save file as..."
CMDeclareCommand CMD_FileSaveAll                4 "FileSaveAll"             "Saves all opened files"
CMDeclareCommand CMD_FileCloseFile              5 "FileCloseFile"           "Closes the file"
CMDeclareCommand CMD_FileCloseAllFiles          6 "FileCloseAllFiles"       "Closes all files"
CMDeclareCommand CMD_FileNewFile                7 "FileNewFile"             "Create a new file"

    // Options Menu 10-19
CMDeclareCommand CMD_FindInFiles                10 "FindInFiles"            "Search the text in multiple files"
CMDeclareCommand CMD_SelectWorkSpace            11 "SelectWorkSpace"       "Select another workspace to work in"

    // Build Menu 20-29
CMDeclareCommand CMD_BuildRun                   20 "BuildRun"                "Compiles and runs the main program (or current file if is '.SRC')"
CMDeclareCommand CMD_BuildRunCurrent            21 "BuildRunCurrent"         "Compiles and runs the current file"
CMDeclareCommand CMD_BuildCompileCurrent        22 "BuildCompile"            "Compiles the current file"
CMDeclareCommand CMD_BuildPreCompile            23 "BuildPrecompile"         "PreCompiles the current file"
CMDeclareCommand CMD_BuildExecute               24 "BuildExecute"            "Starts the main program (or current file if it is '.SRC') without compiling"
CMDeclareCommand CMD_BuildDebugRun              25 "BuildDebugRun"           "ReCompiles with debug info and starts the main program"
CMDeclareCommand CMD_BuildDebugRunCurrent       26 "BuildDebugRunCurrent"    "ReCompiles with debug info and starts the current program"

    // Window Menu. 40-49
CMDeclareCommand CMD_WindowSwitchToCodeView     40 "WindowSwitchToCodeView"   "Activates the codeview window"
CMDeclareCommand CMD_WindowSwitchToErrorView    41 "WindowSwitchToErrorView"  "Activates the error window"
CMDeclareCommand CMD_WindowSyncCodeView         42 "WindowSyncCodeView"       "Synchronizes the CodeView with cursorposition"
CMDeclareCommand CMD_WindowNextView             43 "WindowNextView"           "Activates the next view"
CMDeclareCommand CMD_WindowPreviousView         44 "WindowPreviousView"       "Activates the privious view"

    // Lists 50-59
CMDeclareCommand CMD_ListCreator                50 "ListCreator"              "Activates the Creator list"
CMDeclareCommand CMD_ListObjects                51 "ListObjects"              "Activates the Object List"
CMDeclareCommand CMD_ListVars                   52 "ListVariables"            "Activates the Variables List"
CMDeclareCommand CMD_ListKeys                   53 "ListKeys"                 "Activates the Keys List"
CMDeclareCommand CMD_ListProcedures             54 "ListProcedures"           "Activates the Procedures List (Overwriting)"
CMDeclareCommand CMD_ListFunctions              55 "ListFunctions"            "Activates the Functions List (Overwriting)"
CMDeclareCommand CMD_ListClasses                56 "ListClasses"              "Activates the Classes List"
CMDeclareCommand CMD_ListIDETags                57 "ListIDETags"              "Activates the List with IDE tags"


    // Mixed. 60-69
CMDeclareCommand CMD_ToggleComment              60 "ToggleComment"              "Toggled the current line comment"
CMDeclareCommand CMD_ToolsInsertHeaderGlobal    61 "ToolsInsertHeaderGlobal"    "Inserts a header into the current file (global)"
CMDeclareCommand CMD_ToolsInsertHeaderUser      62 "ToolsInsertHeaderUser"      "Inserts a header into the current file (userspecific)"
CMDeclareCommand CMD_OpenFileUnderCursor        63 "OpenFileUnderCursor"        "Tries to open the file under the current cursorposition"
CMDeclareCommand CMD_InsertRevisionMark         64 "InsertRevisionMark"         "Inserts a Revisionmark"
CMDeclareCommand CMD_InsertColor                65 "InsertColor"                "Inserts a RGB Color value"

    // Convertion 70-79
CMDeclareCommand CMD_ConvertOnItemToAddItem   70 "ConvertOnItemToAddItem"       "Converts On_Item block to send Add_Item and back"
CMDeclareCommand CMD_ConvertCStructToVDF      71 "ConvertCStructToVDF"          "Converts a C structure to VDF syntax"
CMDeclareCommand CMD_ConvertCDllCallToVDF     72 "ConvertCDllCallToVDF"         "Converts a C Dll call to VDF syntax"
CMDeclareCommand CMD_ConvertVDFTypeToHandler  73 "ConvertVDFTypeToHandler"      "Converts a VDF TYPE structure to a Handler class"

CMDeclareCommand CMD_MarkScopeBlock           74 "MarkScopeBlock"               "Marks the current Scope Begin/End block for the current Line"
// v3.0 by SVN
CMDeclareCommand CMD_MOVELINEUP               75 "MoveLineUp"                   "Moves selected editor's code line up"
CMDeclareCommand CMD_MOVELINEDOWN             76 "MoveLineDown"                 "Moves selected editor's code line down"
CMDeclareCommand CMD_DUPLICATESELECTION       77 "DuplicateSelection"           "Duplicates selection or code line"
#ENDIF

Register_Procedure ContextSensitiveHelp            // WvA: 06-05-2002 Context Help Key


// Short note: // **WvA Translated doc from german to english
//
//  1.There is a criteria that leads to Ausloesen of a List
//  2.Down- and UpArrow are rerouted to the list
//  3.



#IFDEF TH_SCINTILLA
  Use cSciLexer.pkg
  Use cEditorHotKey_Mixin.pkg
  Class cCodeEdit is a cSciLexer
    Import_Class_Protocol cEditorHotKey_Mixin
  End_Class
#ELSE
  Class cCodeEdit is a cCodeMaxEdit
  End_Class
#ENDIF
    // Editor class for the codemax editor.
Class cEditorEdit Is a cCodeEdit
    Import_Class_Protocol cEditExtentionsMixin

    Procedure Construct_Object
        Integer iRet
        Forward Send Construct_Object
        Property Integer piInSetFocus              0
        Property Integer phoIniHandler             ghoEditorProperties
        Property String  psFileName                ""
        Property Number  pnFileTimeStamp           0
        Property Integer piLastKeyTranslated       False
        Property String  psOpenBracketTip          ""
        Send Define_cEditExtentionsMixin
        On_Key Key_F1 Send ContextSensitiveHelp  // Used to be ctrl+F1, which unfortunately is out of sync with DAWs
        On_Key Key_Ctrl+Key_F1 Send Help         // as that depends on muscle memory bring it back in sync.
        //On_Key Key_Ctrl+Key_O Send doAdjustTextCase // only here for quick testing will be removed

        Property Integer piEnterIsDown             0
        Set phoCodeTipHandler   To ghoCodeTip
        Set phoCodeListHandler  To ghoCodeList
        Property Integer piLastLineNumber          0
        Property Integer piCurrClassID             0
        Property Integer piProcedureState          0 // Parameters are inserted too.
    End_Procedure

    Procedure end_construct_object
        Forward Send end_construct_object
        Object oRevisionMaskHandler Is a cRevisionMaskHandler
        End_Object

        On_Key kCancel Send Request_Cancel
    End_Procedure

    
    // Standard Interface Support
    // By SVN on 23/03/2017
    Function CanCut Returns Integer
        Function_Return (CM_CanCut(Self))
    End_Function
    Function CanCopy Returns Integer
        Function_Return (CM_CanCopy(Self))
    End_Function
    Function CanPaste Returns Integer
        Function_Return (CM_CanPaste(Self))
    End_Function
    Function CanUndo Returns Integer
        Function_Return (CM_CanUndo(Self))
    End_Function
    Function CanRedo Returns Integer
        Function_Return (CM_CanRedo(Self))
    End_Function
    Function CanDelete Returns Integer
        Function_Return (CM_CanCut(Self))
    End_Function
    Procedure Redo
        Integer iRet
        Get CM_Redo to iRet
    End_Procedure
    Procedure Undo
        Integer iRet
        Get CM_Undo to iRet
    End_Procedure
    Procedure Cut
        Integer iRet
        Get CM_Cut to iRet
    End_Procedure
    Procedure Delete
        Integer iRet
        Get CM_Cut to iRet
    End_Procedure
    Procedure Copy
        Integer iRet
        Get CM_Copy to iRet
    End_Procedure
    Procedure Paste
        Integer iRet
        Get CM_Paste to iRet
    End_Procedure
    //

    // **WvA 13-11-2004 Added logic to cancel the errorlistwindow
    // with the escape key. Just trying to avoid to have to use the
    // mouse too much ;)
    // This is similar to how it works in most other editors.
    Procedure Request_Cancel
      Boolean bErrorListVisible
      
      Get pbErrorListVisible Of ghoEditorProperties To bErrorListVisible
      If (bErrorListVisible) Begin
        Set pbErrorListVisible Of ghoEditorProperties    To False
        Send PAWindowErrorListONOFF False
      End
      Forward Send Request_Cancel
    End_Procedure // Request_Cancel
    
    //
    // For simulating keyboard navigation by sending VK_xxx keyboard commands with
    // postmessage WM_KEYDOWN / WM_KEYUP into the Windows message queue
    //
    Procedure PostVirtualKey Integer iVkKey
      Integer iRet
      
      Move (PostMessage (window_Handle(Self), WM_KEYDOWN, iVkKey, 0)) To iRet
      Move (PostMessage (window_Handle(Self), WM_KEYUP, iVkKey, 0)) To iRet
    End_Procedure

        //
    Function CodelistCurrentMethodValue String sVal Integer iRec Returns String
        Integer iCur
        String  sParas sName sRet
        Move sVal           To sName
        If (piProcedureState(Self)) Begin
            Clear Asdb
            Move iRec   To ASDB.RecNum
            Find Eq ASDB by RecNum
            If ASDB.SetCode Ne "" Move (Append("Set ",sVal))   To sVal
            Append sVal (ASDBParametersList(True))
            If "returns" In sVal Begin
                Move (Right(sVal,Length(sVal)-Pos("returns",sVal)-7))   To sRet
                Move (Trim(sRet))                                       To sRet
                Append sVal "\n\t\tab" "Local " sRet " " (Left(sRet,1)) "Ret"
                Append sVal "\n\t\tab" "Forward Get "
                If (piProcedureState(Self) Eq MK_PROC_PROCEDURE) Append sVal "Msg_"
                Append sVal sName (ASDBParametersList(False)) " to " (Left(sRet,1)) "Ret"
                If (piProcedureState(Self) Eq MK_PROC_PROCEDURE) Append sVal "\n\t\tabProcedure_Return " (Left(sRet,1)) "Ret"
                Else                                             Append sVal "\n\t\tabFunction_Return "  (Left(sRet,1)) "Ret"
            End
            Else Begin
                Append sVal "\n\t\tab" "Forward "
                If ASDB.SetCode Ne "" Append sVal "Set "
                Else                  Append sVal "Send "
                Append sVal sName (ASDBParametersList(False))
            End
            If (piProcedureState(Self) Eq MK_PROC_PROCEDURE) Append sVal "\n\t" "End_Procedure"
            Else                                             Append sVal "\n\t" "End_Function"
        End
        Function_Return sVal
    End_Function

    Function ClassCodeTemplate String sTab String sVal Returns String
        //____Procedure_Construct_Object...
        Append sVal "\n" sTab "\tab" "/" "/Insert your Properties here."
        Append sVal "\n" sTab "\tabProcedure Construct_Object"
        Append sVal "\n" sTab "\tab\tab" "Forward send Construct_Object"
        Append sVal "\n" sTab "\tabEnd_Procedure"

        //____Procedure_End_Construct_Object...
        Append sVal "\n" sTab "\tab" "/" "/Finish object construction"
        Append sVal "\n" sTab "\tabProcedure End_Construct_Object"
        Append sVal "\n" sTab "\tab\tab" "Forward send End_Construct_Object"
        Append sVal "\n" sTab "\tabEnd_Procedure"
        Append sVal "\n" sTab "End_Class"
        Function_Return (Trim(sVal))
    End_Function

    Function CodelistCurrentClassValue String sVal Returns String
//        String sLine sTab sRet
//        Integer isVar iIndent
//        Move (psSourceLine(phoCodelistHandler(Self))) To sLine
//        If (Left(Uppercase(Trim(sLine)),6)) Eq "CLASS " Begin
//            Move (Length(sLine)-Length(LTrim(sLine)))   To iIndent
//            Move (Repeat(" ",iIndent))                  To sTab
//
//            //____Procedure_Construct_Object...
//            Append sVal "\n" sTab "\tab\tab" "/" "/Insert your Properties here."
//            Append sVal "\n" sTab "\tabProcedure Construct_Object"
//            Append sVal "\n" sTab "\tab\tab" "Forward send Construct_Object"
//            Append sVal "\n" sTab "\tabEnd_Procedure"
//
//            //____Procedure_End_Construct_Object...
//            Append sVal "\n" sTab "\tab\tab" "/" "/Finish object construction"
//            Append sVal "\n" sTab "\tabProcedure End_Construct_Object"
//            Append sVal "\n" sTab "\tab\tab" "Forward send End_Construct_Object"
//            Append sVal "\n" sTab "\tabEnd_Procedure"
//            Append sVal "\n" sTab "End_Class"
//        End
        Function_Return (Trim(sVal))
    End_Function

    Function CodelistCurrentDataFileValue String sVal Returns String
        Function_Return (Trim(sVal))
    End_Function

    Function CodelistCurrentCommandValue String sVal Integer iRef Returns String
        Integer iStart
        Integer iItem iIndent
        String  sLine sTab
        // Indent
        Get CM_GetSel False to iStart
        Get piSelStartLine  to iStart
        Get value item iStart to sLine
        Move (Length(sLine)-Length(LTrim(sLine)))   to iIndent
        Move (Repeat(" ",iIndent))                  to sTab
        //
        Move (Codelist_current_item(phoCodelistHandler(Self))) to iItem
        Get Value of (oCommandsArray(Self)) item iItem to sVal
        If (Uppercase(sVal)="CLASS")        Get ClassCodeTemplate sTab sVal         to sVal
        If (Uppercase(sVal)="OBJECT")       Move (sVal+"\n"+sTab+"End_Object")      to sVal 
        If (Uppercase(sVal)="PROCEDURE")    Move (sVal+"\n"+sTab+"End_Procedure")   to sVal
        If (Uppercase(sVal)="FUNCTION")     Move (sVal+"\n"+sTab+"End_Function")    to sVal
        If (Uppercase(sVal)="FOR_ALL")      Move (sVal+"\n"+sTab+"\tabDo"+"\n\tab"+sTab+"\n"+sTab+"End_For_All")     to sVal
        If (Uppercase(sVal)="BEGIN")        Move (sVal+"\n"+sTab+"End")             to sVal
        Set piInListCol to (piInListCol(Self)-1)
        Function_Return sVal
    End_Function
    
    Function CodelistCurrentTypeValue String sVal Integer iRef Returns String
        Integer iStart
        Integer iItem iIndent
        String  sLine sTab sType sVar sMethod
        // Indent
        Get CM_GetSel False to iStart
        Get piSelStartLine  to iStart
        Get value item iStart to sLine
        //
        String sCloseStmt sName
        Handle hoLine
        Get value item (iStart+1) to sCloseStmt
        Move (Trim(sCloseStmt)) to sCloseStmt
        //
        Move (Length(sLine)-Length(LTrim(sLine)))   to iIndent
        Move (Repeat(" ",iIndent))                  to sTab
        Move "Function" to sMethod
        If (Left(Uppercase(Trim(sLine)), 4)="PROC") Move "Procedure" to sMethod
        // Trailing comment [ // mName (Type Function|Procedure) ]
        If ("END_"=Uppercase(Left(sCloseStmt, 4))) Begin
            Get ParseLineTmp " " True sLine to hoLine
            Get Value of hoLine item 1 to sName
            Move (sCloseStmt * "//" * sName * '('+sVal * sMethod +')') to sCloseStmt
            Set Value item (iStart+1) to sCloseStmt
        End
        //
        Move (Codelist_current_item(phoCodelistHandler(Self))) to iItem
        Get Value of (oTypesArray(Self)) item iItem to sVal
        //Set piInListCol to (piInListCol(Self)-1)
        Move (Uppercase(sVal)) to sType
        If      (sType="ADDRESS")    Move "aRetVal"      To sVar
        Else If (sType="BIGINT")     Move "biRetVal"     to sVar
        Else If (sType="BOOLEAN")    Move "bRetVal"      to sVar
        Else If (sType="CHAR")       Move "cRetVal"      to sVar
        Else If (sType="DATE")       Move "dRetVal"      to sVar
        Else If (sType="DATETIME")   Move "dtRetVal"     to sVar
        Else If (sType="HANDLE")     Move "hRetVal"      to sVar
        Else If (sType="INTEGER")    Move "iRetVal"      to sVar
        Else If (sType="NUMBER")     Move "nRetVal"      to sVar
        Else If (sType="POINTER")    Move "pRetVal"      to sVar
        Else If (sType="REAL")       Move "rRetVal"      to sVar
        Else If (sType="ROWID")      Move "riRetVal"     to sVar
        Else If (sType="SHORT")      Move "siRetVal"     to sVar
        Else If (sType="STRING")     Move "sRetVal"      to sVar
        Else If (sType="TIME")       Move "tmRetVal"     to sVar
        Else If (sType="TIMESPAN")   Move "tsRetVal"     to sVar
        Else If (sType="UBIGINT")    Move "ubiRetVal"    to sVar
        Else If (sType="UCHAR")      Move "ucRetVal"     to sVar
        Else If (sType="UINTEGER")   Move "uiRetVal"     to sVar
        Else If (sType="USHORT")     Move "usRetVal"     to sVar
        Else If (sType="VARIANT")    Move "vRetVal"      to sVar
        Else                         Move ("l"+sVal)     to sVar
        Move (sVal+"\n"+sTab+"\tab"+sVal*sVar+"\n"+sTab+"\tab"+sMethod+"_Return"*sVar) to sVal
        Function_Return sVal
    End_Function

    Function CodelistCurrentAttributeValue String sVal Integer iRef Returns String
        Integer iStart
        Integer iItem iIndent
        String  sLine sTab
        // Indent
        Get CM_GetSel False to iStart
        Get piSelStartLine  to iStart
        Get value item iStart to sLine
        Move (Length(sLine)-Length(LTrim(sLine)))   to iIndent
        Move (Repeat(" ",iIndent))                  to sTab
        //
        Move (Codelist_current_item(phoCodelistHandler(Self))) to iItem
        Get Value of (oAttrArray(Self)) item iItem to sVal
        //Set piInListCol to (piInListCol(Self)-1)
        Function_Return sVal // DF_FIELD_STORE_TIME
    End_Function

    Function CodelistCurrentObjectValue String sVal Integer iRef Returns String
        String sRef
        Integer isVar

        If iRef Eq -1 Function_Return sVal // desktop or variable

        Move (LTrim(sVal))                              To sVal
        Move (psSourceRefVal(phoCodelistHandler(Self))) To sRef
        Move (ReduceReference(sVal,sRef))               To sVal
        Move (ReferenceToObject(sVal))                  To sVal
        Function_Return sVal
    End_Function


    // **WvA: 11.07.2004 Added
    Function CodelistCurrentIDETagValue String sVal Returns String
      Handle hoIDETag
      Integer iItem

      Move (Codelist_current_item(phoCodelistHandler(Self))) To iItem
      Move (oIDETagsArray(Self)) To hoIDETag
      Get FindTagsForItem Of hoIDETag sVal To sVal
      Function_Return sVal
    End_Function // CodelistCurrentIDETagValue


    Procedure InsertCodelistText String sVal
        Integer iLine iCol iRet iLen
        Get CM_GetSel True To iRet
        Move (piSelEndLine(Self))                                       To iLine
        Move (piSelEndCol(Self))                                        To iCol
        Move (CM_SetSel(Self,iLine,piInListCol(Self),iLine,iCol,False)) To iRet
        Move (CM_DeleteSel(Self))                                       To iRet
        Send InsertTextAtPosition iLine (piInListCol(Self)) sVal
        If "\n" In sVal Move (Pos("\n",sVal)-1)                         To iLen
        Else Move (Length(sVal))                                        To iLen
        Move (piInListCol(Self)+iLen)                                   To iCol
        Move (CM_SetSel(Self,iLine,iCol,iLine,iCol,False))              To iRet
    End_Procedure

    Procedure CodelistSimulateEnter
        Integer iRet
#IFDEF TH_SCINTILLA
        Send DoKeyReturn
#ELSE
        Send PostVirtualKey VK_RETURN
#ENDIF
    End_Procedure

    // SVN CodeList support
    Procedure CM_CodeListItemSelected String sItem Integer iRefVal
        Integer iLine iCol iRet iLen iCodeTip iReason iShouldMakeEnter
        String sVal sLine sWord sFunc
        Set pbIsCodelistActive To False

        Move (piListReason(phoCodelistHandler(Self))) To iReason

        If iReason Eq MK_LR_INDEXES Get CM_GetCurrentWordIncludingDot To sWord
        Else Get CM_GetCurrentWord To sWord
        If ( (iReason Eq MK_LR_DATABASEFIELDS) And (sWord Eq ".") ) Move "" To sWord
        If (uppercase(sWord)) Eq (uppercase(Left(sItem,(length(sWord))))) Begin
        Case Begin
            Case (iReason Eq MK_LR_OBJECTS)
                Get CodelistCurrentObjectValue sItem iRefVal To sVal
                Send InsertCodelistText sVal
                Move 1 to iShouldMakeEnter
            Case Break
            Case (iReason Eq MK_LR_CLASSES)
                Get CodelistCurrentClassValue sItem To sVal
                Send InsertCodelistText sVal
                Move 0 to iShouldMakeEnter
            Case Break
            Case (iReason Eq MK_LR_PROCEDURES)
                Get CodelistCurrentMethodValue sItem iRefVal To sVal
                Send InsertCodelistText sVal
                Move 1 To iShouldMakeEnter
            Case Break

            Case (iReason Eq MK_LR_FUNCTIONS)
                Get CodelistCurrentMethodValue sItem iRefVal To sVal
                Send InsertCodelistText sVal
                Move 1 To iShouldMakeEnter
            Case Break

            Case ( (iReason Eq MK_LR_INDEXES) or (iReason Eq MK_LR_DATABASEFIELDS) or (iReason Eq MK_LR_VARS) or (iReason Eq MK_LR_KEYS) or (iReason Eq MK_LR_IDETAGS) or (iReason Eq MK_LR_COMMANDS) or (iReason Eq MK_LR_TYPES) or (iReason Eq MK_LR_ATTRIBUTES) or (iReason=MK_LR_DATAFILES))
                Move (Trim(sItem)) To sVal
                If (iReason Eq MK_LR_KEYS) Begin
                    Get value To sLine
                    Move (Mid(sLine,1,(piInListCol(Self)))) To sLine
                    If ( (sVal Eq "KEY_SHIFT") Or (sVal Eq "KEY_ALT") Or (sVal Eq "KEY_CTRL") ) Begin
                        If sLine Ne "(" Move ("("+sVal) To sVal
                        Move (sVal + "+") To sVal
                    End
                    Else Begin
                        If sLine Eq "+" Move (sVal+")") To sVal
                        Move (sVal + " Send") To sVal
                        Set piEnterIsDown To FALSE
                        Move 0 To iShouldMakeEnter
                    End
                End
                Else If (iReason Eq MK_LR_IDETAGS) Begin
                    Get CodelistCurrentIDETagValue sItem To sVal
                End
                Else If (iReason=MK_LR_COMMANDS) Begin
                    Get CodelistCurrentCommandValue sItem to sVal
                End
                Else If (iReason=MK_LR_DATAFILES) Begin
                    Get CodelistCurrentDataFileValue sItem to sVal
                End
                Else If (iReason=MK_LR_TYPES) Begin
                    Get CodelistCurrentTypeValue sItem to sVal
                End
                Else If (iReason=MK_LR_ATTRIBUTES) Begin
                    Get CodelistCurrentAttributeValue sItem to sVal
                End
                Send InsertCodelistText sVal
                If ( (iReason Eq MK_LR_KEYS) And ( (Right(sVal,1)) Eq "+") ) Begin
                    Set piInListCol To ( (piInListCol(Self)) + (length(sVal)) )
                    Get CM_GetSel True To iRet
                    Move (piSelEndLine(Self))   To iLine
                    Move (piSelEndCol(Self))    To iCol
                    Move (CM_SetSel(Self,iLine,(iCol-1),iLine,(iCol-1),False)) To iRet
                    Send Codelist_Beginning_Of_Data To (phoCodelistHandler(Self))
                    Set pbIsCodelistActive To True
                    Procedure_Return TRUE
                End
                If (iReason Eq MK_LR_DATABASEFIELDS) Begin  //@RRS
                  Set piEnterIsDown To False                //@RRS
                  Move 0 To iShouldMakeEnter                //@RRS
                End                                         //@RRS
                If (iReason Eq MK_LR_INDEXES) Begin
                  //@Move 1 To iShouldMakeEnter
                  Set piEnterIsDown To False                //@RRS
                  Move 0 To iShouldMakeEnter                //@RRS
                End
            Case Break

            Case Else
            Get CodeTipFunction Of (phoCodeTipHandler(Self)) sItem To sFunc
            Move sFunc              To sVal
            Get Value               To sLine
            Move (RTrim(sLine))     To sLine
            Get CM_GetCurrentWord   To sWord
            Move (Left(sLine,(Length(sLine)-Length(sWord)))) To sLine
            Move (Trim(Left(sVal, (Pos("(",sVal)-1)))) To sVal
            Move (sLine+sVal+"(") To sVal
            If sVal Ne "" Begin
                Get CM_GetSel True To iRet
                Move (piSelEndLine(Self))                                       To iLine
                Move (piSelEndCol(Self))                                        To iCol
                Append sVal " "
                Move (CM_SetSel(Self,iLine,0,iLine,iCol,False)) To iRet
                Move (CM_DeleteSel(Self))                                       To iRet
                Send InsertTextAtPosition iLine (piSelEndCol(Self)) sVal
                If "\n" In sVal Move (Pos("\n",sVal)-1)                         To iLen
                Else Move (Length(sVal))                                        To iLen
                Move (piInListCol(Self)+iLen-1)                                 To iCol
                Move (CM_SetSel(Self,iLine,iCol,iLine,iCol,False))              To iRet
            End
            Set psCodeTipCurrent    To sFunc
            Get pbCodeTipAutoPopup Of (phoIniHandler(Self)) To iCodeTip
            Set pbCodeTipAutoPopup Of (phoIniHandler(Self)) To True
            Send CodeTip
            Set pbCodeTipAutoPopup Of (phoIniHandler(Self)) To iCodeTip
            Case Break
        Case End
        End

        If ( (iReason Ge MK_LR_Objects) And ( (piEnterIsDown(Self)) Or (iShouldMakeEnter) ) ) begin
#IFNDEF TH_SCINTILLA
          Send CodelistSimulateEnter
#ENDIF
        End

        Set piListReason Of (phoCodelistHandler(Self)) To 0
        Set piSourceObject Of (phoCodelistHandler(Self)) To 0
        Send BlockKey VK_HOME   CM_KEY_CTRL  False
        Send BlockKey VK_END    CM_KEY_CTRL  False

        // Repositiones Cursor
        If ((iReason=MK_LR_COMMANDS)or(iReason Eq MK_LR_ATTRIBUTES)or(iReason=MK_LR_DATAFILES)) Begin
#IFDEF TH_SCINTILLA
            Send EditorMessage SCI_LINEEND
#ELSE
            Send PostVirtualKey VK_END
            //Send PostVirtualKey VK_SPACE
#ENDIF
        End
        If (iReason Eq MK_LR_TYPES) Begin
#IFDEF TH_SCINTILLA
            Send EditorMessage SCI_LINEDOWN
            Send EditorMessage SCI_LINEEND
#ELSE
            Send PostVirtualKey VK_DOWN
            Send PostVirtualKey VK_END
#ENDIF
            Send CodelistSimulateEnter
        End
        If (iReason Eq MK_LR_CLASSES) Begin
#IFDEF TH_SCINTILLA
            Send EditorMessage SCI_LINEDOWN
            Send EditorMessage SCI_LINEDOWN
            Send EditorMessage SCI_LINEDOWN
            Send EditorMessage SCI_LINEEND
#ELSE
            Send PostVirtualKey VK_DOWN
            Send PostVirtualKey VK_DOWN
            Send PostVirtualKey VK_DOWN
            Send PostVirtualKey VK_END
#ENDIF
            Send CodelistSimulateEnter
        End
    End_Procedure

    Procedure SelectClosestCodelistMatch
        String sWord
        Integer iRet

        If (piListReason(phoCodelistHandler(Self))) Eq MK_LR_INDEXES Get CM_GetCurrentWordIncludingDot To sWord
        Else                                                         Get CM_GetCurrentWord  To sWord
        
#IFDEF TH_SCINTILLA
        Send ShowAutoComplete sWord
#ELSE
        Get codelist_SelectClosestItem Of (phoCodelistHandler(Self)) sWord To iRet // make the item that matches closest the given value active
#ENDIF
        
    End_Procedure

    Procedure OnCodelistCancel
        Set piListReason   Of (phoCodelistHandler(Self)) To 0
        Set piSourceObject Of (phoCodelistHandler(Self)) To 0
        Set pbIsCodelistActive To False
        Send BlockKey VK_HOME   CM_KEY_CTRL  False
        Send BlockKey VK_END    CM_KEY_CTRL  False
    End_Procedure

        // Fills the Codelist with all Methods.
    Procedure FillCodeListWithMethodsData Integer iType Integer iProcState
        Integer hoParser iLine iRet
        String sCls
        Set piCurrClassID       To 0
        Set piProcedureState    To iProcState
        Move (piSourceObject(phoCodelistHandler(Self))) To hoParser
        Move (piSourceLine(phoCodelistHandler(Self))) To iLine
        If (LineToItemEx(hoParser,MK_OBJECT+MK_CLASS,iLine)) Begin
            Get psCEl_psClass   Of hoParser To sCls
            If sCls Ne "" Begin
                Send VDFCls_Search sCls 0 0
                [found] Begin
                    Set piCurrClassID   To VDFCLS.Code
                    Clear ASDB
                    Move VDFCLS.Code    To ASDB.VDFCls
                    Move iType          To ASDB.Type
                    Repeat
                        Find Gt ASDB by Index.3
                        If VDFCls.Code Ne ASDB.VDFCls Indicate found False
                        If iType       Ne ASDB.Type   Indicate found False
                        [found] Begin
                            Get Codelist_add_item Of (phoCodelistHandler(Self)) (Trim(asdb.name)) "" asdb.recnum To iRet
                            Indicate found True
                        End
                    Until [Not found]
                End
            End
        End
    End_Procedure

    Procedure FillCodelistWithArrayData
        Integer hoSource iItem iRet
        String sVal
        Move (piSourceObject(phoCodelistHandler(Self))) To hoSource
        Move ( (item_count(hoSource)) -1) To iItem
        While (iItem Ge 0)
            Get value Of hoSource Item iItem To sVal
            Get Codelist_add_item Of (phoCodelistHandler(Self)) sVal "" 0 To iRet
            Decrement iItem
        End
    End_Procedure

    Procedure FillCodelistWithVarData
        Integer hoSource iLine hoIDParas hoIDVars iRet iItem
        Move (piSourceObject(phoCodelistHandler(Self))) To hoSource
        Move (piSourceLine(phoCodelistHandler(Self))) To iLine
        Get  GetParameterListFromLine Of hoSource iLine     To hoIDParas
        Get  GetVariablenListFromLine Of hoSource iLine     To hoIDVars
        For iItem From 0 To (Item_Count(hoIDVars)-1)
            Get codelist_add_item Of (phoCodelistHandler(Self)) (Value2D(hoIDVars,iItem,0)) "" 0 To iRet
            //Send AddLine (Value2D(hoIDVars,iItem,0)) (Value2D(hoIDVars,iItem,1))
        End
        For iItem From 0 To (Item_Count(hoIDParas)-1)
            Get codelist_add_item Of (phoCodelistHandler(Self)) (Value2D(hoIDParas,iItem,0)) "" 0 To iRet
            //Send AddLine (Value2D(hoIDParas,iItem,0)) (Value2D(hoIDParas,iItem,1))
        End
    End_Procedure

    Procedure FillCodelistWithClassData
        String sBmp sLine
        Integer iRet hoCache iFound
        Move (psSourceLine(phoCodelistHandler(Self)))    To sLine
        Move (oClassDataCache(phoCodelistHandler(Self))) To hoCache
        If (item_count(hoCache)<>0) Begin
          Send FillCodelistFromCache To (phoCodelistHandler(Self))
        End  
        Else Begin
            Clear VDFCls
            Repeat
                Find Gt VDFCls by Index.1
                Move (found) To iFound
                [found] Indicate found as VDFCLS.Base Eq "Y"
                [found] Begin
                    Get codelist_add_CachedItem Of (phoCodelistHandler(Self)) (Trim(vdfcls.name)) (Trim(vdfcls.bitmap)) 0 To iRet
                End
                Indicate found as iFound
            Until [Not found]
        End
    End_Procedure

    Procedure FillCodelistWithObjectData
        Integer iC iItem  iTextMaxX iTextX iDel iCur hoParser iLine
        Integer hoIDVars hoIDParas hoIDDestroy hoID iVarType iRet
        String  sObj sCls sVarName sRef

        Move (piSourceObject(phoCodelistHandler(Self))) To hoParser
        Move (piSourceLine(phoCodelistHandler(Self))) To iLine
        Move (psSourceRefVal(phoCodelistHandler(Self))) To sRef

        // Add Desktop
        Get codelist_add_item Of (phoCodelistHandler(Self)) "Desktop" (ClassBitmaps(desktop,"Desktop",MK_CLASS)) -1 To iRet

        // Add Variables
        Get  GetVariablenListFromLine Of hoParser iLine     To hoIDVars
        For iItem From 0 To (Item_Count(hoIDVars)-1)
            Get value2D Of hoIDVars Item iItem 0           To sVarName
            Get value2D Of hoIDVars Item iItem 1           To iVarType
            If ((iVarType Eq MK_INTEGER) Or (iVarType Eq MK_HANDLE)) If (Left(Uppercase(sVarName),2)) Eq "HO" Begin
                Get codelist_add_item Of (phoCodelistHandler(Self)) sVarName "" -1 To iRet
            End
        End

        // Add Parameters
        Get  GetParameterListFromLine Of hoParser iLine     To hoIDParas
        For iItem From 0 To (Item_Count(hoIDParas)-1)
            Get value2D Of hoIDParas Item iItem 0           To sVarName
            Get value2D Of hoIDParas Item iItem 1           To iVarType
            If ((iVarType Eq MK_INTEGER) Or (iVarType Eq MK_HANDLE)) If (Left(Uppercase(sVarName),2)) Eq "HO" Begin
                Get codelist_add_item Of (phoCodelistHandler(Self)) sVarName "" -1 To iRet
            End
        End

        // AddObject

        Get GetObjectList            Of hoParser    To hoID         // Objects
        If hoID Begin
            For iC From 0 To (Item_Count(hoID)-1)
                Get Value2D Of hoID Item iC 0                       To sObj
                Get Value2D Of hoID Item iC 1                       To sCls
                Move (ReplaceAllMethods(sObj)) To sObj              // Remove Procedures and Functions
                Get codelist_add_item Of (phoCodelistHandler(Self)) sObj (ClassBitmaps(desktop,sCls,MK_CLASS)) iC To iRet
            End
        End
    End_Procedure

    //
    Function DoCodeListInit Handle hCodeList Returns Integer
        Integer iRet iUseBitmaps  hoSource hoIDParas hoIDVars iLine
        //
        Integer iItem iCnt iReason iStyle
        String  sFunc sWord sVal
        //
        Move (pbCodeListUseBitmaps(phoIniHandler(Self))) To iUseBitmaps
        Move (piListReason(phoCodelistHandler(Self))) To iReason
        Case Begin

        Case ( (iReason Eq MK_LR_INDEXES) or (iReason Eq MK_LR_DATABASEFIELDS) or (iReason Eq MK_LR_KEYS)or (iReason Eq MK_LR_IDETAGS)or (iReason Eq MK_LR_COMMANDS) or (iReason Eq MK_LR_TYPES) or (iReason Eq MK_LR_ATTRIBUTES) or (iReason Eq MK_LR_DATAFILES))
            Send Codelist_connect To (phoCodelistHandler(Self)) hCodelist False // connect the codelist-object without bitmaps
            Set Codelist_style Of (phoCodelistHandler(Self)) To (LVS_EX_TRACKSELECT Ior LVS_EX_ONECLICKACTIVATE) // set's the listview style to the possible styles (refer to msdn)
#IFNDEF TH_SCINTILLA
            If (iReason Eq MK_LR_INDEXES) Begin
                Move (GetWindowLong(hCodelist,GWL_STYLE)) To iStyle
                If (iStyle Iand LVS_SORTASCENDING) Begin
                    Move (iStyle - LVS_SORTASCENDING) To iStyle
                    Move (SetWindowLong(hCodelist,GWL_STYLE,iStyle)) To iStyle
                End
            End
#ENDIF
            Send FillCodelistWithArraydata
            Case break

        Case (iReason Eq MK_LR_VARS)
            Send Codelist_connect To (phoCodelistHandler(Self)) hCodelist False // connect the codelist-object without bitmaps
            Set Codelist_style Of (phoCodelistHandler(Self)) To (LVS_EX_TRACKSELECT Ior LVS_EX_ONECLICKACTIVATE) // set's the listview style to the possible styles (refer to msdn)

            Send FillCodelistWithVarData
            Case break

        Case (iReason Eq MK_LR_CLASSES)
            Send Codelist_connect To (phoCodelistHandler(Self)) hCodelist iUseBitmaps // connect the codelist-object with bitmaps
            //Set Codelist_style Of (phoCodelistHandler(self)) to (LVS_EX_ONECLICKACTIVATE) // set's the listview style to the possible styles (refer to msdn)
            Set codelist_font Of (phoCodelistHandler(Self)) To 0
            Send FillCodelistWithClassData
            Case break

        Case (iReason Eq MK_LR_PROCEDURES)
            Send Codelist_connect To (phoCodelistHandler(Self)) hCodelist False // connect the codelist-object without bitmaps
            Set Codelist_style Of (phoCodelistHandler(Self)) To (LVS_EX_TRACKSELECT Ior LVS_EX_ONECLICKACTIVATE) // set's the listview style to the possible styles (refer to msdn)

            Send FillCodelistWithMethodsData ASDB_TYPE_PROCEDURE MK_PROC_PROCEDURE
            Case break
        Case (iReason Eq MK_LR_FUNCTIONS)
            Send Codelist_connect To (phoCodelistHandler(Self)) hCodelist False // connect the codelist-object without bitmaps
            Set Codelist_style Of (phoCodelistHandler(Self)) To (LVS_EX_TRACKSELECT Ior LVS_EX_ONECLICKACTIVATE) // set's the listview style to the possible styles (refer to msdn)

            Send FillCodelistWithMethodsData ASDB_TYPE_FUNCTION MK_PROC_FUNCTION
            Case break

        Case (iReason Eq MK_LR_OBJECTS)
            Send Codelist_connect To (phoCodelistHandler(Self)) hCodelist iUseBitmaps // connect the codelist-object with bitmaps
            Set Codelist_style Of (phoCodelistHandler(Self)) To (LVS_EX_ONECLICKACTIVATE) // set's the listview style to the possible styles (refer to msdn)

            Send FillCodelistWithObjectData
            Case break

        Case Else
        //
        Get Item_Count Of (phoCodeTipHandler(Self)) To iCnt
        If (iCnt) Begin
            Send Codelist_connect To (phoCodelistHandler(Self)) hCodelist iUseBitmaps // connect the codelist-object with the delivered listview handle. the second parameter tells the object to use bitmaps (faster) or not (slower)
            Set Codelist_style Of (phoCodelistHandler(Self)) To (LVS_EX_TRACKSELECT Ior LVS_EX_ONECLICKACTIVATE) // set's the listview style to the possible styles (refer to msdn)
            For iItem From 0 To (iCnt-1)
                Get Value Of (phoCodeTipHandler(Self)) Item iItem To sFunc
                    Get Codelist_add_item Of (phoCodelistHandler(Self)) sFunc "function16.bmp" 0 To iRet
            Loop
        End
        Case End

        Send SelectClosestCodelistMatch
        //

        Set pbIsCodelistActive To True
        Send BlockKey VK_HOME   CM_KEY_CTRL  True
        Send BlockKey VK_END    CM_KEY_CTRL  True

        Function_Return True
    End_Function

    // Remove the codelist window
    // is done by sending a keydown esc and keyup esc and not via destroy window.
    // this way codemax is freeing the resources correctly
    // 12.2.2003 BP
    Procedure CancelCodelist
#IFDEF TH_SCINTILLA
        Send EditorMessage SCI_CANCEL
#ELSE
        Send PostVirtualKey VK_ESCAPE
#ENDIF
    End_Procedure

    // Remove the codetip window
    // is done by sending a keydown esc and keyup esc and not via destroy window.
    // this way codemax is freeing the resources correctly
    // 12.2.2003 BP
    Procedure CancelCodetip
#IFDEF TH_SCINTILLA
        Send EditorMessage SCI_CANCEL
#ELSE
        Send PostVirtualKey VK_ESCAPE
#ENDIF
    End_Procedure

    // Searches a function xy or procedure xy line in the current edit-buffer
    // and returns the line or blank if not found
    // 12.2.2003 BP
    Function SearchFunctioninParser String sFunction Returns String
        Integer hoParser iC
        String sVal
        Move (phoParser(Self)) To hoParser
        Move (Trim(sFunction)) To sFunction
        If (Left(uppercase(sFunction),4)) Eq "MSG_" Move ("procedure " + (Replace("MSG_",(uppercase(sFunction)),""))) To sFunction
        Else Move ("function " + sFunction) To sFunction
        Move (SearchBufferForText(hoParser,sFunction)) To sVal

        Function_Return sVal
    End_Function

    // Searches a procedure xy line in the current edit-buffer
    // and returns the line or blank if not found
    // 12.2.2003 BP
    Function SearchProcedureinParser String sFunction Returns String
        Integer hoParser iC
        String sVal
        Move (phoParser(Self)) To hoParser
        Move (Trim(sFunction)) To sFunction
        Move ("procedure " + sFunction) To sFunction
        Move (SearchBufferForText(hoParser,sFunction)) To sVal

        Function_Return sVal
    End_Function

    // Removes the object reference from a parameter list when calling a method using
    // get or send.
    //
    // Precondition: sParams is uppercase and the object reference is the first thing from
    //               the left.
    Function RemoveObjectFromMethodParameters String sParams String sRef Returns String
      Integer iLength
      String  sObjectName
      
      Move (Uppercase(sRef))  To sRef        // sRef = "of" / "to"
      Move (Length(sRef))     To iLength
      If (Left(sParams,iLength)=sRef) Begin  // get abc of oObject "1" 2 "three" to iResult
                                             // send abc to oObject "1" 1 "three"
        Move (Trim(Replace(sRef,sParams,""))) To sParams
        Move (Left(sParams,Pos(" ",sParams))) To sObjectName // oObject
        If (sObjectName<>"") Move (Trim(Replace(sObjectName,sParams,""))) To sParams
        Else Move "" To sParams
      End
      
      Function_Return sParams
    End_Function

    // Parse the current Line for a displayable codetip and set's the according properties
    // returns true if codetip found else returns false
    // 12.2.2003 BP
    Function ParseLineForCodeTip Returns Integer
        Integer iRet iSelLine iSelCol iLine iCol iIsFirst iPos iBraceLevel iStartBraceLevel iParaCount iOpenBraces
        String sLine sPart sCurChar sStringMarker sParseString sExpression sTip
        String sMethodName

        Set piCodeTipType         To C_TIPTYPE_UNDEFINED
        Get CM_GetSel True To iRet
        Move (piCodeTipCurrLine(Self)) To iSelLine
        Move (piSelEndLine(Self)) To iLine
        Move (piSelEndCol(Self))  To iCol

        // set the current tip-line if not set (-1)
        If (iSelLine Eq -1) Set piCodeTipCurrLine To iLine
        Else If (iSelLine Ne iLine) Begin  // remove tip if line was changed
            Function_Return False
        End

        // take the line
        Get CM_GETLINE iLine To sLine
        Move (cString(sLine)) To sLine

        // Take the left part, the right part is not interesting
        Move (Left(sLine,iCol)) To sLine

        // Remove all strings (' ', " " and remarks //)
        For iPos From 1 To (length(sLine))
            Move (Mid(sLine,1,iPos)) To sCurChar
            If sStringMarker Eq "" Begin  // not a string
                If ( (sCurChar Eq "'") Or (sCurChar Eq '"') ) Begin // string starts
                    Move sCurChar To sStringMarker
                    Move (sParseString+" ") To sParseString
                End
                Else Begin                                          // not a string
                    If (Mid(sLine,2,iPos)) Eq "//" Move (length(sLine)) To iPos // Remark found - cut the remark
                    Else Move (sParseString+sCurChar) To sParseString
                End
            End
            Else Begin                                              // it is a string
                If sCurChar Eq sStringMarker Begin                  // string ends
                   Move (sParseString+" ") To sParseString
                   Move "" To sStringMarker
                End
                Else Move (sParseString+" ") To sParseString
            End
        Loop
        Move (Replaces(Character(9),sParseString,"  ")) To sParseString // replace all horizontal tab characters with spaces

        // now search for first function that can display a tooltip from right to left
        Move 0 To iStartBraceLevel
        Move (length(sParseString)) To iPos

        Move iStartBraceLevel To iBraceLevel

        While (iPos Gt 0)
            Move (Mid(sParseString,1,iPos)) To sCurChar
            If sCurChar Eq ")" Begin
                Increment iBraceLevel
                Increment iOpenBraces
            End
            If sCurChar Eq "(" Begin
                Decrement iBraceLevel
                Decrement iOpenBraces
            End
            If ( (sCurChar Eq ",") And (iBracelevel Le -1) ) Decrement iBraceLevel
            If iBraceLevel Lt (iStartBraceLevel - 1) Begin
                If (Pos("(",sExpression)<>0) Move (Left(sExpression,( (Pos("(",sExpression))-1))) To sMethodName
                Else Move sExpression To sMethodName
                Move (Trim(sMethodName)) To sMethodName
                // Search in Edit-Buffer for function or msg_ definition
                Get SearchFunctionInParser sMethodName To sTip
                // if not found search in codetiphandler
                If (sTip = "") Get CodeTipFunction Of (phoCodeTipHandler(Self)) sMethodName To sTip
                // we have a tooltip (yippie)
                If (sTip <> "") Begin
                    Set psCodeTipCurrent To sTip
                    Move 0 To iParaCount
                    While (Pos(",",sExpression)<>0)
                        Increment iParaCount
                        Move (Replace(",",sExpression,"")) To sExpression
                    End
                    Set piCodeTipType      To C_TIPTYPE_EXPRESSION
                    Set piCodeTipArgument  To iParaCount
                    Function_Return True
                End
                // no tooltip for this function, get next one
                Else Begin
                    Decrement iStartBraceLevel
                    Move 0 To iBraceLevel
                    Move "" To sExpression
                End
            End
            Else If iBraceLevel Le iStartBraceLevel Move (sCurChar + (sExpression)) To sExpression
            Decrement iPos
        End
        // no tooltip found in function expression, now check for a get or send expression
        Move (uppercase((" " + sParsestring))) To sExpression
        If (Pos(" GET ",sExpression)<>0) Begin
            Move (Right(sExpression,((length(sExpression)) - 4 - (Pos(" GET ",sExpression))))) To sExpression
            Move (Trim(sExpression)) To sExpression
            If (Pos(" ",sExpression)<>0) Begin
              Move (Left(sExpression,(Pos(" ",sExpression)))) To sMethodName // removes any parameters, leaving bare function name
              Move (Trim(Replace(sMethodName,sExpression,""))) To sExpression // only contains parameters now
            End
            Else Begin
              Move sExpression To sMethodName
              Move "" To sExpression
            End

            Move (SearchFunctionInParser(Self,sMethodName)) To sTip
            If (sTip <> "") Begin
              Move -1 To iParaCount // count which parameter we are editing
              Get RemoveObjectFromMethodParameters sExpression "of" to sExpression
              While (sExpression<>"")
                Move (Left(sExpression,Pos(" ",sExpression))) To sPart
                If (sPart<>"") Move (Trim(Replace(sPart,sExpression,""))) To sExpression
                Else Move "" To sExpression
                Increment iParaCount
              Loop
              Set psCodeTipCurrent  To sTip
              Set piCodeTipArgument To iParaCount
              Set piCodeTipType     To C_TIPTYPE_FUNCTION
              Function_Return True
            End
        End
        If (Pos(" SEND ",sExpression)<>0) Begin
            Move (Right(sExpression,((length(sExpression)) - 5 - (Pos(" SEND ",sExpression))))) To sExpression
            Move (Trim(sExpression)) To sExpression
            If (Pos(" ",sExpression)<>0) Begin
              Move (Left(sExpression,(Pos(" ",sExpression)))) To sMethodName // removes any parameters, leaving bare function name
              Move (Trim(Replace(sMethodName,sExpression,""))) To sExpression // only contains parameters now
            End
            Else Begin
              Move sExpression To sMethodName
              Move "" To sExpression
            End
            
            Move (SearchProcedureInParser(Self,sMethodName)) To sTip
            If (sTip <> "") Begin
              Move -1 To iParaCount // count which parameter we are editing
              Get RemoveObjectFromMethodParameters sExpression "of" to sExpression
              Get RemoveObjectFromMethodParameters sExpression "to" to sExpression
              
              While (sExpression<>"")
                Move (Left(sExpression,Pos(" ",sExpression))) To sPart
                If (sPart<>"") Move (Trim(Replace(sPart,sExpression,""))) To sExpression
                Else Move "" To sExpression
                Increment iParaCount
              Loop

              Set psCodeTipCurrent  To sTip
              Set piCodeTipArgument To iParaCount
              Set piCodeTipType     To C_TIPTYPE_PROCEDURE
              Function_Return True
            End
        End
        If iOpenBraces Ge 0 Function_Return False  // no open function expression and no get/send expression found. remove tooltip
        If (psCodeTipCurrent(Self)) Ne "" Function_Return True
        Function_Return False
    End_Function

    // Codetip is requested, return true (1) to display codetip or false (0) to not display a codetip
    // changed the initial codetip request so that it is returned false if no codetip is to display
    // otherwise there is always a codetip created (invisible) and immediatly destroyed in OnCodetipUpdate
    // 12.2.2003 BP
    Procedure OnCodeTip
        Integer iEnabled iRet // Should not be zero if successfull...
        Get pbUseCodeTips Of (phoIniHandler(Self)) To iEnabled
        If ( (Not(iEnabled)) And (psOpenBracketTip(Self)) Ne "") Begin
            Set psCodeTipCurrent To (psOpenBracketTip(Self))
            Set piCodeTipArgument To -2
            Set piCodeTipCurrLine To -1
            Procedure_Return True
        End
        If (Not(iEnabled)) Procedure_Return False
        Get CodeTipInitialize Of (phoCodeTipHandler(Self)) To iRet
        If (Not(iRet)) Procedure_Return False
        If (psOpenBracketTip(Self)) Eq "" Set piCodeTipCurrLine To -1 // Reset, new tip requested
        Get ParseLineForCodeTip To iRet
        If ( (Not(iRet)) And (psOpenBracketTip(Self)) Ne "") Begin
            Set psCodeTipCurrent To (psOpenBracketTip(Self))
            Set piCodeTipArgument To -2
            Set piCodeTipCurrLine To -1
            Move 1 To iRet
        End
        Procedure_Return iRet
    End_Procedure

    // Codetip is to be updated, return true (1) to update the codetip or false (0) to not updating codetip
    // Check the line for codetip and remove it if necessary
    // 12.2.2003 BP
    Procedure OnCodeTipUpdate
        Integer iRet
        Get ParseLineForCodeTip To iRet
        If ( (Not(iRet)) And (psOpenBracketTip(Self)) Ne "") Begin
            Set psCodeTipCurrent To (psOpenBracketTip(Self))
            Set piCodeTipArgument To -2
            Set piCodeTipCurrLine To -1
            Move 1 To iRet
        End
        If (Not(iRet)) Send CancelCodeTip
        Procedure_Return iRet
    End_Procedure

    // **WvA 06-05-2002: Added context sensitive help for the VDF-user.
    // The code windowshelp in VDF is up to Vdf8 SP2 in the vdfcode.hlp file. This method will
    // invoke the windows helpfile and show the topic that is currently under the cursor.
    // Normally invoked by CTRL+F1
    Procedure ContextSensitiveHelp
        Integer iVoid
        String  sHelpFile sWord sVdfRootDir
        Number  nVer
        Handle  hoHelp

        Get psVdfRootDir Of ghoWorkSpaceHandlerEx To sVdfRootDir
        Get fnCurrentVdfVersion Of ghoWorkSpaceHandlerEx   To nVer // 70=VDF7, 82=VDF8.2

        If (nVer <= 90) Begin
          Move (sVdfRootDir +'\Help\VdfCode.hlp') To sHelpFile
          // ** SVN 29/01-2003:
          // I do not like to get something like "(Trim(sStr))" in Help window!
          Get CM_GetCurrentWord To sWord
          If (Length(sWord)>1) Move (WinHelpStr(Container_Handle(Self), sHelpFile, HELP_PARTIALKEY, sWord)) To iVoid
        End
        Else Begin
          //
          If (nVer<100) Begin
            // For VDF9.1
            Send vShellExecute "OPEN" 'VDF9.chm' "" (sVdfRootDir+"\Help\")
          End
          Else Begin
            Get CM_GetCurrentWord To sWord
            Get Create u_cHtmlHelp to hoHelp
            If (hoHelp) Begin
              // Disable the "always on top" state as it is not very convenient.
              // It breaks alt-tab and can no longer edit the file under the helpfile.
              Set pbAlwaysOnTop of hoHelp To False
              If (nVer<180) Begin
                Set psHelpFile of hoHelp to (sVdfRootDir+"Help\VisualDataFlex.chm")
              End
              Else Begin
                Set psHelpFile of hoHelp to (sVdfRootDir+"Help\DataFlex.chm")
              End
              If (Length(sWord)>1) Begin
                Send DoDisplayKeyword of hoHelp (sWord+Character(0))
              End
              Else Begin
                Send DoDisplayIndex of hoHelp
              End
              Send Destroy of hoHelp
            End
          End
        End
    End_Procedure   // ContextSensitiveHelp

    Function GetLeftFromPrnLine String sLine Returns String
        Integer iFinished iPos
        String sLeft
        Move 1 To iPos
        While iPos Le (length(sLine))
            If (Mid(sLine,1,iPos)) In ">1234567890" Move (sLeft + (Mid(sLine,1,iPos)) ) To sLeft
            Else Move (length(sLine)) To iPos
            Increment iPos
        End
        Function_Return sLeft
    End_Function

    Function GetDepth String sLine Returns Integer
        Integer iRetVal
        While (Pos(">",sLine)) Ne 0
            Increment iRetVal
            Move (Replace(">",sLine,"")) To sLine
        End
        Function_Return iRetVal
    End_Function

    // Fixed to work with VDF8 and higher
    // 02.01.2004 BP

    Function FindCurrentInclude Returns String
        Integer iRet iFinished iPos iCur iCurDepth iNewDepth iCurLine iCurCol
        String sCurrentFindText sLine sFile sLeft sRight sNewLine

        Get CM_GetSel False                 To iRet
        Move (piSelEndLine(Self)) To iCurLine
        Move (piSelEndCol(Self)) To iCurCol

        Get value To sLine
        If (Left(uppercase(Trim(sLine)),16)) Eq "INCLUDING FILE: " Begin
            Move (Replace("INCLUDING FILE: ",(uppercase(Trim(sLine))),"")) To sFile
            If (Pos("   ",sFile)<>0) Begin
                Move (Left(sFile,(Pos("   ",sFile)))) To sFile
                Move (Trim(sFile)) To sFile
            End
            Function_Return sFile
        End

        Get GetLeftFromPrnLine sLine To sLeft
        If (Trim(sLeft)) Eq "" Begin
            Function_Return ""
        End

        Move (Replace(sLeft,sLine,"")) To sRight
        If (Left(uppercase(Trim(sRight)),4)) Eq "USE " Begin
            Move (Replace("USE ",(uppercase(Trim(sRight))),"")) To sLine
            Move (Trim(sLine)) To sLine
            Move 1 To iPos
            Move "" To sFile
            While (iPos Le (length(sLine)) )
                If ( ((Mid(sLine,1,iPos)) Eq " ") Or ((Mid(sLine,1,iPos)) Eq "/") ) Move (length(sLine)) To iPos
                Else Move (sFile + (Mid(sLine,1,iPos)) ) To sFile
                Increment iPos
            End
            If (Pos("   ",sFile)<>0) Begin
                Move (Left(sFile,(Pos("   ",sFile)))) To sFile
                Move (Trim(sFile)) To sFile
            End
            Function_Return sFile
        End


        Move (GetDepth(Self,sLeft)) To iCurDepth
        If iCurDepth Eq 1 Begin                       // must be main-source
            Get value Item 0 To sLine
            Move (Replace("COMPILING PROGRAM: ",(uppercase(Trim(sLine))),"")) To sFile
            If (Pos("   ",sFile)<>0) Begin
                Move (Left(sFile,(Pos("   ",sFile)))) To sFile
                Move (Trim(sFile)) To sFile
            End
            Function_Return sFile
        End
        Set dynamic_update_state1 To False
        Get CM_GetFindText To sCurrentFindText
        Get CM_SetFindText "INCLUDING FILE: " To iRet
        Move 0 To iFinished
        While (Not(iFinished))
            Move (current_item(Self)) To iCur
            Send FindPrevious
            If (current_item(Self)) Eq iCur Move 1 To iFinished
            Else Begin
                Get value Item ((current_item(Self))-1) To sNewLine
                Get GetLeftFromPrnLine sNewLine To sNewLine
                Move (GetDepth(Self,sNewLine)) To iNewDepth
                If iNewDepth Lt iCurDepth Begin
                    Get value To sLine
                    Move (Replace("INCLUDING FILE: ",(uppercase(Trim(sLine))),"")) To sFile
                    Get CM_SetSel iCurLine iCurCol iCurLine iCurCol True To iRet
                    Set dynamic_update_state1 To True
                    If (Pos("   ",sFile)<>0) Begin
                        Move (Left(sFile,(Pos("   ",sFile)))) To sFile
                        Move (Trim(sFile)) To sFile
                    End
                    Function_Return sFile
                End
            End
        End
        Get CM_SetSel iCurLine iCurCol iCurLine iCurCol True To iRet
        Set dynamic_update_state1 To True
        Function_Return ""
    End_Function

        // Tries to open the file under the cursor.
    Procedure OpenFileUnderCursor
        String sWord sPathWord sFileName
        String sEditedFile sTable sExt
        Boolean bIsHttp
        
        Get GetFileName     To sEditedFile
        // handle prn's different
        Get ParseFileExtension sEditedFile To sExt
        If ( uppercase(sExt) = "PRN"  Or uppercase(sExt) = "PRP" ) Begin
          Get FindCurrentInclude To sWord
          If (sWord Eq "") Procedure_Return
        End
        Else Begin
          Get CM_GetCurrentWordIncludingDot  To sWord    // Gets current word with not stopping on "." only with blanks!
          If (sWord = "") Begin
            Error 200 ("OpenFileUnderCursor: There is no word under the cursor.")
            Procedure_Return
          End
        End
        Move false To bIsHttp
        If (Left(lowercase(sWord),5)="http:" or Left(lowercase(sWord),6)="https:") Move True to bIsHttp
        If (bIsHttp) Begin
          // open associated browser
          Send vShellExecute "OPEN" sWord "" ""
        End
        Else Begin
          Move sWord To sPathWord
          If Not "." In sPathWord Append sPathWord ".pkg"
          Get FindFileForWorkspace of ghoWorkSpaceHandlerEx sPathWord     to sPathWord
          If (sPathWord <> "") Begin
            Get FileNameOnDisk sPathWord To sFileName // Case sensitivity correction if needed
            Delegate Send CAOpenFile sFileName
          End
          Else Begin
            Get isCurrentWordaTable sWord To sTable
            If (sTable<>"") Begin
              Send LaunchDBEUtility sTable
            End
            Else Error 200 ('OpenFileUnderCursor: File "'+sWord+'" not found.')
          End
        End
    End_Procedure

        // Tries to find the method in the current line.
    Procedure TryToIdentifyCurrentMethod
        Integer hoID
        String  sL sMethod sClass sInfo
        Delegate Send ShowMethodInfo ""
        Get value                   To sL
        Move (Trim(lowercase(sL)))  To sL
        Move (oLineParser(Self))    To hoID
        Set  psSepCharacter         Of hoID             To " "
        Set  piSkipEmptyParts       Of hoID             To True
        Send ParseLine              To hoID sL
        If (Value(hoID,0)) In "send,get,set,procedure,function" Begin
            Get value              Of hoID Item 1       To sMethod
        End
        If (Value(hoID,0)) Eq "move" Begin
            Get value              Of hoID Item 1       To sMethod
            If (Left(sMethod,1)) Eq "(" Begin
                Move (Replace("(",sMethod,""))          To sMethod
                Move (Left(sMethod,Pos("(",sMethod)-1)) To sMethod
            End
        End
        If sMethod Ne "" Begin
            Clear VDFProp
            Move sMethod    To VDFProp.Name
            Find Ge VDFProp by Index.2
            If VDFProp.Name Ne sMethod Indicate found False
            [found] Delegate Send ShowMethodInfo (Trim(VDFProp.Descr))
//            if (GetCurrentElement(Self,MK_OBJECT+MK_CLASS)) Begin  // Get the current element-> only Object or Class!
//                get psCEl_psClass of (phoParser(Self))  to sClass
//                move (Trim(sClass))                     to sClass
//                Clear VDFCLS
//                move sClass to VDFCLS.Name
//                Find eq VDFCLS by Index.1
//                [Found] Begin
//                    Open ASDB
//                    Clear ASDB
//                    move VDFCLS.Code    to ASDB.VdfCls
//                    move sMethod        to ASDB.Name
//                    Find eq ASDB by Index.1
//                    [Found] Begin
//                        Delegate send ShowMethodInfo (ASDBInfoString(0))
//                     End
//                End
//            End
        End
    End_Procedure


    Procedure ListCreator
        Boolean bInsert
        Integer iRet iLine hoParser
        String  sRef sLine sValue sStart
        Move (phoParser(Self))                                          To hoParser
        Get CM_GetSel False                                             To iRet
        Move (piSelEndLine(Self))                                       To iLine
        Move (GetCurrentRef(Self))                                      To sRef
        Get Value Item iLine                                            To sValue
        If (Trim(sValue)) Ne "" ;
        If Not (Trim(Lowercase(sValue))) In "get@set@send@move@" Move True To bInsert
        Move (Left(Trim(sValue),4))                                     To sValue
        Move (Lowercase(Trim(sValue)))                                  To sValue
        Move "Set"                                                      To sStart
        If sValue In "get@set@send@move@"   Move sValue                 To sStart
        Get GetCreatorLine Of  Desktop sRef hoParser iLine sStart       To sLine
        If sLine Ne "" Begin
            If bInsert Send Insert sLine
            Else Set ValueSmart Item iLine                              To sLine
        End
    End_Procedure

    Procedure ListObjects
        Send ShowLanguageList True MK_LR_OBJECTS
    End_Procedure
    Procedure ListVars
        Send ShowLanguageList True MK_LR_VARS
    End_Procedure
    Procedure ListKeys
        Send ShowLanguageList True MK_LR_KEYS
    End_Procedure
    Procedure ListIDETags
        Send ShowLanguageList True MK_LR_IDETAGS
    End_Procedure
    Procedure ListCommands
        Send ShowLanguageList True MK_LR_COMMANDS
    End_Procedure
    Procedure ListProcedures
        Send ShowLanguageList True MK_LR_PROCEDURES
    End_Procedure
    Procedure ListFunctions
        Send ShowLanguageList True MK_LR_FUNCTIONS
    End_Procedure
    Procedure ListClasses
        Send ShowLanguageList True MK_LR_CLASSES
    End_Procedure
    Procedure ListDataFiles
        Send ShowLanguageList True MK_LR_DATAFILES
    End_Procedure

        // Synchronisiert den Element mit
    Procedure SyncCodeView
        Integer iRet iL
        Get CM_GetSel False To iRet
        If iRet Begin
            Get LineToItem Of (phoParser(Self)) (piSelEndLine(Self)) To iRet
            If iRet Begin
                Get piCEl_pItemNr Of (phoParser(Self))  To iRet
                Set Current_Item Of (phoElements(Self)) To iRet
            End

        End

    End_Procedure

    Procedure VDFSyntaxCheck Integer iLine
        String sLine sChar sTextchar sLineAbove
        String sEOLComment sTemp
        Integer iBraces iPos iLength iIsText iRet iLineTmp iCurHighline iECPos
        If iLine Gt (CM_GetLineCount(Self)) Procedure_Return
        Get CM_GETLINE iLine To sLine
        Get cm_getHighlightedLine To iCurHighLine
        Move (cString(sLine)) To sLine
        Move "//" To sEOLComment
        Move (Pos(sEOLComment,sLine)) to iECPos
        If (iECPos <> 0) Begin
          // test if not a EOL comment in a string!
          For iPos From 1 to iECPos
            Move (Mid(sLine,1,iPos)) To sChar
            If (sTextchar Eq "") Begin
                If sChar Eq '"' Move sChar To sTextchar
                If sChar Eq "'" Move sChar To sTextchar
            End
            Else If sChar Eq sTextchar Move "" To sTextchar
          Loop
          If (sTextchar="") Begin
            Move (Left(sLine,iECPos-1)) To sLine
          End
        End
        If (Right(Trim(sLine),1)) Eq ";" Procedure_Return
        Move (iLine -1) To iLineTmp
        While (iLineTmp Ge 0)
            Get CM_GETLINE iLineTmp To sLineAbove
            Move (cString(sLineAbove)) To sLineAbove
            If (Pos("//",sLineAbove)) Ne 0 Move (Left(sLineAbove,((Pos("//",sLineAbove))-1))) To sLineAbove
            If (Right(Trim(sLineAbove),1)) Eq ";" Move (sLineAbove + sLine) To sLine
            Else If (length(Trim(sLineAbove))) Gt 0 Move -1 To iLineTmp
            Decrement iLineTmp
        End
        If (length(sLine)) Le 0 Begin
            If ( ((psOpenBracketTip(Self)) Ne "") And (iLine Eq iCurHighLine) ) Begin
                Set psOpenBracketTip To ""
                Set piCodeTipCurrLine To -1
                Send CancelCodeTip
                Get CM_SetHighlightedLine  -1 To iRet
            End
            Procedure_Return
        End
        If (length(sLine)) Gt 3000 Procedure_Return
        For iPos From 1 To (length(sLine))
            Move (Mid(sLine,1,iPos)) To sChar
            If (sTextchar Eq "") Begin
                If sChar Eq '"' Move sChar To sTextchar
                If sChar Eq "'" Move sChar To sTextchar
            End
            Else If sChar Eq sTextchar Move "" To sTextchar
            If sTextchar Eq "" Begin
                If sChar Eq "(" Increment iBraces
                If sChar Eq ")" Decrement iBraces
            End
        Loop
        If iBraces Ne 0 Begin
            If iBraces Gt 0 Set psOpenBracketTip To ('*** WARNING: A ")" is missing in the marked Line! ***')
            If iBraces Lt 0 Set psOpenBracketTip To ('*** WARNING: A "(" is missing in the marked Line! ***')
            Send CodeTip
            Get CM_SetHighlightedLine iLine To iRet
            Get cm_setbookmark iLine True To iRet
        End
        Else Begin
            If ( ((psOpenBracketTip(Self)) Ne "") And (iLine Eq iCurHighLine) ) Begin
                Set psOpenBracketTip To ""
                Set piCodeTipCurrLine To -1
                Send CancelCodeTip
                Get CM_SetHighlightedLine  -1 To iRet
            End
        End
    End_Procedure

    Procedure onKeyUp Integer iKey
        Forward Send onKeyUp iKey
        //if iKey eq VK_Return send ParseBuffer   // Better here becouse Line is already inserted
    End_Procedure
        // Trapped for current pos -> StatusBar
    Procedure onSelChange
        Integer iRet iLine iCol iLineCount iOldLine
        String sLang

        Get CM_GetSel False To iRet // not normalize becouse then isnt EndPosition the cursor pos.
        If iRet Begin   // Shows the position in the StatusBar.
            Move (piSelEndLine(Self))   To iLine
            Move (piSelEndCol(Self))    To iCol
            Delegate Send ShowCursorPosition iLine iCol
        End
        If (pbIsCodelistActive(Self)) Send SelectClosestCodelistMatch

        If (piLastLineNumber(Self)) Ne (piSelEndLine(Self)) Begin
            Send CheckCurrentFileReadOnlyState
            
            Get CM_GetLanguage To sLang
            Delegate Send ShowLanguageInfo sLang

            Move (piLastLineNumber(Self)) To iOldLine
            Set piLastLineNumber To (piSelEndLine(Self))
            If (sLang Eq "VDF") Begin
                If ( ((CM_GetHighlightedLine(Self)) Eq -1) And ( (psOpenBracketTip(Self)) Ne "") ) Begin
                    Set psOpenBracketTip To ""
                    Set piCodeTipCurrLine To -1
                    Send CancelCodeTip
                End
                Send VDFSyntaxcheck iOldLine
            End
        End
    End_Procedure

    Procedure SetCurrentLineToOwerDraw
        Integer iRet iLine iCol iLineCount
        Get CM_GetSel False To iRet // not normalize becouse then isnt EndPosition the cursor pos.
        If iRet Begin   // Shows the position in the StatusBar.
            Move (piSelEndLine(Self))   To iLine
            Move (piSelEndCol(Self))    To iCol
            Move (CM_SetLineStyle(Self,iLine,CML_OwnerDraw))    To iRet
        End
    End_Procedure

        // Trapped for INS/OVR -> StatusBar
    Procedure onOvertypeChange
        Integer iMode
        Move (CM_IsOvertypeEnabled(Self))   To iMode
        Delegate Send ShowInsert (Not(iMode))
    End_Procedure

    Procedure Toggle_Overtype
        Integer iRet
        Move (CM_EnableOvertype(Self, (Not(CM_IsOvertypeEnabled(Self))))) To iRet
    End_Procedure

        // Only for demonstration purposes.
        // Openes a file if it is dragged into it.
    Procedure OnFileDropped String sFile
        Delegate Send  CAOpenFile sFile
    End_Procedure

        // Here are the commands implemented.
    Procedure onRegisteredCmd Integer iCmd

            // File Menu
        If iCmd Eq CMD_FileOpenFile             Send CAOpenFile
        If iCmd Eq CMD_FileSaveFile             Send CASaveFile
        If iCmd Eq CMD_FileSaveFileAs           Send CASaveFileAs
        If iCmd Eq CMD_FileSaveAll              Send CASaveAllFiles
        If iCmd Eq CMD_FileCloseFile            Send CACloseFile
        If iCmd Eq CMD_FileCloseAllFiles        Send CACloseAllFiles
        If iCmd Eq CMD_FileNewFile              Send CANewFile

            // Edit Menu
        If iCmd Eq CMD_FindInFiles              Send CAPopUpFindInFiles

            // Options Menu
        If iCmd Eq CMD_SelectWorkSpace          Send CASelectWorkSpace

            // Build Menu
        If iCmd Eq CMD_BuildRun                 Send CABuildRun
        If iCmd Eq CMD_BuildRunCurrent          Send CABuildRunCurrent
        If iCmd Eq CMD_BuildCompileCurrent      Send CABuildCompile
        If iCmd Eq CMD_BuildPreCompile          Send CABuildPreCompile
        If iCmd Eq CMD_BuildExecute             Send CABuildExecute
        If iCmd Eq CMD_BuildDebugRun            Send CABuildDebugRun
        If iCmd Eq CMD_BuildDebugRunCurrent     Send CABuildDebugRunCurrent

            // Window Menu.
        If iCmd Eq CMD_WindowSwitchToCodeView   Send WindowSwitchToCodeView
        If iCmd Eq CMD_WindowSwitchToErrorView  Send PAWindowSwtichToErrorView
        If iCmd Eq CMD_WindowSyncCodeView       Send SyncCodeView
        If iCmd Eq CMD_WindowNextView           Send CASwitchToNextView
        If iCmd Eq CMD_WindowPreviousView       Send CASwitchToPreviousView

            // Lists.
        If iCmd Eq CMD_ListCreator              Send ListCreator
        If iCmd Eq CMD_ListObjects              Send ListObjects
        If iCmd Eq CMD_ListVars                 Send ListVars
        If iCmd Eq CMD_ListKeys                 Send ListKeys
        If iCmd Eq CMD_ListProcedures           Send ListProcedures
        If iCmd Eq CMD_ListFunctions            Send ListFunctions
        If iCmd Eq CMD_ListClasses              Send ListClasses
        If iCmd Eq CMD_ListIDETags              Send ListIDETags

            // Mixed
        If iCmd Eq CMD_ToggleComment            Send ToggleComment
        If iCmd Eq CMD_ToolsInsertHeaderGlobal  Send InsertHeaderGlobal
        If iCmd Eq CMD_ToolsInsertHeaderUser    Send InsertHeaderUser
        If iCmd Eq CMD_OpenFileUnderCursor      Send OpenFileUnderCursor
        If iCmd Eq CMD_InsertRevisionMark       Send InsertRevision
        If iCmd Eq CMD_InsertColor              Send InsertColorValue

            // Convetion.
        If iCmd Eq CMD_ConvertOnItemToAddItem   Send Toggle_OnItem_AddItem
        If iCmd Eq CMD_ConvertCStructToVDF      Send ConvertCStructToVDF
        If iCmd Eq CMD_ConvertCDllCallToVDF     Send ConvertCDllCallToVDF
        If iCmd Eq CMD_ConvertVDFTypeToHandler  Send ConvertVDFTypeToHandler

        If iCmd Eq CMD_MarkScopeBlock           Send MarkScopeBlock

        If iCmd Eq CMD_MOVELINEUP               Send MoveLineUp
        If iCmd Eq CMD_MOVELINEDOWN             Send MoveLineDown
        If iCmd Eq CMD_DUPLICATESELECTION       Send DuplicateSelection
        
    End_Procedure

        // Returns the Position of a corresponding "(" for the last ")"
        // 15.05.2001 Bernhard
    Function OpenBracketPos String sLine Returns Integer
        Integer iLevel iString
        String sPart
        Move 0 To iString
        While sLine Ne ""
            Move (Mid(sLine,1,(length(sLine)) )) To sPart
            Move (Left(sLine,((length(sLine)) -1) )) To sLine
            If sPart Eq "'" Move (Not(iString)) To iString
            If sPart Eq '"' Move (Not(iString)) To iString
            If ( (Not(iString)) And (sPart Eq ")")) Increment iLevel
            If ( (Not(iString)) And (sPart Eq "(")) Decrement iLevel
            If iLevel Eq 0 Function_Return ((length(sLine)) + 1)
        End
        Function_Return -1
    End_Function

#IFNDEF TH_SCINTILLA
        // Marks the corresponding "(" for the typed ")"
        // 15.05.2001 Bernhard
    Procedure MarkBracket
        String sLine sFont
        Integer iPos iRet iPosX iPosY iSize iHeight iWidth
        Handle hFont
        Get value To sLine
        Move (Left(sLine,(piSelEndCol(Self)) )) To sLine
        Move (sLine + ")") To sLine
        Move (OpenBracketPos(Self,sLine)) To iPos
        If iPos Ne -1 Begin
            Move (CM_PosFromChar(Self,piSelEndLine(Self),iPos))    To iRet
            // Only if the "(" is visible in the Edit-Space
            If (hi(CM_HitTest(Self,(piPosStartX(Self)),(piPosStartY(Self)) ))) Eq CM_EDITSPACE Begin
                Move ( (hi(GUILocation(Self)))+2+(piposEndY(Self))) To iPosY
                Move ( (low(GUILocation(Self)))-3+(piPosStartX(Self))) To iPosX
                Get Msg_ShowBracketMarker Of (oBracketMarker(Self)) iPosY iPosX To iRet
            End
            Else Send RemoveBracketMarker To (oBracketMarker(Self))
        End
        Else Send RemoveBracketMarker To (oBracketMarker(Self))
    End_Procedure
#ENDIF        

        // Key capturing...
    Procedure onCMKeyDown Integer iKeyCode Integer iKeyExt
        If ( (pbIsCodelistActive(Self)) And (iKeyCode Eq VK_HOME) And (iKeyExt Eq CM_KEY_CTRL) )  Send Codelist_Beginning_Of_Data To (phoCodeListHandler(Self))
        If ( (pbIsCodelistActive(Self)) And (iKeyCode Eq VK_END) And (iKeyExt Eq CM_KEY_CTRL) )  Send Codelist_End_Of_Data To (phoCodeListHandler(Self))
        If iKeyCode Eq VK_RETURN Set piEnterIsDown   To True
    End_Procedure

        // Key capturing...
    Procedure onCMKeyUp Integer iKeyCode Integer iKeyExt
        Integer iRet iEnde
        String  sLine
        If iKeyExt Ne 0 If iKeyCode Eq VK_RIGHT                 Move 0 To iKeyCode
        If iKeyCode Eq VK_RETURN If (Not(piEnterIsDown(Self)))  Move 0 To iKeyCode
        If iKeyCode Eq VK_RETURN Set piEnterIsDown   To False
        Get isListReason iKeyCode  To iRet
        If iRet Ne MK_LW_NO If iRet Ne MK_LR_CREATOR Send ShowLanguageList True iRet

        If (pbCodeTipRequest(Self)) Begin
            Set pbCodeTipRequest To False
            Send CodeTip
        End
        Else Begin
          // **WvA 15-11-2004 Added support to cancel the debugwindow with the Escape key
          If (iKeyCode Eq VK_ESCAPE) Send Request_Cancel
        End

#IFNDEF TH_SCINTILLA
        // Remove the Bracket-Marker if a Edit-Key is pressed (you will get no KeyPress in this case) 15.05.2001 Bernhard
        If ( (iKeyCode Lt VK_HELP) And (iKeyCode Ne VK_SHIFT) ) Send RemoveBracketMarker To (oBracketMarker(Self))
#ENDIF        
    End_Procedure
    
    Function TranslateCharacter Integer iKeyCode Returns Integer
      Integer iChar
      String  sCharTrans
      
      Move 0 To iChar
      Move (Mid(psCharTranslation(ghoEditorProperties),9,(Pos(("|"+(String(iKeyCode))+";"),(psCharTranslation(ghoEditorProperties)))) )) To sCharTrans
      Move (Mid(sCharTrans,5,(Pos(";",sCharTrans)))) To sCharTrans
      Move (Left(sCharTrans,(Pos("|",sCharTrans)))) To sCharTrans
      Move (Replaces(";",sCharTrans,"")) To sCharTrans
      Move (Replaces("|",sCharTrans,"")) To sCharTrans
      If (sCharTrans<>"") Move (Integer(sCharTrans)) To iChar
      Function_Return iChar
    End_Function
    
    Function ShouldTranslateCharacter Integer iKeyCode Returns Boolean
      Function_Return ((Pos(("|"+(String(iKeyCode))+";"),(psCharTranslation(ghoEditorProperties)))) Ne 0)
    End_Function

        // Capturing KeyPress for Mark of Brackets. It must be KeyPress because KeyDown/KeyUp deliver
        // Scan-Codes (which would be a problem if using different keyboard-layouts)
        // whereas KeyPress delivers the Ascii-Value Of the Key pressed. 15.05.2001 Bernhard

        // Added Character translation so if a specified key is pressed some other char is inserted.
        // 7.2.2003 BP

    Procedure onCMKeyPress Integer iKeyCode Integer iKeyExt
        Boolean bTranslateChar
        Integer iCharTrans
#IFNDEF TH_SCINTILLA
        Get ShouldTranslateCharacter iKeyCode to bTranslateChar
        If ( (bTranslateChar) And (Not(piLastKeyTranslated(Self))) ) Begin
            Set piLastKeyTranslated To True
            Get TranslateCharacter iKeyCode to iCharTrans
            Send Windows_Message WM_CHAR iCharTrans 0
                Procedure_Return 1
            End

        Set piLastKeyTranslated To False
#ENDIF

        Forward Send onCMKeyPress iKeyCode iKeyExt
        If ( (iKeyCode Eq (Ascii(" "))) And (pbIsCodelistActive(Self)) ) Send CancelCodelist
        If ( (iKeyCode Eq (Ascii("("))) And (pbIsCodelistActive(Self)) ) Begin
            If (piListReason(phoCodelistHandler(Self))) Ne MK_LR_KEYS Send CancelCodelist
            Else Set piInListCol To ((piInListCol(Self))+1)
        End

        // automatic CodeTip support. property pbCodeTipRequest is checked in onCmKeyUp since codetip need the ( that was currently typed
        // 30.1.2003 BP
        If (iKeyCode Eq (Ascii("("))) Set pbCodeTipRequest To True

#IFNDEF TH_SCINTILLA
        If iKeyCode Eq (Ascii(")")) Send MarkBracket
        Else Send RemoveBracketMarker To (oBracketMarker(Self))
#ENDIF        
    End_Procedure

        // To allow selection with enter.
    Procedure DoKeyReturn
        If (isListReason(Self,VK_RETURN)) Eq MK_LR_CREATOR Begin
            Send BlockKeyOnce VK_RETURN CM_KEY_NOEXT True
            Send ListCreator
        End
        Else If Not (isKeyBlocked(Self,VK_RETURN,0)) Forward Send DoKeyReturn
    End_Procedure

        // Property change notification...
    Register_Object oEditorElements
    Procedure onPropsChange
#IFDEF TH_SCINTILLA
        Set psEditorHotKeys     Of (phoIniHandler(Self)) to (CMGetHotkeys())
#ELSE
        If (CM_isReadOnly(Self)) Set psReadOnlyColors Of (phoIniHandler(Self)) To (CM_GetColors(Self))
        Else                     Set psColors         Of (phoIniHandler(Self)) To (CM_GetColors(Self))
        Set pbColorSyntax       Of (phoIniHandler(Self)) To (CM_IsColorSyntaxEnabled(Self))
        Set psHotKeys           Of (phoIniHandler(Self)) To (CMGetHotkeys())
#ENDIF
        Set piLineNumbering     Of (phoIniHandler(Self)) To (CM_GetLineNumbering(Self))
//        Set psLanguage          Of (phoIniHandler(Self)) To (CM_GetLanguage(Self))
        Set pbScrollBarH        Of (phoIniHandler(Self)) To (CM_HasScrollBar(Self,True))
        Set pbScrollBarV        Of (phoIniHandler(Self)) To (CM_HasScrollBar(Self,False))
#IFNDEF TH_SCINTILLA
        Set pbSplitterH         Of (phoIniHandler(Self)) To (CM_IsSplitterEnabled(Self,True))
        Set pbSplitterV         Of (phoIniHandler(Self)) To (CM_IsSplitterEnabled(Self,False))
        Set pbSmoothScrolling   Of (phoIniHandler(Self)) To (CM_IsSmoothScrollingEnabled(Self))
        Set pbLineToolTips      Of (phoIniHandler(Self)) To (CM_IsLineToolTipsEnabled(Self))
        Set piUndoLimit         Of (phoIniHandler(Self)) To (CM_GetUndoLimit(Self))
        Set pbPreserveCase      Of (phoIniHandler(Self)) To (CM_IsPreserveCaseEnabled(Self))
        Set psFont              Of (phoIniHandler(Self)) To (CM_GetFont(Self))
        Set psFontStyles        of (phoIniHandler(Self)) to (CM_GetFontStyles(Self))
#ENDIF
        Set pbLeftMargin        Of (phoIniHandler(Self)) To (CM_IsLeftMarginEnabled(Self))
        Set pbDragDrop          Of (phoIniHandler(Self)) To (CM_IsDragDropEnabled(Self))
        Set pbColumnSel         Of (phoIniHandler(Self)) To (CM_IsColumnSelEnabled(Self))
        Set piAutoIndentMode    Of (phoIniHandler(Self)) To (CM_GetAutoIndentMode(Self))
        Set piTabSize           Of (phoIniHandler(Self)) To (CM_GetTabSize(Self))
        Set pbTabExpand         Of (phoIniHandler(Self)) To (CM_IsTabExpandEnabled(Self))
        Set pbNormalizeCase     Of (phoIniHandler(Self)) To (CM_IsNormalizeCaseEnabled(Self))

        Set pbSelBounds         Of (phoIniHandler(Self)) To (CM_IsSelBoundsEnabled(Self))
        Set pbCaseSensitive     Of (phoIniHandler(Self)) To (CM_IsCaseSensitiveEnabled(Self))
        Set pbWholeWord         Of (phoIniHandler(Self)) To (CM_IsWholeWordEnabled(Self))
    	Send NotifyColorEditorChange To (oEditorElements(Parent(Self)))
    End_Procedure

    Procedure SetLanguage String sFile
        Integer iRet hoIni
        Handle  hoID
        String  sLang
        Move (phoIniHandler(Self))                 To hoIni
        Move (LanguageForFile(hoIni,sFile))        To sLang
//        If sLang eq "" move (psLanguage(hoIni))    To sLang
        Move (CM_SetLanguage(Self,sLang))          to iRet
        Get phoParser       to hoID
        Set Language        of hoID to sLang
    End_Procedure


        // Sets all... (sent by Page_Object)
    Procedure SetAdjustments
        Integer hoIni iRet
        // Font Face
        String  sFontData
        String  sFontTemp 
        String  sFontFace
        Integer iFontSize
        Integer iCharSet
        //

        Move (CM_ENABLEGLOBALPROPS(Self,False))    To iRet

        Move (phoIniHandler(Self))  To hoIni
        Move (CM_SetLineNumbering(Self,Low(piLineNumbering(hoIni)),Hi(piLineNumbering(hoIni)),Low(piLineNumbering(hoIni)))) To iRet
        Move (CM_EnableLeftMargin(Self,pbLeftMargin(hoIni)))            To iRet

        Move (CM_SetLanguage(Self,psLanguage(hoIni)))                   To iRet
        Move (CM_ShowScrollBar(Self,True,pbScrollBarH(hoIni)))          To iRet
        Move (CM_ShowScrollBar(Self,False,pbScrollBarV(hoIni)))         To iRet
#IFNDEF TH_SCINTILLA
        If ( (CM_isReadOnly(Self)) And (psReadOnlyColors(hoINI) Ne "") ) ;
            Move (CM_SetColors(Self,psReadOnlyColors(hoIni)))           To iRet
        Else Move (CM_SetColors(Self,psColors(hoIni)))                  To iRet
        Move (CM_EnableColorSyntax(Self,pbColorSyntax(hoIni)))          To iRet
        Move (CM_EnableSplitter(Self,True,pbSplitterH(hoINI)))          To iRet
        Move (CM_EnableSplitter(Self,False,pbSplitterV(hoINI)))         To iRet
        Move (CM_EnableSmoothScrolling(Self,pbSmoothScrolling(hoIni)))  To iRet
        Move (CM_EnableLineToolTips(Self,pbLineToolTips(hoIni)))        To iRet
        Move (CM_SetUndoLimit(Self,piUndoLimit(hoIni)))                 To iRet
        Move (CM_EnablePreserveCase(Self,pbPreserveCase(hoIni)))        To iRet
        Move (CM_SetFont(Self,psFont(hoIni)))                           To iRet
        Move (CM_SetFontStyles(Self,psFontStyles(hoIni)))               To iRet
        Get   CM_SetImageList (Window_Handle(phoImageList(Self)))       to iRet
#ELSE
        // Editor font face?
        Move (psFontFace(ghoEditorProperties))                          to sFontData
        If (sFontData="") Move "11pt; 0; Courier New"                 to sFontData
        // Font Size
        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
        Move (Trim(Replace("PT;", Uppercase(sFontTemp), "")))           to iFontSize
        // Code Page
        Move (Left(sFontData, Pos(";", sFontData)))                     to sFontTemp
        Move (Trim(Replace(sFontTemp, sFontData, "")))                  to sFontData
        Move (Trim(Replace(";", sFontTemp, "")))                        to iCharSet
        // Font Face
        Move (Trim(sFontData))                                          to sFontFace
        //
        Send EditorMessage SCI_STYLESETFONT STYLE_DEFAULT (AddressOf(sFontFace))
        Send EditorMessage SCI_STYLESETSIZE STYLE_DEFAULT iFontSize
        Send EditorMessage SCI_STYLESETCHARACTERSET STYLE_DEFAULT iCharSet
        Send EditorMessage SCI_STYLESETSIZE STYLE_LINENUMBER (iFontSize-1) // Set font size
        //
        Set  pbShowMatchingBraces to (pbShowMatchingBraces(hoIni))
        If  (pbShowIndentGuides(hoIni)) Send ShowIndentationGuides
        Send SelectTillEndOfLine (pbSelectWholeLine(hoIni))
#ENDIF
        Move (CM_EnableDragDrop(Self,pbDragDrop(hoIni)))                To iRet
        Move (CM_EnableColumnSel(Self,pbColumnSel(hoIni)))              To iRet
        Move (CM_SetAutoIndentMode(Self,piAutoIndentMode(hoIni)))       To iRet
        Move (CM_SetTabSize(Self,piTabSize(hoIni)))                     To iRet
        Move (CM_EnableTabExpand(Self,pbTabExpand(hoIni)))              To iRet
        Move (CM_EnableNormalizeCase(Self,pbNormalizeCase(hoIni)))      To iRet
        Move (CM_EnableSelBounds(Self,pbSelBounds(hoIni)))              To iRet
        Move (CM_EnableCaseSensitive(Self,pbCaseSensitive(hoIni)))      To iRet
        Move (CM_EnableWholeWord(Self,pbWholeWord(hoIni)))              To iRet
    End_Procedure

    Procedure onModifiedChange Integer bModified
        Delegate Send onModifiedChange  bModified
    End_Procedure
        // Sets the Undo and Redo buttons in the toolbar.
    Procedure onChange
        Integer iUndo iRedo
        //
        Move (CM_CanUndo(Self)) To iUndo
        Move (CM_CanRedo(Self)) To iRedo
        Delegate Send ShadowToolBarItem TBItem_Undo  (Not(iUndo))
        Delegate Send ShadowToolBarItem TBItem_Redo  (Not(iRedo))
        Send ToggleLineChanged
        #IFDEF TH_SCINTILLA        
        Set  pbShowMatchingBraces to (pbShowMatchingBraces(ghoEditorProperties))
        If (pbShowIndentGuides(ghoEditorProperties)) Begin
            Send ShowIndentationGuides
        End
        Send SelectTillEndOfLine (pbSelectWholeLine(ghoEditorProperties))
        #ENDIF
    End_Procedure
        // Fills Properties with the FileDateTime.
    Procedure FillFileTimeStamp String sFile
        Date    dDat
        Integer iH iM Is
        Get_File_Path sFile     To sFile
        If sFile Eq "" Procedure_Return
        Set pnFileTimeStamp     To (MKTimeStampOfFile(sFile))
    End_Procedure
        // To check if file was changed outside of the editor.
    Function isFileTimeChanged String sFile Returns Integer
        If sFile Eq "" Function_Return 0
        Function_Return (MKTimeStampOfFile(sFile) Ne pnFileTimeStamp(Self))
    End_Function


        // Save and Restore BookMarks.
    Procedure SaveBookMarks String sFile
        String sData iCount
        Move (CM_GetAllBookMarks(Self))    To sData
        Move (piBookMarkCnt(Self))         To iCount
        Send THWS_SaveBookmarks sFile sData iCount
    End_Procedure
    Procedure LoadBookMarks String sFile
        Integer iRet iFile
        Get THWS_FindFile sFile to iFile
        If (iFile>=0) ;
            Move (CM_SetAllBookMarks(Self,gtTHWorkspace.taSources[iFile].iBookmarkCount,gtTHWorkspace.taSources[iFile].sBookmarks)) to iRet
    End_Procedure
    Procedure DeleteBookMarks
    End_Procedure

        // Save and Restore the current position if a file.
    Procedure SaveCurrentPos String sFile
        Integer iRet
        String sData
        Get CM_GetSel False To iRet
        Append sData (Pad(piSelEndLine(Self),5)) (Pad(piSelEndCol(Self),5))
        Send THWS_SaveCursorPosition sFile (piSelEndLine(Self)) (piSelEndCol(Self))
    End_Procedure
    Procedure LoadCurrentPos String sFile
        Integer iFile iLine iCol iRet
        Get THWS_FindFile sFile to iFile
        If (iFile>=0) Begin
            Move gtTHWorkspace.taSources[iFile].iCursorLine     to iLine
            Move gtTHWorkspace.taSources[iFile].iCursorColumn   to iCol
            Move (CM_SetSel(Self,iLine,iCol,iLine,iCol,True))   to iRet
        End
    End_Procedure
    
    //
    // Checks the current file if it is readonly and verifies it against
    // the state of the codemax edit control for the current file.
    // If they are not the same then the codemax control is set to comply with
    // the actual file state.
    // In that case the color of the foldertab is updated if needed as well.
    //
    Procedure CheckCurrentFileReadOnlyState
      Integer iRet
      Handle  hoIni
      String  sFile
      String  sColors
      Boolean bIsReadOnly
      Boolean bChanged
      
      Move False to bChanged
      Move ""    To sColors
      Move (CM_isReadOnly(Self)) To bIsReadOnly
      Move (phoIniHandler(Self)) To hoIni
      
      Get psFileName          To sFile
      If (sFile<>CM_NEWFILENAME and sFile<>"") Begin
        // Check if file attrib is readonly:
        If (MKisFileReadOnly(sFile)) Begin
          If (bIsReadOnly=false) Begin
            Move True To bChanged
            Move (CM_SetReadOnly(Self,True))      To iRet    // Set it to readonly
            Get psReadOnlyColors Of hoIni         To sColors // if there is a different
          End                                                // set of colors stored use it
        End
        Else Begin
          If (bIsReadOnly) Begin
            Move True To bChanged
            Move (CM_SetReadOnly(Self,False))     To iRet
            Get psColors Of hoIni                 To sColors
          End
        End
        If (bChanged) Begin
          Send CAOnLabelChanged (Parent(Self))
  
          If (sColors <> "") Begin
#IFNDEF TH_SCINTILLA
            Move (CM_SetColors(Self,sColors))   To iRet
#ENDIF
            Send NotifyColorEditorChange To (oEditorElements(Parent(Self)))
          End
        End
      End
    End_Procedure // CheckFileReadOnlyState

    Function CM_OpenFile String sFile Returns Integer
        Integer iRet iIsPrn iCaseEnabled
        // Switch off the normalize Case feature if we load a prn or prp file.
        // Since this files are sometimes quite large loading of this files is
        // much faster if this feature is turned off.
        // 2.3.2003 BP
        If ( ((Right(Trim(uppercase(sFile)),4)) Eq ".PRN" ) Or ((Right(Trim(uppercase(sFile)),4)) Eq ".PRP") ) Begin
            Move (CM_IsNormalizeCaseEnabled(Self)) To iCaseEnabled
            Get CM_EnableNormalizeCase False To iRet
            Move 1 To iIsPrn
        End
        Forward Get CM_OpenFile sFile   To iRet
        // Reset the normalize case feature to the orginal value if it is a prn file.
        If (iIsPrn) Get CM_EnableNormalizeCase iCaseEnabled To iCaseEnabled

        If iRet Send FillFileTimeStamp  sFile // Update the filetime.
        If iRet Set psFileName          To sFile
        If iRet Begin
            Send AddRecentFile To ghoEditorProperties sFile
            Send LoadBookMarks  sFile
            Send LoadCurrentPos sFile
            
            Send CheckCurrentFileReadOnlyState
        End
        Function_Return iRet
    End_Function

    // Changed to reflect the new ini-setting piSaveLocal which speed's up the file-saving on a network drive dramatically
    // 19.02.02 Bernhard
    //
    Function CM_SaveFile String sFile Integer bUndo Returns Integer
        Integer iRet iCopy
        String sFileName sTemp
        
        Send BufferTextRTrim // right trim the lines with space endings
        If (Not(piSaveLocal(ghoEditorProperties))) Forward Get CM_SaveFile sFile bUndo  To iRet
        Else Begin
            Get FileFromPath sFile To sFileName
            Get TempDirectory To sTemp
            Forward Get CM_SaveFile (sTemp + "\" + sFileName) bUndo  To iRet
            If (iRet) Get copyFileEx (sTemp + "\" + sFileName) sFile True To iRet
            Send FillFileTimeStamp  sFile // Update the filetime if something fails in the file-copy.
        End
        If iRet Send FillFileTimeStamp  sFile // Update the filetime.
        If iRet Set psFileName          To sFile
        If iRet Begin
            Send AddRecentFile To ghoEditorProperties sFile
#IFDEF TH_SCINTILLA
            Send MarkChangedLinesAsSaved
#ENDIF
            Send SaveBookMarks  sFile
            Send SaveCurrentPos sFile
        End

        Function_Return iRet
    End_Function

        // Here a check is run to see if the file was altered outside of this program.
    Procedure Set Focus Integer hoID Integer hoID2
        Integer  iRet
        String   sMsg
        String   sFileName
        Handle   hoMain
        Boolean  bUserModified
        Boolean  bHasChangedExternal
        Boolean  bDoReloadFile

        Forward Set Focus To hoID hOID2
        Send onSelChange
        Send onOvertypeChange
        Move false To bDoReloadFile

        Get Main_Panel_Id to hoMain

        //
        If not (piInSetFocus(Self)) Begin // recursive protection
          Set piInSetFocus    To True
          Get psFileName      To sFileName
          Get isFileTimeChanged sFileName to bHasChangedExternal
          Get CM_IsModified   To bUserModified

          If (bHasChangedExternal and bUserModified) Begin
            Append sMsg "File " (Character(34)) sFileName (Character(34)) " "
            Append sMsg "was changed by another application.\n\n"
            If (bUserModified) Begin
              Append sMsg "You have made changes to this file as well.\n\n"
            End
            Append sMsg "Do you want to load the external changes?\n"
            If (bUserModified) Begin
              Append sMsg "Pressing YES will discard any changes you made to this file.\n"
            End

            Get YesNo_Box sMsg (Label(hoMain))        to iRet
            If iRet Eq MBR_Yes Begin

              Move True to bDoReloadFile
            End
            Else Send FillFileTimeStamp  sFileName // Update the filetime.
          End
          // If file has changed externally, but we didn't edit, then do not ask, just bloody refresh
          If (bHasChangedExternal and bUserModified=false) Move True To bDoReloadFile
          If bDoReloadFile Begin
            Get CM_OpenFile sFileName to iRet
            If bUserModified Begin
              Send onModifiedChange  False // reset the * at the end of the label
            End
          End
          Set piInSetFocus    To False
        End
        // Start the parse whenever the editor get's the focus
        // 28.1.2003 BP
        Send ParseBuffer

    End_Procedure

    Procedure Activate
        Integer iRet
        Forward Send Activate
        If (psOpenBracketTip(Self)) Eq "" Get CM_SetHighlightedLine  -1 To iRet
        Send onChange
    End_Procedure

    Procedure EditShadowToolBarItem Integer iLoseFocus
        //
        Send ShadowToolBarItem TBItem_Save      iLoseFocus
        Send ShadowToolBarItem TBItem_SaveAll   iLoseFocus
        Send ShadowToolBarItem TBItem_Print     iLoseFocus
        //
        Send ShadowToolBarItem TBItem_Cut       iLoseFocus
        Send ShadowToolBarItem TBItem_Copy      iLoseFocus
        Send ShadowToolBarItem TBItem_Paste     iLoseFocus
        //
        If (iLoseFocus) Begin
            Send ShadowToolBarItem TBItem_Undo  iLoseFocus
            Send ShadowToolBarItem TBItem_Redo  iLoseFocus
        End
        Else Send OnChange
        //
        Send ShadowToolBarItem TBItem_Find      iLoseFocus
        Send ShadowToolBarItem TBItem_Replace   iLoseFocus
        //
        Send ShadowToolBarItem TBItem_Compile   iLoseFocus
        If (gsCurrentProgramFile <> "") Begin
        Send ShadowToolBarItem TBItem_Run       iLoseFocus
        Send ShadowToolBarItem TBItem_Debug     iLoseFocus
        Send ShadowToolBarItem TBItem_Execute   iLoseFocus
        End
        //
    End_Procedure

    Procedure onSetFocus
        Send EditShadowToolBarItem False
    End_Procedure
    Procedure onKillFocus
        Send EditShadowToolBarItem True
    End_Procedure

    Procedure DestroyObject
        Send RemoveAllFiles
        Send Request_Destroy_Object
    End_Procedure

    Function DragAndDrop_CanReceiveData String sDataType Returns Integer
        If (HitTestCurrentMouse(Self)) Eq CM_EDITSPACE Begin
            If sDataType Eq "DD_CLASS"  Function_Return 1
            If sDataType Eq "DD_OBJECT" Function_Return 1
            If sDataType Eq "DD_METHOD" Function_Return 1
        End
        Else Function_Return 0
    End_Function
    Function DragAndDrop_DropData Integer hoSrcObj Returns Integer
        Integer iLine
        String  sData sDataType sCR sRef sObj
        Get DragAndDrop_DataType    Of hoSrcObj To sDataType

        If (DragAndDrop_CanReceiveData(Self,sDataType)) Begin
            Move (LineRowUnderMouseCursor(Self))    To iLine
            Move (Hi (iLine))                       To iLine
            Get GetRefFromLine iLine                To sRef
            Get DragAndDrop_GetData     Of hoSrcObj To sData
            If sDataType Eq "DD_OBJECT" Begin
                Get ReduceReference sData sRef      To sData
                Get ReferenceToObject sData         To sData
            End
            If sDataType Eq "DD_METHOD" Begin
                Move (Left(sData,Pos("@",sData)))   To sObj
                Move (Replace(sObj,sData,""))       To sData
                Move (Replace("@",sObj,""))         To sObj
                Get ReduceReference sObj sRef       To sObj
                Get ReferenceToObject sObj          To sObj
                Move (Replace("@DEST@",sData,sObj)) To sData
            End
            Send Request_InserTextUnderMouseCursor sData
        End
        Function_Return 0
    End_Function

    Procedure ShowToolTip String sStr
    End_Procedure


    // Additional Commands:
    //  -Procedure
    //  -Function
    //  -End_Procedure
    //  -End_Function
    //  -Forward


    Function FindCommand String sSub Returns String
        Move (Uppercase(Trim(sSub)))    To sSub
        If (Left(sSub,1)) Eq "P"        Function_Return "Procedure"
        If (Left(sSub,2)) Eq "FU"       Function_Return "Function"
        If (Left(sSub,5)) Eq "END_P"    Function_Return "End_Procedure"
        If (Left(sSub,5)) Eq "END_F"    Function_Return "End_Function"
        If (Left(sSub,2)) Eq "FO"       Function_Return "Forward"
        Function_Return ""
    End_Function

        // To understand "\tab" for inserting a TabBlanks.
    Procedure InsertTextAtPosition Integer iLine Integer iCol String sTxt
        String sTab
        Move (Repeat(" ",piTabSize(ghoEditorProperties)))   To sTab
        Move (Replaces("\tab",sTxt,sTab))                   To sTxt
        Forward Send InsertTextAtPosition iLine iCol sTxt
    End_Procedure
        // Should deliver a name of the Project.
    Function GetProjectName Returns String
        String sRet
        Get CurrentWorkSpaceDescription Of ghoWorkSpaceHandlerEx    To sRet
        Function_Return sRet
    End_Function

        // Inserta the contents of the given file, neither on the top of a file
        // or if a AB created file insert an AB-StoreTopStart -End block and inserts
        // the file there.
        // Some special TAGS are replaces by the other information.
    Procedure InsertHeaderFromFile String sTplFile
        Integer iArgSize iSize iRet iStartRev iEndRev
        String  sFileName sBuffer
        String  sProjectName
        String  sUserName
        String  sComputerName
        String  sDD sDM sDY
        String  sTH sTM sTS
        String  sLine sTmp
        Integer iLine iLineCount iABStoreStart iABIgnoreStart
        Integer iChannel

        Get value Item 0    To sLine
        Append sTmp "/" "/AB/ Project"
        If (Left(sLine,13)) Eq sTmp Begin
            Move "" To sTmp
            Append sTmp "/" "/AB-STORETOPSTART"
            Get CM_GetLineCount To iLineCount
            For iLine From 0 To (iLineCount-1)
                Get value Item iLine    To sLine
                If (Uppercase(Left(Trim(sLine),11))) Eq ("/"+"/TH-HEADER") Begin
                    Send GotoLine iLine
                    Procedure_Return
                End
                If (Uppercase(  Left(Trim(sLine),16))) Eq ("/"+"/AB-IGNORESTART") Move iLine    To iABIgnoreStart
                If (Uppercase(  Left(Trim(sLine),18))) Eq sTmp Move iLine To iABStoreStart
                If (Uppercase(  Left(Trim(sLine),7)))  Eq "OBJECT "           Break
                If (Uppercase(Left(Trim(sLine),16)))   Eq "CD_POPUP_OBJECT "  Break
            End
            If iABStoreStart Gt 0 Move (iABStoreStart+1) To iLine
            Else Begin
                Move "" To sTmp
                Append sTmp "/" "/AB-StoreTopStart" (Character(13)) (Character(10))
                Append sTmp "/" "/AB-StoreTopEnd" (Character(13)) (Character(10)) (Character(13)) (Character(10))
                Move (CM_InsertText(Self,sTmp,iABIgnoreStart,0))    To iRet
                Move (iABIgnoreStart+1)                             To iLine
            End
        End
        Else Begin
            Get CM_GetLineCount To iLineCount
            If iLineCount Gt 50 Move 50 To iLineCount
            For iLine From 0 To (iLineCount-1)
                Get value Item iLine    To sLine
                If (Uppercase(Left(Trim(sLine),11))) Eq ("/"+"/TH-HEADER") Begin
                    Send GotoLine iLine
                    Procedure_Return
                End
            End
            Move 0 To iLine
        End

        // 27-06-2003 **WvA Added channel logic to the sequential
        //                  file access in here to avoid getting
        //                  channel in use errors.
        Get Seq_New_Channel To iChannel
        If (iChannel <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin

          Direct_Input Channel iChannel  sTplFile
          [    seqeof] Begin
              Send Seq_Release_Channel iChannel
              Procedure_Return -1
          End
          [Not seqeof] Begin
              Set_Channel_Position iChannel To -1    // Set to end of file.
              Get_Channel_Position iChannel To  iSize // Gets the size of the File.
              Set_Channel_Position iChannel To  0    // Set to beginning of file
          End
          Get_Argument_Size          To iArgSize
          If iArgSize Lt iSize Set_Argument_Size iSize
          Read_Block Channel iChannel sBuffer iSize
          Close_Input Channel iChannel

          Send Seq_Release_Channel iChannel

          Move (ComputerName(Desktop))       To sComputerName
          Move (NetzwerkBenutzer(Desktop))   To sUserName
          Get  GetFileName                   To sFileName
          Get  GetProjectName                To sProjectName

          Move (Replaces("@FILENAME@"     ,sBuffer,sFileName))        To sBuffer  // FileName
          Move (Replaces("@PROJECTNAME@"  ,sBuffer,sProjectName))     To sBuffer  // ProjectName
          Move (Replaces("@USERNAME@"     ,sBuffer,sUserName))        To sBuffer  // UserName
          Move (Replaces("@COMPUTERNAME@" ,sBuffer,sComputerName))    To sBuffer  // UserName


          // Date parts.
          Sysdate4 sDY sTH sTM sTS
          Move (Mid(sDY,2,1))     To sDD
          Move (Mid(sDY,2,4))     To sDM
          Move (Mid(sDY,4,7))     To sDY
          Move (Replaces("@DD@"         ,sBuffer,sDD))          To sBuffer  // Day
          Move (Replaces("@DM@"         ,sBuffer,sDM))          To sBuffer  // Month
          Move (Replaces("@DY@"         ,sBuffer,sDY))          To sBuffer  // Year

          // Time parts.
          Move (Right("0"+sTH,2)) To sTH
          Move (Right("0"+sTM,2)) To sTM
          Move (Right("0"+sTS,2)) To sTS
          Move (Replaces("@TH@"         ,sBuffer,sTH))          To sBuffer  // Hour
          Move (Replaces("@TM@"         ,sBuffer,sTM))          To sBuffer  // Minute
          Move (Replaces("@TS@"         ,sBuffer,sTH))          To sBuffer  // Second

          If iArgSize Lt iSize Set_Argument_Size  iArgSize
          Move (Pos(("/"+"/TH-REVISIONSTART"),Uppercase(sBuffer)))    To iStartRev
          Move (Pos(("/"+"/TH-REVISIONEND"),Uppercase(sBuffer)))      To iEndRev
          If iStartRev Gt 0 If iEndRev Gt 0 Begin
              Move (Remove(sBuffer,iStartRev+18,iEndRev-iStartRev-20)) To sBuffer
          End
          Move (CM_InsertText(Self,sBuffer,iLine,0))                  To iRet

          Send GotoLine iLine

        End
        Else Begin
          Send Info_Box "No free channels available to insert the header"
        End
    End_Procedure

        // Inserts a Header into the current file.
        // -1st tries to find userspecific header names UserName+Header.Tpl
        // -2nd the global Header named Header.Tpl
    Procedure InsertHeaderUser
        String sFile
        Move ("Header"+gsUserName+".tpl")   To sFile
        Get_File_Path sFile  To sFile                       //@
        If sFile Eq "" Get_File_Path "Header.Tpl" To sFile  //@
        If sFile Ne "" Send InsertHeaderFromFile sFile      //@
        Else Error 300 "Unable to locate Header.tpl"        //@
    End_Procedure
    Procedure InsertHeaderGlobal
        String sFile                                   //@
        Get_File_Path "Header.Tpl" To sFile            //@
        If sFile Ne "" Send InsertHeaderFromFile sFile //@
        Else Error 300 "Unable to locate Header.tpl"   //@
    End_Procedure
        // Can be used to insert a string at the revisionmarks.
    Procedure InsertRevisionString String sStr
        Integer iC iLineCount iRet iCurLine
        String  sLine sCR
        Get CM_GetSel False To iRet
        Get piSelEndLine                                                    To iCurLine
        Append sStr "\n"
        Append sCR (Character(13)) (Character(10))
        Move (Replaces("\n",sStr,sCR))  To sStr
        Get CM_GetLineCount To iLineCount
        If iLineCount Gt 50 Move 500 To iLineCount   // A limitation to prevent long searchers.
        For iC From 0 To (iLineCount-1)
            Get value Item iC   To sLine
            If (Uppercase(Trim(sLine))) Eq ("/"+"/TH-REVISIONEND") Begin
                Move (CM_InsertText(Self,sStr,iC,0))        To iRet
                Move (CM_InsertText(Self,sStr,iCurLine,0))  To iRet
                Procedure_Return
            End
        End
        Error 200 "InsertRevision: Revisionend marker not found!"
    End_Procedure
        // Inserts a revision entry.
    Procedure InsertRevision
        String  sMaskedValue sRet sIssue
        Integer hoID
        Send Popup To (oTextGetter(Self))
        Get StringP1 Of (oTextGetter(Self)) To sRet
        If sRet Eq "#CANCEL" Procedure_Return

        Get StringP2 of (oTextGetter(Self)) to sIssue
        If (sIssue<>"") Move ('(#'+sIssue+'):' * sRet) to sRet
        Move (oRevisionMaskHandler(Self))   to hoID
        Send LoadRevisionMask               To hoID
        Get  CreateMaskedValue Of hoID sRet To sMaskedValue
        Send InsertRevisionString sMaskedValue
    End_Procedure

// We now use cWinFunc.pkg version
//        // Converts a 8 Bit value to hex. (For HTML RGB support)
//    Function ByteToHex Integer iByte Returns String
//        Integer iLow iHi
//        String  sHexchars sLow sHi
//        Move "0123456789ABCDEF" To sHexchars
//        Move (iByte/16)         To iHi
//        Move (iByte-(iHi*16))   To iLow
//        Move (Mid(sHexchars,1,iHi+1))     To sHi
//        Move (Mid(sHexchars,1,iLow+1))    To sLow
//        Function_Return (sHi+sLow)
//    End_Function
    
        // Inserts a color value.
    Procedure InsertColorValue
        Integer hoID bRet iColor iR iG iB
        Integer iCurLine iCurCol
        String  sRGB
        Object oColorDlg Is a ColorDialog
            Set SelectedColor   To (RGB(255, 0, 0))
            Move Self           To hoID
        End_Object
        Get Show_Dialog Of hoID To bRet
        If bRet Begin
            Get CM_GetSel False To bRet
            Get piSelEndLine    To iCurLine
            Get piSelEndCol     To iCurCol
            Get SelectedColor   Of hoID To iColor
            Move (R_From_RGB(iColor))   To iR
            Move (G_From_RGB(iColor))   To iG
            Move (B_From_RGB(iColor))   To iB
            If (Left(Value(Self,0),1)) Eq "<" Append sRGB "#" (ByteToHex(iR)) (ByteToHex(iG)) (ByteToHex(iB))
            Else Begin
                Append sRGB "(RGB(" iR "," iG "," iB "))"
                If iColor Eq clAqua     Move "clAqua"    To sRGB
                If iColor Eq clBlack    Move "clBlack"   To sRGB
                If iColor Eq clBlue     Move "clBlue"    To sRGB
                If iColor Eq clDkGray   Move "clDkGray"  To sRGB
                If iColor Eq clFuchsia  Move "clFuchsia" To sRGB
                If iColor Eq clGray     Move "clGray"    To sRGB
                If iColor Eq clGreen    Move "clGreen"   To sRGB
                If iColor Eq clLime     Move "clLime"    To sRGB
                If iColor Eq clLtGray   Move "clLtGray"  To sRGB
                If iColor Eq clMaroon   Move "clMaroon"  To sRGB
                If iColor Eq clNavy     Move "clNavy"    To sRGB
                If iColor Eq clOlive    Move "clOlive"   To sRGB
                If iColor Eq clPurple   Move "clPurple"  To sRGB
                If iColor Eq clRed      Move "clRed"     To sRGB
                If iColor Eq clSilver   Move "clSilver"  To sRGB
                If iColor Eq clTeal     Move "clTeal"    To sRGB
                If iColor Eq clWhite    Move "clWhite"   To sRGB
                If iColor Eq clYellow   Move "clYellow"  To sRGB
            End
            Move (CM_InsertText(Self,sRGB,iCurLine,iCurCol)) To bRet
        End
        Send Request_Destroy_Object To hoID
    End_Procedure
        // Inserts a bitmap value.
    Procedure InsertBitmapValue
        Integer hoID bRet
        Integer iCurLine iCurCol
        String  sFileName sBmpDir
        Object oOpenDialog Is a OpenDialog
            Set Location To 5 471
            Set Dialog_Caption To "Please Select Bitmap file"
            Set Filter_String To "Bitmaps|*.BMP|Icons|*.ICO|All Files|*.*"
            Set NoChangeDir_State   To True
            Move Self To hoID
        End_Object    // oOpenDialog
        If (hoID <> 0) Begin
            Get CurrentBitmapPath Of ghoWorkSpaceHandlerEx To sBmpDir
            Set Initial_Folder Of hoID To sBmpDir
            Get Show_Dialog Of hoID To bRet
            If bRet Begin
                Get CM_GetSel False To bRet
                Get piSelEndLine    To iCurLine
                Get piSelEndCol     To iCurCol
                Get File_Title Of hoID To sFileName
                Move (CM_InsertText(Self,('"'+sFileName+'"'),iCurLine,iCurCol)) To bRet
            End
        End
        Send Request_Destroy_Object To hoID
    End_Procedure
    //
    Procedure LaunchUtility String sPath
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send  LaunchUtility sPath sFile
        Else Delegate Send LaunchUtility sPath ""
    End_Procedure
    //
    Procedure LaunchIDEUtility
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send  LaunchIDEUtility sFile
        Else Delegate Send LaunchIDEUtility
    End_Procedure
    //
    Procedure LaunchMergeUtility
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchMergeUtility   sFile
        Else Delegate Send LaunchMergeUtility
    End_Procedure
    //
    Procedure LaunchVCSUtility
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchVCSUtility   sFile
        Else Delegate Send LaunchVCSUtility
    End_Procedure
    //
    Procedure LaunchDBBUtility
        String sFile
        String sExt sLExt
        
        Get psFileName to sFile
        Get ParseFileExtension sFile to sExt
        If (sExt<>"") Begin
          Move (Lowercase(sExt)) to sLExt
          If (sLExt="dd" or sLExt="fd" or sLExt="tag" or sLExt="def") Begin
            Move (Replace("."+sExt,sFile,"")) to sFile
          End
          Else If (sLExt<>"int") Begin
            Move CM_NewFileName to sFile
          End
        End
        If (sFile<>CM_NewFileName) Begin
          Get ParseFileName sFile to sFile // Don't want the path part
          Delegate Send LaunchDBBUtility  ('-t'+trim(sFile))
        End
        Else Delegate Send LaunchDBBUtility
    End_Procedure
    //
    Procedure LaunchDBEUtility String sFile
        String sWorkspace
        String sTable
        
        Move "" To sTable
        Move "" To sWorkspace
        If (Num_Arguments>0) Move sFile To sTable
        If (sTable<>"") Begin
          Move ('"-t'+sTable+'"') To sTable
          //Move ('-xNoWorkspace')  To sWorkspace
        End
        //Else Begin
          Get CurrentWorkSpaceName of ghoWorkspaceHandlerEx To sWorkspace
          Move ('-x"'+sWorkspace+'"') To sWorkspace
        //End
        Delegate Send LaunchDBEUtility (sWorkspace+" "+sTable)
    End_Procedure
    //
    Procedure LaunchDBCUtility
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchDBCUtility   sFile
        Else Delegate Send LaunchDBCUtility
    End_Procedure
    //
    Procedure LaunchDBUUtility
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchDBUUtility   sFile
        Else Delegate Send LaunchDBUUtility
    End_Procedure
    //
    Procedure LaunchRptUtility
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchRptUtility   sFile
        Else Delegate Send LaunchRptUtility
    End_Procedure
    //
    Procedure LaunchCodeArt
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchCodeArt sFile
        Else Delegate Send LaunchCodeArt
    End_Procedure
    //
    Procedure LaunchCodePub
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchCodePub sFile
        Else Delegate Send LaunchCodePub
    End_Procedure
    //
    Procedure LaunchMenuUtility
        String sFile
        Get psFileName To sFile
        If (sFile<>CM_NewFileName) Delegate Send LaunchMenuUtility sFile
        Else Delegate Send LaunchMenuUtility
    End_Procedure
    //
    Procedure PreCompileDFAllEnt
        Delegate Send PreCompileDFAllEnt
    End_Procedure
    //
    Procedure PreCompileWindows
        Delegate Send PreCompileWindows
    End_Procedure
    //
    Procedure CACurrentCompile
        Delegate Send CACurrentCompile
    End_Procedure

    #IFDEF TH_SCINTILLA
    Function SCKeywords String sKeyWords Returns String
        Function_Return (Trim(Replaces("\n", sKeywords, " ")))
    End_Function
    
    Procedure SetLexer
        Boolean bInit
        Integer iRet
        Integer iLanguage
        Handle  hWnd
        String  sKeywords sScopeKeywords1 sScopeKeywords2 sOperators
        String  sLanguage
        Get Window_Handle to hWnd
        If (hWnd) Begin
            //Move (SendMessage(hWnd,SCI_GETLEXER,0,0)) to iRet // found?
            Get psLanguage      of ghoEditorProperties              to sLanguage
            Get FindLanguage    of ghoEditorProperties sLanguage    to iLanguage
            If (iLanguage=-1) Begin // Should it return?
                Send Info_Box ("Default Language '"+sLanguage+"' definition not found")
                Procedure_Return
            End
            Move (Lowercase(sLanguage))                             to sLanguage
            If ((sLanguage="")or(sLanguage="vdf")) Move "dataflex"  to sLanguage
            Move (sLanguage+Character(0))                           to sLanguage
            Move (SendMessage(hWnd,SCI_SETLEXERLANGUAGE,0,AddressOf(sLanguage))) to iRet
            Move (SendMessage(hWnd,SCI_GETLEXER,0,0)) to iRet // found?
            If (iRet=SCLEX_DATAFLEX) Begin
                Get SCKeywords (psLanguages.szKeywords(ghoEditorProperties, iLanguage))         to sKeywords
                Get SCKeywords (psLanguages.szScopeKeywords1(ghoEditorProperties, iLanguage))   to sScopeKeywords1
                Get SCKeywords (psLanguages.szScopeKeywords2(ghoEditorProperties, iLanguage))   to sScopeKeywords2
                Get SCKeywords (psLanguages.szOperators(ghoEditorProperties,iLanguage))         to sOperators
                Move (Replaces("^",sOperators,"")) To sOperators // The ^ char is a wildcard match in scintilla, the result is EVERYTHING is an operator, so remove it before passing it, it is a hardcoded operator in scintilla.
                //
                Get InitializedLanguage of oNormalizeCase SCLEX_DATAFLEX to bInit
                If (bInit=False) Begin
                  Send AddKeywords   of oNormalizeCase SCLEX_DATAFLEX sKeywords 
                  Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords1
                  Send AddScopewords of oNormalizeCase SCLEX_DATAFLEX sScopeKeywords2
                End
                //
                Move (Lowercase(sKeywords)) to sKeywords
                Move (sKeywords+Character(0)) to sKeywords
                Move (Lowercase(sScopeKeywords1)) To sScopeKeywords1
                Move (Lowercase(sScopeKeywords2)) To sScopeKeywords2
                Move (Lowercase(sOperators))      To sOperators
                Move (SendMessage(hWnd,SCI_SETKEYWORDS,0,AddressOf(sKeywords)))       to iRet // language keywords
                Move (SendMessage(hWnd,SCI_SETKEYWORDS,1,AddressOf(sScopeKeywords1))) to iRet // scope open
                Move (SendMessage(hWnd,SCI_SETKEYWORDS,2,AddressOf(sScopeKeywords2))) to iRet // scope close
                Move (SendMessage(hWnd,SCI_SETKEYWORDS,3,AddressOf(sOperators)))      to iRet // operators
                //
                Move (SendMessage(hWnd,SCI_SETSTYLEBITS,5,0)) to iRet
                //debug
                String sValue
                ZeroString 40 to sValue
                String sName
                Move ("position.width"+Character(0)) to sName
                Move (SendMessage(hWnd,SCI_GETPROPERTYEXPANDED,AddressOf(sName),AddressOf(sValue))) to iRet // found?
            
            End
            Else Begin
                Send Info_Box "DataFlex Lexer was not found."
            End
        End
    End_Procedure
    #ENDIF

End_Class

