//
// File: cSciLexer.pkg
// Author: Wil van Antwerpen
// Date: March 2017
//
//
// The scintilla control is made accessible here via the cSciLexer class and it's implementation has been designed to
// be almost a drop-in replacement for the codemax control that was previously the control used for editing by the Hammer.
//
// As development on codemax has ceased years ago and we need to go forward, scintilla ended up being the best match.
// Until our scintilla implementation is considered stable you can select which control to use by setting/removing the
// TH_SCINTILLA compiler directive at the start of hammer.src.
//
// Note that the intention is to phase out codemax and that the backwards compatibility is likely to fade over time as
// new scintilla only feature(s) will make it into the product.
//
// This is only designed this way to make the transition period from codemax to scintilla as smooth as can be.
//
// Codemax compatible methods are prefixed by CM_
//
// Documentation for the scintilla control can be found here:
// http://www.scintilla.org/ScintillaDoc.html
//
// This wrapper is licensed under the 2 clause BSD license as to make it as easy as possible to re-use if needed.
//
//
// BSD License content start
// *********************************************************************************************************
//
// Copyright (c) 2017, Wil van Antwerpen
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// The views and conclusions contained in the software and documentation are those
// of the authors and should not be interpreted as representing official policies,
// either expressed or implied, of the VDF-Guidance / Hammer Project.
// *********************************************************************************************************


Use cWinFunc.pkg
Use seq_chnl.pkg
Use cSciLexer.h
Use cSciCommandHotKeySupport.pkg
Use DllHandler.pkg
Use EditorSettings.dg
Use Tools\Find.dg

//
//function specific for scintilla, create xpm icons
//
External_Function SciEditorIconXpm      "SciEditorIconXpm"      SCIMAGE.DLL Integer iIcon Returns Pointer
//extern "C" unsigned int SciLoadPngAsRGBA(char* sFileName,unsigned char *pImage, unsigned *width, unsigned *height, unsigned int* uSize)
External_Function SciLoadPngAsRGBA      "SciLoadPngAsRGBA"      SCIMAGE.DLL Pointer pFileName Pointer pImage Pointer pWidth Pointer pHeight Pointer pSize Returns integer
External_Function SciLoadImageAsRGBA    "SciLoadImageAsRGBA"    SCIMAGE.DLL Pointer pFileName Pointer pImage Pointer pWidth Pointer pHeight Returns integer
External_Function SciLoadImageErrorText "SciLoadImageErrorText" SCIMAGE.DLL Integer iError Pointer pErrorText Returns integer
External_Function SciFreeRGBAImage      "SciFreeRGBAImage"      SCIMAGE.DLL Pointer pImage Returns integer


Class cSciLexer is a DFControl // cUIObject  cObject

    Register_Procedure OnWmSetFocus
    Register_Procedure OnWmKillFocus
    Register_Procedure OnWmPaint
    Register_Procedure DoKeyReturn
    Register_Procedure DoFileDropping
    Register_Procedure onWmContextMenu
    

    
    Procedure Construct_Object
      // the scintilla DLL to load is in the programs folder, preload it
      Set psDllLoadPath of oDllHandler to (psProgramPath(phoWorkspace(ghoApplication)))
      Send doLoadLibrary of oDllHandler "SciLexer.dll"
      
      Forward Send Construct_Object
      Set External_Class_Name "cScintillaEditor"  to CODEMAXWNDCLASS
      Set External_Message WM_SETFOCUS            to msg_OnWmSetFocus
      Set External_Message WM_KILLFOCUS           to msg_OnWmKillFocus
      Set External_Message WM_PAINT               to msg_OnWmPaint
      Set External_Message WM_DROPFILES           to msg_DoFileDropping
      Set External_Message WM_RBUTTONUP           to msg_onWmContextMenu
      //Set External_Message WM_KEYDOWN             to msg_onWmKeyDown  <<-- does not work

        

      //
      // Put any NEW properties HERE
      Property Address paTextData              0
      Property Integer piTextLength            0


          // These Properties are filled by CM_GetSel
      Property Integer piSelStartLine          0
      Property Integer piSelStartCol           0
      Property Integer piSelEndLine            0
      Property Integer piSelEndCol             0

          // Used to insert a self defined popup menu.
      Property Integer Floating_Menu_Object    0
      
          // These colors are stored in separate properties for easy access.
      Property Integer piWindowColor			     0	// Set during CM_GetColor / CM_SetColor
      Property Integer piTextColor				     0	// ...
      
      Property Integer peAutoIndentMode        CM_INDENT_PREVLINE
      Property Boolean pbShowMatchingBraces    True
      Property Boolean pbBraceHighLightState   False   // keeps track of brace highlight state so we can turn it off just one time instead of on each navigational action
      Property String  psEOLChar               CS_CRLF // default End Of Line character to use
      Property Handle  phMarkerLineHighLight   0       // scintilla marker handle that keeps track of the highlighted line
      Property String  piMarginLineNumberDigits 3      // character width of the line number margin (counts the digits)
      Property String[] psClearKeyBindings             // array that holds keyboard shortcut's that have to be cleared
      Property String  psSearchText            ""      // text to use in a search
      Property String  psLineOnEnter           ""      // content of the line when the cursor enters it (for line_changed_tracking)
          //
          //
          // These properties used with CodeTip (SVN)
      Property Integer phoCodeTipHandler           0
      Property Integer pbCodetipRequest           False
      Property Integer piCodeTipStyle              0   // not used for scintilla
      Property Integer piCodeTipHandle             0   // handle of actual tooltip, not available in scintilla
      //Property Integer piCodeTipStructure          0    // not used at all
      //Property Integer piCodeTipUpdated           False // not used at all
      Property Integer piCodeTipHighlightedStart  -1   // not used in scintilla, we set it directly
      Property Integer piCodeTipHighlightedEnd    -1   // not used in scintilla, we set it directly
      Property Integer piCodeTipArgument          -1   // denotes the current argument number that we are editing
      Property Integer piCodeTipFuncCount          0   // not used, but referenced in structure
      Property Integer piCodeTipCurrFunc           0   // not used, but referenced in structure
      Property Integer piCodeTipCurrLine          -1
      //Property Integer piCodeTipCurrCol           -1 // not used at all
      Property String  psCodeTipCurrent           ""   // contains the actual tip string to display
      //Property String  psCodeTipWord              "" // not used at all
      Property Integer piCodeTipType              C_TIPTYPE_UNDEFINED
      
      Property Boolean pbIsCodelistActive         False
      
      Property Boolean pbFileLoading              False // Set to true while loading file (for ex. in CM_Openfile)


      // ****************************************************************************
      // properties below are from old codemax, the might be removed if not needed or
      // moved up if they can stay.
      //
        Property Integer piWindowHandle Public 0
        Property Integer phoIniHandler  Public Self
//        Property Integer phFont         Public 0

        Property Integer piDragAcceptFilesState Public True

        Property Integer pbSaveAndLoadAsOEM     Public True
            // These Properties are filled by CM_PosFromChar.
        Property Integer piPosStartX    Public 0
        Property Integer piPosStartY    Public 0
        Property Integer piPosEndX      Public 0
        Property Integer piPosEndY      Public 0
            // Thes Properties are filled by FillCurrentPosition
        Property Integer piAbsPosXStart Public 0
        Property Integer piAbsPosYStart Public 0
        Property Integer piAbsPosXEnd   Public 0
        Property Integer piAbsPosYEnd   Public 0
            // Is used to do some actions when the find is done.
        Property Integer piFindWrapMode Public FindWrapMode_NoWrapMsg
            // Is ised to Block keys.
        Property String  psBlockedKeysNo            Public (Repeat("0",255))
        Property String  psBlockedKeysAlt           Public (Repeat("0",255))
        Property String  psBlockedKeysShift         Public (Repeat("0",255))
        Property String  psBlockedKeysCtrl          Public (Repeat("0",255))
            // Is used to Block keys but only once.
        Property String  psBlockedKeysNoOnce        Public (Repeat("0",255))
        Property String  psBlockedKeysAltOnce       Public (Repeat("0",255))
        Property String  psBlockedKeysShiftOnce     Public (Repeat("0",255))
        Property String  psBlockedKeysCtrlOnce      Public (Repeat("0",255))
            // Used with CMM_GetAllBookMarks.
        Property Integer piBookMarkCnt  Public 0
            // To use with Absolute_GUIOrigin -> Overwrite it to force SelectionLists
            // to popup relative to the cursor position.
        Property Integer piDontOverwriteGUIOrigin   Public False
        Property Integer piGUIOriginOffsetY         Public 0
        Property Integer piGUIOriginOffsetX         Public 0
            //
            // These properties used with CodeList (SVN)
        Property Integer phoCodeListHandler         0
            //
            // I want to have a client border as default
        Set Border_Style         to Border_ClientEdge
            // Simulate these keys because they are overwritten by the DFControl.
        On_Key key_Tab           Send Default_Key
        On_Key Key_Shift+key_Tab Send Default_Key
        On_Key kEnter            Send DoKeyReturn

        Property Integer piRedrawState   Public True

    End_Procedure

    Procedure End_Construct_Object
        Forward Send End_Construct_Object
        
    End_Procedure
    
    Function SciLoadImageErrorText Integer iError Returns String
      Integer iVoid
      String  sErrorText
      
      ZeroString 300 to sErrorText
      Move (SciLoadImageErrorText(iError,AddressOf(sErrorText))) To iVoid
      Function_Return (CString(sErrorText))
    End_Function
    

        // Allows dropping files from Windows.
    Procedure DoFileDropping Integer wParam Integer lParam
        Handle  hDrop
        Integer iCount iSize iC iRet
        Local_Buffer  sFile pFile
        Move wParam             to hDrop
        Move (DragQueryFile(hDrop,|CI$FFFFFFFF,0,0))    to iCount
        For iC from 0 to (iCount-1)
            Move (DragQueryFile(hDrop,iC,0,0))          to iSize
            Move (Repeat(Character(0),iSize+1))         to sFile
            GetAddress of sFile                             to pFile
            Move (DragQueryFile(hDrop,iC,pFile,iSize+1))    to iRet
            If iRet Begin
                Move (CString(sFile))                   to sFile
                Send onFileDropped sFile
            End
        End
        Move (DragFinish(hDrop))                        to iRet
    End_Procedure
    Procedure OnFileDropped String sFile
    End_Procedure
    
    Procedure onWmContextMenu Integer wParam Integer lParam
      Send DoRightClick wParam
    End_Procedure

        // This popups the SelectionList reltive to the cursor position
    Function Absolute_GUIOrigin Returns Integer
        Integer iX iY iRet
        Forward Get Absolute_GUIOrigin  to iRet
        If (piDontOverwriteGUIOrigin(Self)) Function_Return iRet
        Move (Hi(iRet))                                                 to iY
        Move (Low(iRet))                                                to iX
        Get  CM_GetSel False                                            to iRet
        Get  CM_PosFromChar (piSelEndLine(Self)) (piSelEndCol(Self))    to iRet
        Move (iY+piPosEndY(Self))                                       to iY
        Move (iX+piPosEndX(Self))                                       to iX
        Move (iY+piGUIOriginOffsetY(Self))                              to iY
        Move (iX+piGUIOriginOffsetX(Self))                              to iX
        Function_Return (MAKEWPARAM(iX,iY))
    End_Function

        // So the real GUIOrigin is always available too.
    Function Absolute_GUIOriginEx Returns Integer
        Integer iRet iOld
        Get piDontOverwriteGUIOrigin    to iOld
        Set piDontOverwriteGUIOrigin    to True
        Get Absolute_GUIOrigin          to iRet
        Set piDontOverwriteGUIOrigin    to iOld
        Function_Return iRet
    End_Function

        // Implementing Dyn.Update.State with using WM_SETREDRAW
    Procedure Set Dynamic_Update_State1 Integer iFlag
        Integer iRet
        If (window_handle(Self)) Eq 0 Procedure_Return
        Set piRedrawState   to iFlag
        Move (SendMessage(Window_Handle(Self),WM_SETREDRAW,iFlag,0))            to iRet
        If iFlag Move (RedrawWindow(Window_Handle(Self),0,0,RDW_INVALIDATE))    to iRet
    End_Procedure
    Function Dynamic_Update_State1 Returns Integer
        Function_Return (piRedrawState(Self))
    End_Function

    Procedure OnWmPaint
    End_Procedure

    
    Function CreateIndentation Integer iIndent Integer iTabSize Boolean bInsertSpaces Returns String
      String sIndent
      
      Move "" to sIndent
      If (bInsertSpaces=False) Begin
        While (iIndent>=iTabSize)
          Move (sIndent+"\t") to sIndent
          Move (iIndent-iTabSize) to iIndent
        Loop
        Move (Replaces("\t",sIndent,Character(9))) to sIndent
        While (iIndent>0)
          Move (sIndent+" ") to sIndent
          Decrement iIndent
        Loop
      End
      Else Begin
        Move (Repeat(" ",iIndent)) To sIndent
      End
      Function_Return sIndent
    End_Function
    
    //
    // iLine is the new line we are on and iIndentWanted is the indentation from the previous
    // line. We will insert the wanted indentation and then place the cursor at the end of
    // the line.
    //
    Procedure IndentAsPreviousLine Integer iLine Integer iIndentWanted
      Boolean bUseTabs
      Integer iPos
      Integer iTabSize
      String  sIndent
      
      Get EditorMessage SCI_GETTABWIDTH 0 0 to iTabSize
      Get EditorMessage SCI_GETUSETABS  0 0 to bUseTabs
      Get CreateIndentation iIndentWanted iTabSize (not(bUseTabs)) to sIndent
      Move (sIndent+Character(0)) to sIndent
      Get EditorMessage SCI_POSITIONFROMLINE iLine 0 to iPos
      Send EditorMessage SCI_SETTARGETRANGE iPos iPos
      Send EditorMessage SCI_REPLACETARGET -1 (AddressOf(sIndent))
      Send EditorMessage SCI_LINEEND
    End_Procedure
    
    Procedure DoKeyReturn
      Integer iLine
      Integer iIndent
      Integer eMode
      
      //  Send Windows_Message WM_CHAR    VK_RETURN 0
      Get peAutoIndentMode to eMode
      If (eMode=CM_INDENT_PREVLINE) Begin
        Get  Current_Item to iLine
        Send EditorMessage SCI_BEGINUNDOACTION
        Get  EditorMessage SCI_GETLINEINDENTATION iLine 0 to iIndent
        Send EditorMessage SCI_NEWLINE
        Send IndentAsPreviousLine (iLine+1) iIndent
        Send EditorMessage SCI_ENDUNDOACTION
      End
      Else Begin
        Send EditorMessage SCI_NEWLINE
      End
    End_Procedure
        // To ensure that the Object with the WinFocus also owns the DF focus.
    Procedure OnWmSetFocus
        Send Activate
    End_Procedure
    Procedure OnWmKillFocus
    End_Procedure

// Removed - the whole font handling is completely different in scintilla.
//
//        // Destroys the font object if created.
//    Procedure Request_DestroyFontObject

    
    Procedure EditorMessage Handle uMsg DWord wParam DWord lParam
      Handle  hWnd
      Integer iRet
      
      Get Window_Handle to hWnd
      If (hWnd) Begin
        If num_arguments Eq 3 Begin
          Move (SendMessage(hWnd,uMsg,wParam,lParam)) to iRet
        End
        Else If num_arguments eq 2 Begin
          Move (SendMessage(hWnd,uMsg,wParam,0)) to iRet
        End
        Else If num_arguments eq 1 Begin
          Move (SendMessage(hWnd,uMsg,0,0)) to iRet
        End
      End
    End_Procedure
    
    Function EditorMessage Handle uMsg DWord wParam DWord lParam Returns Integer
      Handle  hWnd
      Integer iRet
      
      Move 0 To iRet
      Get Window_Handle to hWnd
      If (hWnd) Begin
        Move (SendMessage(hWnd,uMsg,wParam,lParam)) to iRet
      End
      Function_Return iRet
    End_Function
    
    Procedure EditorMessageString Handle uMsg String ByRef sName String ByRef sValue
      Handle  hWnd
      Integer iRet
      
      Get Window_Handle to hWnd
      If (hWnd) Begin
        Move (sName+ Character(0)) to sName
        Move (sValue+Character(0)) to sValue
        Move (SendMessage(hWnd,uMsg,AddressOf(sName),AddressOf(sValue))) to iRet
      End
    End_Procedure

    Procedure SetAppearance Integer iElement Integer iColorIndex
        Send EditorMessage SCI_STYLESETFORE   iElement gtColorer[iColorIndex].iForeC
        Send EditorMessage SCI_STYLESETBACK   iElement gtColorer[iColorIndex].iBackC 
        Send EditorMessage SCI_STYLESETBOLD   iElement gtColorer[iColorIndex].iBold
        Send EditorMessage SCI_STYLESETITALIC iElement gtColorer[iColorIndex].iItalics
    End_Procedure
    
    Procedure DefaultFontStyles
      Integer iRet
      Integer iTextColor
      Integer iBackColor
      Integer iCharSet
      String  sFont
      
      Move ("Courier New"+Character(0)) to sFont
      Send EditorMessage SCI_STYLESETFONT STYLE_DEFAULT (AddressOf(sFont))
      Send EditorMessage SCI_STYLESETSIZE STYLE_DEFAULT 12 //11
      // By SVN on 23/05/2017 -- National Languages support
      //Move SC_CHARSET_DEFAULT To iCharSet
      Move SC_CHARSET_RUSSIAN to iCharSet
      //Send EditorMessage SCI_SETCODEPAGE 1251
      //Move SC_CHARSET_OEM To iCharSet
      Send EditorMessage SCI_STYLESETCHARACTERSET STYLE_DEFAULT iCharSet
      Send EditorMessage SCI_STYLECLEARALL
      // We have setup a default font for all, now set the specific fonts.
      //
      Set piTextColor   to gtColorer[EC_TEXT].iForeC //iTextColor
      Set piWindowColor to gtColorer[EC_WINDOW].iForeC //iBackColor
      // Caret
      Send EditorMessage SCI_SETCARETFORE       gtColorer[EC_TEXT].iForeC
      Send EditorMessage SCI_SETCARETWIDTH      3
      //Send EditorMessage SCI_SETCARETSTYLE      CARETSTYLE_BLOCK // Good for overwrite mode (Default is Underline)
      // Selection
      //Send EditorMessage SCI_SETSELFORE True (Rgb($FF, $FF, $FF)) // Will overwrite selection highlighting
      Move gtColorer[EC_WINDOW].iForeC to iBackColor
      If (iBackColor<0) Move clWhite to iBackColor
      // *** Lets check either Selection color is set and if not, then allocate default selection
      // Probably not the best algorithm, but we may improve at some stage if required ***
      If (gtColorer[EC_SELECTION].iForeC<=0) Begin
          If (iBackColor < (RGB($FF, $FF, $FF)/2-10000)) ;
            Send EditorMessage SCI_SETSELBACK True (Rgb($00, $00, $AA)) // Set darker
          Else ;
            Send EditorMessage SCI_SETSELBACK True (RGB(170,195,240))   // Set lighter
      End
      Else  Send EditorMessage SCI_SETSELBACK True gtColorer[EC_SELECTION].iForeC   // Set as per options
      // # White space
      // style.dataflex.0=fore:#808080
      Send EditorMessage SCI_STYLESETFORE STYLE_DEFAULT gtColorer[EC_TEXT].iForeC
      Send EditorMessage SCI_STYLESETBACK STYLE_DEFAULT iBackColor
      Send EditorMessage SCI_STYLESETBACK 0             iBackColor
      //
      Send SetAppearance    0                   EC_TEXT
      Send SetAppearance    1                   EC_TEXT             // // # Identifiers (style.dataflex.1=)
      Send SetAppearance    2                   EC_METATAGS         // # Comment: { ... } (style.dataflex.2=$(colour.code.comment.box),$(font.code.comment.box))
      Send SetAppearance    3                   EC_COMMENTS         // # Comment: (* ... *) (style.dataflex.3=$(colour.code.comment.box),$(font.code.comment.box))
      Send SetAppearance    4                   EC_COMMENTS         // # Line Comment: // ... (style.dataflex.4=$(colour.code.comment.line),$(font.code.comment.line))
//      Send EditorMessage SCI_STYLESETFORE 5 (rgb($7F,$7F,$00))      // # Preprocessor: {$ ... } (style.dataflex.5=$(colour.preproc))
//      Send EditorMessage SCI_STYLESETFORE 6 (rgb($7F,$7F,$00))      // # Preprocessor: (*$ ... *) (style.dataflex.6=$(colour.preproc))
      Send SetAppearance    7                   EC_NUMBERS          // # Number (style.dataflex.7=$(colour.Number))
      Send SetAppearance    8                   EC_NUMBERS          // # Hex Number (style.dataflex.8=$(colour.Number))
      Send SetAppearance    9                   EC_KEYWORDS         // # Keyword (style.dataflex.9=$(colour.keyword) // Basic keywords)
      Send SetAppearance   10                   EC_STRINGS          // # String (style.dataflex.10=$(colour.String))
      Send SetAppearance   11                   EC_STRINGTYPING     // # End of line where String is not closed (style.dataflex.11=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled)
      Send SetAppearance   12                   EC_SCOPEKWORDS      // # Scope keyword (style.dataflex.12=$(colour.keyword),bold)
      Send SetAppearance   13                   EC_OPERATORS        // # Operators (style.dataflex.13=$(colour.operator),bold)
      Send SetAppearance   STYLE_BRACELIGHT     EC_BRACEHLIGHT      // Colors for matching braces
      Send SetAppearance   STYLE_BRACEBAD       EC_UNMATCHEDBRACE   // Colors for an unmatched brace (bracebad)
      Send SetAppearance   STYLE_LINENUMBER     EC_LINENUMBERS      // Line Numbers Margin
      Send EditorMessage   SCI_STYLESETSIZE     STYLE_LINENUMBER 10 // Set font size
      //
      // Colors for codetip tooltip
      // font style to use for call tip
      Move ("Segoe UI"+Character(0)) to sFont
//      Move ("Verdana"+Character(0)) to sFont
      Send EditorMessage SCI_STYLESETFONT STYLE_CALLTIP   (AddressOf(sFont))
      Send EditorMessage SCI_STYLESETSIZE STYLE_CALLTIP   9
      Send EditorMessage SCI_STYLESETBACK STYLE_CALLTIP   (rgb($FF,$FF,$E1))
      Send EditorMessage SCI_STYLESETFORE STYLE_CALLTIP   (rgb($00,$00,$00)) // Code tooltip text color
      Send EditorMessage SCI_CALLTIPSETFOREHLT            (rgb($00,$00,$00)) // Code tooltip parameters color
      Send EditorMessage SCI_CALLTIPUSESTYLE 10 // tabs are filtered out of calltips, but we need to call this to have scintilla use our defined colors.
      //
      // tell the control we want to use our own font style for autocomplete
      Send EditorMessage SCI_AUTOCUSESTYLE
      // font style to use for autocomplete (codelist)
//      Move ("DejaVu Sans Mono"+Character(0)) to sFont
      Move ("Segoe UI"+Character(0)) to sFont
      Send EditorMessage SCI_STYLESETFONT STYLE_AUTOCOMPLETE (AddressOf(sFont))
      Send EditorMessage SCI_STYLESETSIZE STYLE_AUTOCOMPLETE 10
      // Bookmarks and Changed line
      Send EditorMessage SCI_SETMARGINBACKN MARGIN_BOOKMARKS    gtColorer[EC_LEFTMARGIN].iForeC
      Send EditorMessage SCI_SETMARGINBACKN MARGIN_CHANGED_LINE gtColorer[EC_LEFTMARGIN].iForeC
    End_Procedure // DefaultFontStyles
    
    Procedure Set LexerProperty String sName String sValue
        Send EditorMessageString SCI_SETPROPERTY (&sName) (&sValue)
    End_Procedure
    
    Procedure SetLexer
      Integer iRet
      Handle  hWnd
      String  sKeywords
      String  sLanguage
      
      Get Window_Handle to hWnd
      If (hWnd) Begin
        
        Move (SendMessage(hWnd,SCI_GETLEXER,0,0)) to iRet // found?
        Move "dataflex" to sLanguage
        Move (sLanguage+Character(0)) to sLanguage
        Move (SendMessage(hWnd,SCI_SETLEXERLANGUAGE,0,AddressOf(sLanguage))) to iRet

//        Move (SendMessage(hWnd,SCI_SETLEXER,SCLEX_DATAFLEX,0)) to iRet
        Move (SendMessage(hWnd,SCI_GETLEXER,0,0)) to iRet // found?
        If (iRet=SCLEX_DATAFLEX) Begin
          
          Move "a abort abort_transaction abs Activate_View Address addressof an and Append Append_Output array as ascii at " to sKeywords
          Move (sKeywords+"background Begin begin_constraints Begin_Row Begin_Transaction BigInt Boolean Broadcast calc Case ") to sKeywords
          Move (sKeywords+"Cd_End_Object Cd_Popup_Object channel Char character Class Clear Close Close_Input Close_Output Constrain contains ") to sKeywords
          Move (sKeywords+"Currency Date DateTime Decimal Decrement Deferred_View Define Delegate Delete Direct_Input Direct_Output ") to sKeywords
          Move (sKeywords+"div do downto DWord dynamic Else End End_Class end_constraints End_Enum_List End_Enumeration_List end_for_all ") to sKeywords
          Move (sKeywords+"End_Function end_item_list End_Object End_Procedure End_Row End_Struct End_Transaction end_type Entry_Item ") to sKeywords
          Move (sKeywords+"Enum_List Enumeration_List eq Error External_Function False Field File_Field File_Exist Find Float ") to sKeywords
          Move (sKeywords+"for For_All Forward Found from Function Function_Return ge Get Get_Argument_Size Get_File_Path getaddress ") to sKeywords
          Move (sKeywords+"getbuff getbuff_string Get_Attribute Get_Channel_Position Get_Current_Directory get_profile_string ") to sKeywords
          Move (sKeywords+"Goto gt Handle iand If ifnot ior Import_Class_Protocol ") to sKeywords
          Move (sKeywords+"in Increment indicate indicator inherited initialization inline insert Integer interface is item item_list le left local Loop lt ltrim ") to sKeywords
          Move (sKeywords+"mid mod Move moveint movenum movestr ne not Number num_arguments Object of On_Item On_Key Open or overload overstrike ") to sKeywords
          Move (sKeywords+"pos Pointer private Procedure Procedure_Return Procedure_Section Property protected public published put ") to sKeywords
          Move (sKeywords+"Read_Block Readln register Register_Function Register_Object Register_Procedure ") to sKeywords
          Move (sKeywords+"remove Repeat replace replaces Returns right RowID rtrim Runprogram ") to sKeywords
          Move (sKeywords+"Save SaveRecord Self Send SeqEof Set Set_Argument_Size Set_Attribute Set_Channel_Position ") to sKeywords
          Move (sKeywords+"Set_Date_Attribute Set_Directory shl Short Show Showln ") to sKeywords
          Move (sKeywords+"shr Start_UI Struct String Sysdate then Time TimeSpan to trim True type ") to sKeywords
          Move (sKeywords+"UBigInt UChar UInteger Until UShort Use var variant while write writeln xor zerofile zerostring zerotype") to sKeywords
          Move (Lowercase(sKeywords)) to sKeywords
          Move (sKeywords+Character(0)) to sKeywords
          Move (SendMessage(hWnd,SCI_SETKEYWORDS,0,AddressOf(sKeywords))) to iRet // found?
          //
          // set style bits (?)
          // ToDo: According to the DOC style bits are deprecated.
          //
          Move (SendMessage(hWnd,SCI_SETSTYLEBITS,5,0)) to iRet
          //
          //position.width=$(scale 576)
          //position.height=$(scale 740)
          //Set LexerProperty "position.width"   to "$(scale 576)"
          //Set LexerProperty "position.height"  to "$(scale 740)"
          
          //Set LexerProperty "position.width"   to "576"
          //Set LexerProperty "position.height"  to "740"
          
          //debug
          String sValue
          ZeroString 40 to sValue
          String sName
          Move ("position.width"+Character(0)) to sName
          Move (SendMessage(hWnd,SCI_GETPROPERTYEXPANDED,AddressOf(sName),AddressOf(sValue))) to iRet // found?

        End
        Else Begin
          Send Info_Box "DataFlex Lexer was not found."
        End
      End
    End_Procedure
    
    Procedure SetDefaultFoldingStyle
      Integer iRet
      Integer iFore
      Integer iBack
      Pointer pExpandIconXpm
      Pointer pCollapseIconXpm
      Pointer pBookmarkIconXpm
      Pointer pChangedLineIconXpm
      Pointer pSavedLineIconXpm
      //
      //line.margin.width=4
      //margin.width=$(scale 16)
      //fold.margin.width=$(scale 14)
      Set LexerProperty "line.margin.width" to "4"
      //Set LexerProperty "margin.width"      to "$(scale 16)"
      //Set LexerProperty "fold.margin.width" to "$(scale 14)"
      Set LexerProperty "margin.width"      to "16"
      Set LexerProperty "fold.margin.width" to "14"
      //
      // set folding defaults
      //
      Set LexerProperty "fold" to "1"
      Set LexerProperty "fold.compact" to "1"
      Set LexerProperty "fold.flags" to "1"
      Set LexerProperty "fold.comment" to "1"
      Set LexerProperty "fold.preprocessor" to "1"
      //
      // Now resize all the margins to zero
      // (This will be done in a RecalcLineMargin method...)
      //
      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 0
      //
      // Then Set the margin type and margin mask and resize it...
//      Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
      Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CODE_FOLDING SC_MARGIN_SYMBOL
      Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CODE_FOLDING SC_MASK_FOLDERS
      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING 20
      Send EditorMessage SCI_SETFOLDMARGINCOLOUR    True gtColorer[EC_LINENUMBERS].iBackC
      Send EditorMessage SCI_SETFOLDMARGINHICOLOUR  True gtColorer[EC_LEFTMARGIN].iForeC
      //
      // Needs marker defines
      Move (RGB($00,$00,$00)) to iBack
      Move (RGB($bb,$bb,$bb)) to iFore
      //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDEROPEN    SC_ALPHA_TRANSPARENT
      Move (SciEditorIconXpm(0)) To pExpandIconXpm       // get xpm icon from parser DLL
      Move (SciEditorIconXpm(1)) To pCollapseIconXpm     // These icons are created by hand by Sergey!
      Move (SciEditorIconXpm(2)) To pBookmarkIconXpm
      Move (SciEditorIconXpm(3)) To pChangedLineIconXpm
      Move (SciEditorIconXpm(4)) To pSavedLineIconXpm
      
      Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPEN    iBack
      Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPEN    iFore
      If (pCollapseIconXpm<>0) Begin
        Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPEN pCollapseIconXpm
      End
      //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPEN    SC_MARK_CIRCLEMINUS
      //Send EditorMessage SCI_MARKERSETALPHA SC_MARKNUM_FOLDER        SC_ALPHA_TRANSPARENT
      Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDER        iBack
      Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDER        iFore
      If (pExpandIconXpm<>0) Begin
        Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDER    pExpandIconXpm
      End
      //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERSUB     iBack
      //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERSUB     iFore
      Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERSUB     SC_MARK_EMPTY //SC_MARK_VLINE       //SC_MARK_EMPTY
      //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERTAIL    iBack
      //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERTAIL    iFore
      Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERTAIL    SC_MARK_EMPTY //SC_MARK_LCORNERCURVE
      Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEREND     iBack
      Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEREND     iFore
      If (pExpandIconXpm<>0) Begin
        Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEREND    pExpandIconXpm
      End
      ///Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEREND     SC_MARK_EMPTY //SC_MARK_CIRCLEPLUSCONNECTED
      Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDEROPENMID iBack
      Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDEROPENMID iFore
      If (pCollapseIconXpm<>0) Begin
        Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_FOLDEROPENMID pCollapseIconXpm
      End
      //Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDEROPENMID SC_MARK_EMPTY //SC_MARK_CIRCLEMINUSCONNECTED
      //Send EditorMessage SCI_MARKERSETBACK  SC_MARKNUM_FOLDERMIDTAIL iBack
      //Send EditorMessage SCI_MARKERSETFORE  SC_MARKNUM_FOLDERMIDTAIL iFore
      Send EditorMessage SCI_MARKERDEFINE   SC_MARKNUM_FOLDERMIDTAIL SC_MARK_EMPTY //SC_MARK_TCORNERCURVE
      //
      //
      // SendEditor(SCI_SETFOLDFLAGS, 16, 0); // 16  	Draw line below if not expanded
      Send EditorMessage SCI_SETFOLDFLAGS 16 0
      //
      // Tell scintilla we want to be notified about mouse clicks in the margin
      Send EditorMessage SCI_SETMARGINSENSITIVEN MARGIN_CODE_FOLDING 1
      //
      // for marker 10 define a background color instead of the marker symbol
      Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_LINEHIGHLIGHT SC_MARK_BACKGROUND
      Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_LINEHIGHLIGHT gtColorer[EC_HLIGHTEDLINE].iForeC //(rgb($DE,$DE,$EF))
      //
      // for marker 11 connect it to sergey's bookmark symbol
      //
      If (pBookmarkIconXpm<>0) Begin
        Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_BOOKMARK pBookmarkIconXpm
      End
      Else Begin // fall back on default
        Send EditorMessage SCI_MARKERDEFINE  SC_MARKNUM_BOOKMARK  SC_MARK_BOOKMARK
        Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_BOOKMARK  (rgb($DE,$00,$00))
      End
      //Send EditorMessage SCI_MARKERSETFORE SC_MARKNUM_BOOKMARK  (rgb($EE,$00,$00))
      //
      // for marker 12 and 13 connect it to the changedline icon
      If (pChangedLineIconXpm<>0) Begin
        Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINE pChangedLineIconXpm
      End
      Else Begin
        // We're using the SC_MARK_FULLRECT instead as we can set the color and width
        // dynamically.
        Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINE SC_MARK_FULLRECT
        Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINE  (rgb($FF,$F2,$00)) // yellow
      End
      
      If (pSavedLineIconXpm<>0) Begin
        Send EditorMessage SCI_MARKERDEFINEPIXMAP SC_MARKNUM_CHANGEDLINESAVED pSavedLineIconXpm
      End
      Else Begin
        Send EditorMessage SCI_MARKERDEFINE SC_MARKNUM_CHANGEDLINESAVED SC_MARK_FULLRECT
        Send EditorMessage SCI_MARKERSETBACK SC_MARKNUM_CHANGEDLINESAVED  (rgb($00,$FF,$00)) // green
      End
    End_Procedure
    
    Procedure SetDefaultWordStyle
      //
      // Use the default sets of word and whitespace characters. This sets whitespace to space, tab and
      // other characters with codes less than 0x20, with word characters set to alphanumeric and '_'.
      //
      Send EditorMessage SCI_SETCHARSDEFAULT
    End_Procedure
    
        // Should try to destroy the font object.
    Procedure Destroy_Object
      //Handle  hWnd
      Integer iRet

      Send ClearTextBuffer // just in case there is data in there.
      //Get piWindowHandle to hWnd
      Forward Send Destroy_Object
      Move (CMUnregisterControl()) to iRet
    End_Procedure

    Procedure ApplyEditorOptions
        Send DefaultFontStyles
        Send SetLexer
        Send SetDefaultFoldingStyle
        Send SetDefaultWordStyle
        Send EditorMessage SCI_USEPOPUP        SC_POPUP_NEVER  // Don't use the embedded popup menu, send WM_CONTEXTMENU to parent window
        Send EditorMessage SCI_SETMODEVENTMASK SC_MODEVENTMASKALL // show ALL events in SCN_MODIFIED
        Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_LINE_NUMBERS SC_MARGIN_NUMBER // margin 0 is for line numbers
        Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_BOOKMARKS    (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
        Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_BOOKMARKS    16
        Send EditorMessage SCI_SETMARGINMASKN  MARGIN_BOOKMARKS    SC_MASK_BOOKMARK
        Send EditorMessage SCI_SETMARGINTYPEN  MARGIN_CHANGED_LINE (SC_MARGIN_SYMBOL+SC_MARGIN_COLOUR)
        Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CHANGED_LINE 3
        Send EditorMessage SCI_SETMARGINMASKN  MARGIN_CHANGED_LINE SC_MASK_CHANGEDLINE
        //
        Send ClearRegisteredKeyBindings
    End_Procedure

        // Used to create the window...
    Procedure Page_Object Integer iFlag
        Integer iRet
        Handle  hWnd
        Forward Send Page_Object iFlag
        If iFlag begin
            If (piDragAcceptFilesState(Self)) Begin // Allow Dragging files into it.
              Move (DragAcceptFiles(Window_Handle(Self),True)) to iRet
            End
            Integer iSize
            Get Window_Handle to hWnd
            If (piWindowHandle(Self)=0) Begin
                Get GuiSize to iSize
                //Move (SetWindowPos(hWnd,0,2,2,Low(iSize),Hi(iSize),0)) to iRet
                Set piWindowHandle to hWnd
            End
            If (hWnd<>0) Begin
                Send ApplyEditorOptions
            End
        End
        //Send Windows_Message CMM_ENABLEOEMCODE (pbSaveAndLoadAsOEM(Self)) 0
        Send SetAdjustments
        Send onPaged
    End_Procedure

        // Procedures for overwriting. (sent by page after Object is paged.)
    Procedure SetAdjustments
    End_Procedure
    Procedure onPaged
      // some temp code to find out defaults (to be removed)
      //Integer i iCount iWidth
      //Get EditorMessage SCI_GETMARGINS 0 0 to iCount
      //For i from 0 to (iCount-1)
      //  Get EditorMessage SCI_GETMARGINWIDTHN i 0 to iWidth
      //Loop
    End_Procedure

        // Procedures for overwriting. (sent by copy and cut functions)
        // 28.1.2003 BP
    Procedure onBeforePaste
    End_Procedure
    Procedure onAfterPaste
    End_Procedure
    Procedure onBeforeCut
    End_Procedure
    Procedure onAfterCut
    End_Procedure


    //____CODEMAX_NATIVE_METHODs...___________________________________________________


    //
    // ToDo:
    //
    Function CM_SetLanguage String szName Returns Integer
        //Local_BUFFER szName pszName
        //Function_Return (SendMessage(Window_Handle(Self), CMM_SETLANGUAGE, 0, pszName))
    End_Function
    
    //
    // ToDo:
    //
    Function CM_GetLanguage Returns String
        Integer iRet
        String  szName
        //Local_BUFFER szName pszName CM_MAX_LANGUAGE_NAME
        //Move (SendMessage(Window_Handle(Self), CMM_GETLANGUAGE, 0, pszName))    to iRet
        Move "VDF" To szName
        Function_Return szName
    End_Function

    Function CM_EnableColorSyntax Integer bEnable Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLORSYNTAX,  ( bEnable ), 0 ) )
    End_Function

    Function CM_IsColorSyntaxEnabled Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLORSYNTAXENABLED, 0, 0 ) )
    End_Function

    Procedure onPreOpenFile String sFile
    End_Procedure
    Procedure onPostOpenFile String sFile
    End_Procedure
    
    //
    // This adds the line into a zero terminating textbuffer that holds the text of the
    // document we are reading.
    // It has to be fast so we allocate memory directly.
    // We also have to be able to pass a zero terminating string to scintilla.
    //
    Procedure AddLineToBuffer String sLine
      Address aOldText
      Address aNewText
      Boolean bOk
      Integer iLen iOldLen iNewLen
      Integer iVoid
      // By SVN on 23/05/2017 -- National Languages support
      Move (ToANSI(sLine)) to sLine
      //
      Move (Length(sLine)) To iLen
      If (iLen>0) Begin
        Get paTextData to aOldText
        If (aOldText=0) Begin

            Move (Alloc(iLen+1)) to aNewText // alloc enough room to be able to add a zero char
            Move 0    to iOldLen
            Move iLen to iNewLen
        End
        Else Begin
            Get piTextLength to iOldLen
            Move (iOldLen+iLen) to iNewLen
            Move (ReAlloc(aOldText,iNewLen+1)) to aNewText
        End
        Move (memcopy(aNewText+iOldLen, AddressOf(sLine), iLen)) to bOk // copy on top of terminating zero
        Move (StoreC(aNewText,iNewLen,0)) to iVoid                      // always add zero at the end
        Set paTextData   to aNewText
        Set piTextLength to iNewLen // length does not include the terminating zero
      End
    End_Procedure
    
    Procedure ClearTextBuffer
      Address aTextData
      Integer iVoid
      
      Get paTextData  to aTextData
      If (aTextData<>0) Begin
        Move (Free(aTextData)) to iVoid
      End
      Set paTextData   to 0
      Set piTextLength to 0
    End_Procedure
    
    
    Function CM_OpenFile String szFileName Returns Integer
        Integer iRet
        Integer iChannel
        Integer iLine
        Integer iResult
        Integer iVoid
        Boolean bIsCRLF
        String  sLine
        Address aTextData

        Set pbFileLoading to True
        Send onPreOpenFile szFileName
        //Move (SendMessage(Window_Handle(Self), CMM_OPENFILE, 0, ( pszFileName ) ) ) to iRet
        Move 0 To iLine
        Move True To bIsCRLF  // default, we are on windows
        Get Seq_New_Channel to iChannel
        If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
          Send Info_Box "No Channel Available for reading from a new file" "Error"
          function_return CME_FAILURE
        End
        // Need to use binary read mode if we want to preserve tab characters and not have automatic tab replacement
        Direct_Input channel iChannel ("binary:"+szFileName)
        Repeat
          Readln Channel iChannel sLine
          // As we read in binary mode, the readln reads until it sees a LF, the LF is dropped from the line we
          // read.
          If (iLine=0) Begin // we look at the line ending of the first line for how the document is likely to be formatted.
            If (Pos(CS_CR,sLine)>0) Begin  // if last char at line is CR then strip it
              If (Right(sLine,1)=CS_CR) Begin
                Move True To bIsCRLF
              End
            End
            Else Begin
              Move False To bIsCRLF // note this will set your doc to LF if you have NO lines yet!
            End
            Get CM_EnableCRLF bIsCRLF to iVoid
          End
          If (not(SeqEof)) Begin
            If (Right(sLine,1)=CS_CR) Begin
              //Move (Left(sLine,Length(sLine)-1)) To sLine // strip CR character
              Send AddLineToBuffer (sLine+CS_LF) // don't strip, just add so we have CRLF at the end
            End                                  // (hopefully this speeds it up again)
            Else Begin
              If (bIsCRLF=False) Begin
                Send AddLineToBuffer (sLine+CS_LF)
              End
              Else Begin // last line on CRLF text, but no line end.
                Send AddLineToBuffer sLine
              End
            End
            Increment iLine
          End
          Else If (iLine=0) Begin
            Get CM_EnableCRLF True to iVoid // default is CRLF
          End
        Until (Seqeof)
        Close_Input Channel iChannel
        Send Seq_Release_Channel iChannel

        // SCI_SETTEXT(<unused>, const char *text)
        Get paTextData to aTextData
        If (aTextData<>0) Begin
          Send EditorMessage SCI_SETTEXT 0 aTextData
          Send EditorMessage SCI_EMPTYUNDOBUFFER
          Move CME_SUCCESS to iResult
        End
        Else If (iLine=0) Begin
          Move CME_SUCCESS To iResult // opening an empty file, while an edge case should not throw an error.
        End
        Send ClearTextBuffer
        
        If iRet Send onPostOpenFile szFileName
        Set pbFileLoading to False
        Function_Return iResult
    End_Function

    // Not used in the Hammer
    //
    //Function CM_InsertFile String szFileName Integer pPos Returns Integer

    Function CM_InsertText String szText Integer iLine Integer iCol Returns Integer
      Integer iStartPos
      Integer iRet
      String  sBuffer
      //
      Move (szText+Character(0)) To sBuffer
      Get EditorMessage SCI_FINDCOLUMN iLine iCol to iStartPos
      Get EditorMessage SCI_INSERTTEXT iStartPos (AddressOf(sBuffer)) to iRet
      Move CME_SUCCESS To iRet
      Function_Return iRet
    End_Function

    // **WvA 23-07-2003 Modified to fix a crash
    // Quickly changing workspaces caused the window_handle to
    // be zero. Sending a message to a window with address 0 is fatal.
    Function CM_SetText String szText Returns Integer
        Integer hoWnd iRetVal
        String  sBuffer
        Get Window_Handle to hoWnd
        If (hoWnd) Begin
          Move (szText+Character(0)) To sBuffer
          Get EditorMessage SCI_SETTEXT 0 (AddressOf(sBuffer)) to iRetVal
          Move CME_SUCCESS To iRetVal
        End
        Else Begin
          Send Info_Box "Windows handle is ZXRO"
          Move CME_FAILURE to iRetVal
        End
        Function_Return iRetVal
    End_Function // CM_SetText

//
// Works differently in Scintilla
//
//        // Gets and Sets Colors with a string which is the in its ASCII values
//        // converted CM_Colors structure.
//    Function CM_SetColors String sColors Returns Integer
//    Function CM_GetColors Returns String

    Function CM_EnableWhitespaceDisplay Integer bEnable Returns Integer
      Integer iRet
      Integer eStyle
      If (bEnable) Begin
        Move SCWS_VISIBLEALWAYS To eStyle
      End
      Else Begin
        Move SCWS_INVISIBLE To eStyle
      End
      Get EditorMessage SCI_SETVIEWWS eStyle 0 to iRet
      Set DisplayEOLCharacters to eStyle
      Function_Return iRet
    End_Function
    
    Function CM_IsWhitespaceDisplayEnabled Returns Integer
      Boolean bEnabled
      Integer eStyle
      
      Move False to bEnabled
      Get EditorMessage SCI_GETVIEWWS 0 0 to eStyle
      If (eStyle<>SCWS_INVISIBLE) Begin
        Move True To bEnabled
      End
      Function_Return bEnabled
    End_Function

    Procedure ShowIndentationGuides
        Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
    End_Procedure
    Function CM_IsIndentationGuidesEnabled Returns Integer
        Integer eStyle
        Get EditorMessage SCI_GETINDENTATIONGUIDES 0 0 to eStyle
        Function_Return eStyle
    End_Function
    Procedure ToggleIndentationGuides
        Integer eStyle
        Get EditorMessage SCI_GETINDENTATIONGUIDES 0 0 to eStyle
        If (eStyle) Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_NONE
        Else        Send EditorMessage SCI_SETINDENTATIONGUIDES SC_IV_LOOKBOTH
    End_Procedure
    Procedure ToggleScopeBlocks Integer iMode
        Send EditorMessage SCI_FOLDALL iMode
    End_Procedure
    
    Procedure SelectTillEndOfLine Integer iMode
        Integer iVirtualSpace
        Send EditorMessage SCI_SETSELEOLFILLED iMode
        Move SCVS_NONE to iVirtualSpace
        If (iMode) Move SCVS_RECTANGULARSELECTION to iVirtualSpace
        Send EditorMessage SCI_SETVIRTUALSPACEOPTIONS iVirtualSpace
    End_Procedure

    Function CM_EnableTabExpand Integer bEnable  Returns Integer
      Integer iRet
      // bEnable = tabs change into spaces
      Get EditorMessage SCI_SETUSETABS (not(bEnable)) 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_IsTabExpandEnabled Returns Integer
      Boolean bUseTabs
      
      Get EditorMessage SCI_GETUSETABS 0 0 to bUseTabs
      Function_Return (not(bUseTabs))
    End_Function
    
// Don't think this exists in Scintilla
//
//    Function CM_EnableSmoothScrolling Integer bEnable Returns Integer
//    Function CM_IsSmoothScrollingEnabled Returns Integer

    Function CM_SetTabSize Integer iTabSize Returns Integer
    
      Send EditorMessage SCI_SETTABWIDTH iTabSize
      Function_Return CME_SUCCESS
    End_Function
    
    Function CM_GetTabSize Returns Integer
      Integer iSize
      
      Get EditorMessage SCI_GETTABWIDTH 0 0 To iSize
      Function_Return iSize
    End_Function

    Function CM_SetReadOnly Integer bReadOnly Returns Integer
    
      Send EditorMessage SCI_SETREADONLY bReadOnly
      Function_Return CME_SUCCESS
    End_Function
    
    Function CM_IsReadOnly Returns Integer
      Boolean bReadOnly
      Get EditorMessage SCI_GETREADONLY 0 0 To bReadOnly
      Function_Return bReadOnly
    End_Function

// Does not exist in scintilla
//
// Line tooltips are:
// enable or disable the display of a tooltip window showing the topmost visible line number while scrolling with the vertical scrollbar
//    Function CM_EnableLineToolTips Integer bEnable Returns Integer
//    Function CM_IsLineToolTipsEnabled Returns Integer

    // codemax: CMM_ENABLELEFTMARGIN
    // show or hide the left margin display area. The left margin area is used for line selection and the display of bookmarks.
    // scintilla has 5 margins, by default only margin 1 is set to 20 pixels, we keep it simple for now and
    // pretend we only have 1 margin. (MARGIN_CODE_FOLDING=1)
    Function CM_EnableLeftMargin Integer bEnable Returns Integer
      Integer iWidth
      If (bEnable) Begin
        Move 20 To iWidth
      End
      Else Begin
        Move 0 To iWidth
      End
      Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_CODE_FOLDING iWidth
      Function_Return CME_SUCCESS
    End_Function
    Function CM_IsLeftMarginEnabled Returns Integer
      Integer iWidth
      Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_CODE_FOLDING 0 to iWidth
      Function_Return (iWidth<>0)
    End_Function
    
    Procedure Set DisplayEOLCharacters Boolean bEnabled
      Send EditorMessage SCI_SETVIEWEOL   bEnabled               // show end of line characters
    End_Procedure
    
    Function DisplayEOLCharacters Returns Boolean
      Boolean bEnabled
      Get EditorMessage SCI_GETVIEWEOL 0 0 to bEnabled
      Function_Return bEnabled
    End_Function
    
    Procedure WriteBlock Integer iChannel Address aTextData Integer iPosition Integer iBlockSize
      Boolean bOk
      String  sBlock
      
      Move ""   To sBlock
      ZeroString iBlockSize To sBlock
      Move (memcopy(AddressOf(sBlock), aTextData+iPosition, iBlockSize)) to bOk
      // By SVN on 23/05/2017 -- National Languages support
      Write channel iChannel (ToOEM(sBlock))
      //Write Channel iChannel sBlock
    End_Procedure

    // An application sends CMM_SAVEFILE to save the buffer contents to a specific file.
    // bClearUndo
    // If TRUE, the undo buffer is cleared if the file is successfully saved.
    // If FALSE, the undo buffer is untouched and the user can undo past the last file save operation.
    //CME_SUCCESS=1
    Function CM_SaveFile String szFileName Integer bClearUndo  Returns Integer
      Integer iBlockSize
      Integer iChannel
      Integer iPosition
      Integer iRet
      Integer iResult
      Address aTextData
      Integer iTextLength

      Move 0    To iPosition
      Move 512  To iBlockSize
      Move True To bClearUndo // looks like this was ignored by codemax and always true
      Send EditorMessage SCI_SETREADONLY 1
      Get EditorMessage SCI_GETCHARACTERPOINTER 0 0 to aTextData
      Move (CStringLength(aTextData)) To iTextLength
      If (iTextLength>1) Begin
        
        Get Seq_New_Channel to iChannel
        If (iChannel=DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
          Send Info_Box "No Channel Available for saving file" "Error"
          Send EditorMessage SCI_SETREADONLY 0
          function_return CME_FAILURE
        End

        Direct_Output channel iChannel szFileName
        While ((iPosition+iBlockSize)<iTextLength)
          Send WriteBlock iChannel aTextData iPosition iBlockSize

          Move (iPosition+iBlockSize) To iPosition
        Loop
        If (iPosition<iTextLength) Begin
          Send WriteBlock iChannel aTextData iPosition (iTextLength-iPosition)
        End
        Close_Output Channel iChannel
        Send Seq_Release_Channel iChannel
        
        If (bClearUndo) Begin
          Send EditorMessage SCI_SETSAVEPOINT
        End
        
        Move CME_SUCCESS To iResult
      End
      Send EditorMessage SCI_SETREADONLY 0
      Function_Return iResult
    End_Function



    // Not used in the Hammer
    //
    //Function CM_ReplaceText String szText Integer pRange Returns Integer
    //    Local_BUFFER szText pszText
    //    Function_Return (SendMessage(Window_Handle(Self), CMM_REPLACETEXT,  ( pRange ), ( pszText ) ) )
    //End_Function

    //
    // Only used for passing the editor text to the parser, the parser code has been adjusted for that
    // for scintilla so no need to have the code here.
    //
    //Function CM_GetTextLength Integer pRange Integer bLogical Returns Integer
    //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETTEXTLENGTH,  ( pRange ), ( bLogical ) ) )
    //End_Function
    //Function CM_GetText Integer pRange Returns String
    //    Integer iRet iSize
    //    Move (CM_GetTextLength(Self,pRange,False)) to iSize
    //    Local_BUFFER szText pszText (iSize+1)
    //    Move (SendMessage(Window_Handle(Self), CMM_GETTEXT,  ( pRange ), ( pszText ) ) )    to iRet
    //    Function_Return szText
    //End_Function

    // CMM_GETLINECOUNT
    Function CM_GetLineCount Returns Integer
      Integer iLineCount
      Get EditorMessage SCI_GETLINECOUNT 0 0 to iLineCount
      Function_Return iLineCount
    End_Function
    
    // An application sends CMM_GETLINELENGTH to determine the length of a specific line in the edit buffer
    // nLine
    // The zero-based index of the line to retrieve the length of.
    // bLogical
    // TRUE to return the number of logical characters. FALSE to return the number of bytes (or double-bytes if Unicode version used).
    // SCI_LINELENGTH returns bytes, we ignore bLogical
    Function CM_GetLineLength Integer iLine Integer bLogical Returns Integer
      Integer iLineLength
      Integer iEOLPos
      Integer iStartPos
      // SCI_LINELENGTH also counts the EOL characters, not always handy
      //Get EditorMessage SCI_LINELENGTH iLine 0 to iLineLength
      Get EditorMessage SCI_GETLINEENDPOSITION iLine 0 to iEOLPos
      Get EditorMessage SCI_POSITIONFROMLINE   iLine 0 to iStartPos
      Move (iEOLPos-iStartPos) To iLineLength
      Function_Return iLineLength
    End_Function
    
    // An application sends CMM_GETLINE to retrieve the text on a specific line.
    // nLine - The zero-based line number of the line text to retrieve. nLine must be the index of a valid line number.
    // The number of lines in the buffer can be determined with CMM_GETLINECOUNT.
    // pszBuff - A pointer to a TCHAR buffer where to receive the line text.
    // The necessary buffer size can be determined by first sending CMM_GETLINELENGTH. pszBuff must not be NULL.
    Function CM_GetLine Integer iLine Returns String
      Integer iEOLPos
      Integer iStartPos
      Integer iLineLength
      Integer iRet
      String  sBuffer
      Sci_TextRange Sel
      
      // Can't use sci_linelength and sci_getline as we need the text without EOL characters
      //Get EditorMessage SCI_LINELENGTH iLine 0 to iLineLength
      //Get EditorMessage SCI_GETLINE iLine (AddressOf(szText)) to iRet
      Move "" To sBuffer
      Get EditorMessage SCI_POSITIONFROMLINE   iLine 0 to iStartPos
      Get EditorMessage SCI_GETLINEENDPOSITION iLine 0 to iEOLPos
      Move (iEOLPos-iStartPos) To iLineLength
      If (iLineLength<>0) Begin
        Move iStartPos To Sel.chrg.cpMin
        Move iEOLPos   To Sel.chrg.cpMax
        ZeroString (iLineLength+1) To sBuffer
        Move (AddressOf(sBuffer)) To Sel.lpstrText
        Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
        Move (CString(sBuffer)) To sBuffer
      End
      Function_Return sBuffer
    End_Function

    //
    // An application sends CMM_GETWORDLENGTH to calculate the length of the word at a specific position in the buffer.
    // pPos
    // Pointer to a CM_POSITION structure that contains the buffer position of the word to be retrieved.
    // If NULL, the current caret position is used.
    // The hammer ONLY uses it internally in CM_GetWord, so we discard it and add it directly to
    // CM_GetWord.
    //Function CM_GetWordLength Integer pPos Integer bLogical Returns Integer
    //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETWORDLENGTH,  ( pPos ), ( bLogical ) ) )
    //End_Function
    
    // An application sends CMM_GETWORD to retrieve the word at a specific position in the buffer.
    Function CM_GetWord Integer iLine Integer iCol Returns String
      Integer iPos
      Integer iStartPos iEndPos
      Integer iRet iSize
      String  sBuffer
      Sci_TextRange Sel
      
      Get EditorMessage SCI_FINDCOLUMN iLine iCol to iPos
      Get EditorMessage SCI_WORDSTARTPOSITION iPos True to iStartPos
      Get EditorMessage SCI_WORDENDPOSITION   iPos True to iEndPos
      If (iStartPos>=0 and iStartPos<>iEndPos) Begin
        Move iStartPos To Sel.chrg.cpMin
        Move iEndPos   To Sel.chrg.cpMax
        Move ((iEndPos-iStartPos)+2) To iSize
        ZeroString iSize To sBuffer
        Move (AddressOf(sBuffer)) To Sel.lpstrText
        Get EditorMessage SCI_GETTEXTRANGE 0 (AddressOf(Sel)) to iRet
        Move (CString(sBuffer)) To sBuffer
      End
      Else Begin
        Move "" To sBuffer
      End
      Function_Return sBuffer
    End_Function
        // Gets the current word in a code max way.
    Function CM_GetCurrentWord Returns String
        String  sWord
        Integer iRet
        Get CM_GetSel False                                         to iRet
        Get CM_GetWord (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
        Function_Return sWord
    End_Function

        // Selfmade word getter, which doesnt stop the word on a "."
        // So its easy to use it for getting a file under cursor.
    Function CM_GetWordIncludingDot Integer iLine Integer iCol Returns String
        Integer iStart iEnd iLen iC
        String sLine
        Get value item iLine    to sLine
        Move (Length(sLine))    to iLen
        For iEnd from (iCol+1) to iLen
            If (Mid(sLine,1,iEnd)) Eq " " Break
        End
        For iC from 1 to iCol
            Move (iCol-iC+1)            to iStart
            If (Mid(sLine,1,iStart)) Eq " " Break
        End
        Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
    End_Function
        // Gets the current word under the cursor, but does not stop at a dot (.)
        // only a space character ends the word.
    Function CM_GetCurrentWordIncludingDot Returns String
        String  sWord
        Integer iRet
        Get CM_GetSel False                                         to iRet
        Get CM_GetWordIncludingDot (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
        Function_Return sWord
    End_Function

        //@RRS Selfmade word getter, which find the word from where the cursor is
    Function CM_GetWord3 Integer iLine Integer iCol Returns String
        Integer iStart iEnd iLen iC
        String sLine

        Get value item iLine    to sLine
        Move (Length(sLine))    to iLen

        //For iEnd From (iCol+1) To iLen
        //    If (Mid(sLine,1,iEnd)) Eq " " Break
        //End
        Move iCol to iEnd
        For iC from 1 to iCol
            Move (iCol-iC+1) to iStart
            If (Mid(sLine,1,iStart)) Eq " " Break
        End
        Function_Return (Trim(Mid(sLine,iEnd-iStart+1,iStart)))
    End_Function


        //@RRS Gets the current word in selfmade way.
    Function CM_GetCurrentWord3 Returns String
        String  sWord
        Integer iRet
        Get CM_GetSel False                                        to iRet
        Get CM_GetWord3 (piSelEndLine(Self)) (piSelEndCol(Self))   to sWord
        Function_Return sWord
    End_Function

        //@ RRS New Procedure Used by isReasonForFieldList
    Procedure ReplaceCurrentWord2 String sNew
        String  sWord sTmp sLine
        Integer iRet iLine iCol iColStart
        Integer iStart iEnd iLen iC iPos iTmp

        Move (piSelEndLine(Self))  to iLine
        Move (piSelEndCol(Self))   to iCol

        Get value item iLine to sLine
        Move (Length(sLine)) to iLen
        //showln 'iLen=' iLen
        //showln 'iCol=' iCol

        //@For iEnd From (iCol+1) To iLen
        For iEnd from iCol to iLen
           If (Mid(sLine,1,iEnd)) Eq " " Break
        End
        For iC from 1 to iCol
           Move (iCol-iC+1)            to iStart
           If (Mid(sLine,1,iStart)) Eq " " Break
        End
        Move sLine to sTmp
        Repeat
           Move (Pos(Uppercase(sNew),Uppercase(sTmp))) to iTmp
           If (iTmp) Begin
             Move (Remove(sTmp,1,iTmp)) to sTmp
             Move (iTmp+iPos) to iPos
           End
        Until ((iPos>=iStart) or (iTmp=0))
        //showln 'iPos=' iPos
        //showln 'iSTart=' iStart
        //showln 'iEnd=' iEnd
        //@if (iPos>=iStart) Move iPos to iStart
        If (iPos) Move iPos to iStart
        Move (Overstrike(sNew,sLine,iStart)) to sLine
        //showln 'sLine=' sLine
        Get CM_DeleteLine iLine to iRet
        Get CM_InsertLine iLine sLine to iRet
        Set piSelEndCol to (Length(sLine))
    End_Procedure
        //@ RRS New Procedure
    Procedure RemoveCurrentWord2 //@
        String  sWord
        Integer iRet iLine iCol iColStart
        Integer iStart iEnd iLen iC
        String  sLine

        Move (piSelEndLine(Self))  to iLine
        Move (piSelStartCol(Self)) to iColStart
        Move (piSelEndCol(Self))   to iCol

        Get value item iLine    to sLine
        Move (Length(sLine))    to iLen

        For iEnd from (iCol+1) to iLen
            If (Mid(sLine,1,iEnd)) Eq " " Break
        End
        For iC from 1 to iCol
            Move (iCol-iC+1)            to iStart
            If (Mid(sLine,1,iStart)) Eq " " Break
        End
        Move (Left(sLine,iStart)) to sLine

        Get CM_DeleteLine iLine     to iRet
        Get CM_InsertLine iLine sLine to iRet
        Set piSelEndCol to (Length(sLine))
    End_Procedure

    // An application sends the CMM_ADDTEXT message to add the specified text to the end of the edit buffer.
    //
    Function CM_AddText String szText Returns Integer
      Integer iRet
      Get EditorMessage SCI_APPENDTEXT (Length(szText)) (AddressOf(szText)) to iRet
      Function_Return CME_SUCCESS
    End_Function
    
    //
    // An application sends CMM_DELETELINE to delete a line from the buffer.
    //
    Function CM_DeleteLine Integer iLine  Returns Integer
      Integer iCol
      Integer iStartPos
      Integer iLineLength
      Integer iRet
      
      Move 0 To iCol
      Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
      Get EditorMessage SCI_LINELENGTH  iLine     0           to iLineLength
      Get EditorMessage SCI_DELETERANGE iStartPos iLinelength to iRet
      Function_Return CME_SUCCESS
    End_Function

    //
    // An application sends CMM_INSERTLINE to insert a line of text into the edit buffer.
    // iLine
    // The zero-based index of the line to insert before.
    // pszText
    // The text of the line to insert. This text should not contain any carriage returns or linefeeds.
    //
    Function CM_InsertLine Integer iLine String szText Returns Integer
      Integer iCol
      Integer iStartPos
      Integer iRet
      String  sEOLChar
      
      Move 0 To iCol
      Get psEOLChar to sEOLChar
      Move (CString(szText)+sEOLChar+Character(0)) To szText
      Get EditorMessage SCI_FINDCOLUMN  iLine     iCol        to iStartPos
      Get EditorMessage SCI_INSERTTEXT iStartPos  (AddressOf(sztext)) to iRet
      Function_Return CME_SUCCESS
    End_Function
    
    
    // Gets the active selection and fills it into the properties.
    // Normalized: True=StartPosition always before EndPosition
    // CMM_GETSEL
    Function CM_GetSel Integer bNormalized Returns Integer
      Integer iRet iLine iCol
      Integer iStartPos iEndPos
      
      // With Scintilla we ignore the bNormalized option as it returns the start position as
      // smaller anyways.
      Get EditorMessage SCI_GETSELECTIONSTART 0 0 to iStartPos
      Get EditorMessage SCI_GETSELECTIONEND   0 0 to iEndPos
      
      Get EditorMessage SCI_LINEFROMPOSITION iStartPos 0 to iLine
      Get EditorMessage SCI_GETCOLUMN        iStartPos 0 to iCol
      Set piSelStartLine  to iLine
      Set piSelStartCol   to iCol
      If (iStartPos<>iEndPos) Begin
        Get EditorMessage SCI_LINEFROMPOSITION iEndPos   0 to iLine
        Get EditorMessage SCI_GETCOLUMN        iEndPos   0 to iCol
      End
      Set piSelEndLine  to iLine
      Set piSelEndCol   to iCol
      Move CME_SUCCESS To iRet
      Function_Return iRet
    End_Function
    // CMM_SETSEL
    // bMakeVisible
    // If TRUE, the selection will be scrolled into view. If FALSE, the window contents will not be scrolled.
    Function CM_SetSel Integer iStartLine Integer iStartCol Integer iEndLine Integer iEndCol  Integer bMakeVisible Returns Integer
      Integer iStartPos
      Integer iEndPos
      Integer iRet
      
      Get EditorMessage SCI_FINDCOLUMN iStartLine iStartCol to iStartPos
      Get EditorMessage SCI_FINDCOLUMN iEndLine   iEndCol   to iEndPos
      If (bMakeVisible) Begin
        Send EditorMessage SCI_SETSEL iStartPos iEndPos
      End
      Else Begin
        Send EditorMessage SCI_SETEMPTYSELECTION iEndPos  // set caret at end pos to start with and empty previous selections
        Send EditorMessage SCI_SETSELECTIONSTART iStartPos
        Send EditorMessage SCI_SETSELECTIONEND   iEndPos
      End
      
      Move CME_SUCCESS To iRet
      Function_Return iRet
    End_Function
    
    // An application sends CMM_DELETESEL to delete the currently selected text from the buffer.
    Function CM_DeleteSel Returns Integer
      Integer iRet
      Integer iStartPos iEndPos
      Integer iLength
      
      Move CME_FAILURE To iRet
      Get EditorMessage SCI_GETSELECTIONSTART 0 0 to iStartPos
      Get EditorMessage SCI_GETSELECTIONEND   0 0 to iEndPos
      Move (iEndPos-iStartPos) To iLength
      If (iLength>0) Begin
        Send EditorMessage SCI_DELETERANGE iStartPos iLength
        Move CME_SUCCESS To iRet
      End
      Function_Return iRet
    End_Function
    
    // An application sends CMM_REPLACESEL to replace the current buffer selection with a body of text
    Function CM_ReplaceSel String szText  Returns Integer
      Move (szText+Character(0)) To szText
      Send EditorMessage SCI_REPLACESEL 0 (AddressOf(szText))
      Function_Return CME_SUCCESS
    End_Function

    //
    // ToDo: CM_ExecuteCmd
    //
    Function CM_ExecuteCmd Integer wCmd Integer dwCmdData Returns Integer
      Integer iSCICmd
      Integer iLine
      Integer iVoid
      
      Move 0 To iSCICmd
      Case Begin
        Case (wCmd=CMD_SELECTLINE)
          Get piSelEndLine to iLine
          Get CM_SelectLine iLine True to iVoid
          Case Break
        Case (wCmd=CMD_LINEDELETE)
          Get piSelEndLine to iLine
          Get CM_DeleteLine iLine to iVoid
          Case Break
        Case (wCmd=CMD_Find)
          Send Find
          Case Break
        Case (wCmd=CMD_FindNext)
          Send FindNext
          Case Break
        Case (wCmd=CMD_FINDPREV)
          Send FindPrevious
          Case Break
        Case (wCmd=CMD_FindReplace)
          // ToDo: CMD_FindReplace
          Case Break
        Case (wCmd=CMD_UPPERCASESELECTION)
          Send SC_UppercaseSelection
          Case Break
        Case (wCmd=CMD_LOWERCASESELECTION)
          Send SC_LowercaseSelection
          Case Break
        Case (wCmd=CMD_BOOKMARKTOGGLE)
          Send BookmarkToggle
          Case Break
        Case (wCmd=CMD_BOOKMARKCLEARALL)
          Send BookmarkClearAll
          Case Break
        Case (wCmd=CMD_BOOKMARKJUMPTOFIRST)
          Send BookmarkJumpToFirst
          Case Break
        Case (wCmd=CMD_BOOKMARKJUMPTOLAST)
          Send BookmarkJumpToLast
          Case Break
        Case (wCmd=CMD_BOOKMARKNEXT)
          Send BookmarkNext
          Case Break
        Case (wCmd=CMD_BOOKMARKPREV)
          Send BookmarkPrevious
          Case Break
        Case (wCmd=CMD_GOTOINDENTATION)
          Case Break
        Case (wCmd=CMD_GOTOMATCHBRACE)
          Case Break
        Case (wCmd=CMD_RECORDMACRO)
          Case Break
        Case (wCmd=CMD_PLAYMACRO1)
          Case Break
        Case (wCmd=CMD_PLAYMACRO2)
          Case Break
        Case (wCmd=CMD_PLAYMACRO3)
          Case Break
        Case (wCmd=CMD_PLAYMACRO4)
          Case Break
        Case (wCmd=CMD_PLAYMACRO5)
          Case Break
        Case (wCmd=CMD_PLAYMACRO6)
          Case Break
        Case (wCmd=CMD_PLAYMACRO7)
          Case Break
        Case (wCmd=CMD_PLAYMACRO8)
          Case Break
        Case (wCmd=CMD_PLAYMACRO9)
          Case Break
        Case (wCmd=CMD_PLAYMACRO10)
          Case Break
        Case (wCmd=CMD_CODETIP)
          Get Msg_DoCodeTip 0 to iVoid
          Case Break
        Case (wCmd=CMD_CODELIST)
          Get Msg_DoCodeList 0 to iVoid
          Case Break
      Case End
      If (iSCICmd) Begin
        Send EditorMessage iSCICmd
      End
      //  Function_Return (SendMessage(Window_Handle(Self), CMM_EXECUTECMD,  ( wCmd ), ( dwCmdData ) ) )
      Function_Return CME_SUCCESS
    End_Function

//
// ToDo: Currently no support for splitter screen
//
//    Function CM_SetSplitterPos Integer bHorz  Integer nPos Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_SETSPLITTERPOS,  ( bHorz ), ( nPos ) ) )
//    End_Function
//    Function CM_GetSplitterPos Integer bHorz Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_GETSPLITTERPOS,  ( bHorz ), 0 ) )
//    End_Function

    //
    // An application sends CMM_SETAUTOINDENTMODE to set the current auto-indent mode.
    // The auto-indent mode determines how a new line is indented when ENTER is pressed
    //
    Function CM_SetAutoIndentMode Integer eMode Returns Integer
      If (eMode=CM_INDENT_SCOPE) Begin
        Move CM_INDENT_PREVLINE to eMode
      End
      Set peAutoIndentMode to eMode
      Function_Return CME_SUCCESS
    End_Function
    //
    // CMM_GETAUTOINDENTMODE
    // An application sends CMM_GETAUTOINDENTMODE to determine the current auto-indent mode. The auto-indent mode determines how
    // a new line is indented when ENTER is pressed.
    //
    // CM_INDENT_OFF - No indentation occurs. The next line begins at column zero (0).
    // CM_INDENT_SCOPE - Language-specific scoping is used to determine the correct indentation level for the next line.
    //                   This setting parses the buffer contents, looking backward for scope keywords until the start of
    //                   the current scope is encountered. Once found, the indentation is copied to the next line.
    //                   If no language is set, CM_INDENT_PREVLINE is used.
    // CM_INDENT_PREVLINE - Indentation is copied from the previous line.
    // The default setting is CM_INDENT_PREVLINE.
    // CM_INDENT_SCOPE is not supported for Scintilla now
    Function CM_GetAutoIndentMode Returns Integer
      Integer eMode
      
      Get peAutoIndentMode to eMode
      Function_Return eMode
    End_Function
    Function CM_CanUndo Returns Integer
      Integer iRet
      Get EditorMessage SCI_CANUNDO 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_CanRedo Returns Integer
      Integer iRet
      Get EditorMessage SCI_CANREDO 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_Redo Returns Integer
      Integer iRet
      Get EditorMessage SCI_REDO 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_Undo Returns Integer
      Integer iRet
      Get EditorMessage SCI_UNDO 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_ClearUndoBuffer Returns Integer
      Integer iRet
      // This command tells Scintilla to forget any saved undo or redo history.
      // It also sets the save point to the start of the undo buffer, so the document will appear to be unmodified.
      Get EditorMessage SCI_EMPTYUNDOBUFFER 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_CanCut Returns Integer
      Integer iRet
      Get EditorMessage SCI_GETSELECTIONEMPTY 0 0 to iRet
      Function_Return (iRet=0)
    End_Function
    Function CM_CanCopy Returns Integer
      Integer iRet
      Get EditorMessage SCI_GETSELECTIONEMPTY 0 0 to iRet
      Function_Return (iRet=0)
    End_Function
    Function CM_CanPaste Returns Integer
      Integer iRet
      Get EditorMessage SCI_CANPASTE 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_Cut Returns Integer
      Integer iRet
      Send OnBeforeCut
      Get EditorMessage SCI_CUT 0 0 to iRet
      Send OnAfterCut
      Function_Return iRet
    End_Function
    Function CM_Copy Returns Integer
      Integer iRet
      Get EditorMessage SCI_COPY 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_Paste Returns Integer
      Integer iRet
      Send OnBeforePaste
      Get EditorMessage SCI_PASTE 0 0 to iRet
      Send OnAfterPaste
      Function_Return iRet
    End_Function
    Function CM_IsRecordingMacro Returns Integer
      // Not sure if the function is for starting to record.
      //Integer iRet
      //Get EditorMessage SCI_STARTRECORD 0 0 to iRet
      //Function_Return iRet
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISRECORDINGMACRO, 0, 0 ) )
    End_Function
    Function CM_IsPlayingMacro Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISPLAYINGMACRO, 0, 0 ) )
    End_Function
//
// There is no undo limit in scintilla, the amount of free memory is the limit.
//
//    Function CM_SetUndoLimit Integer nLimit Returns Integer
//    Function CM_GetUndoLimit Returns Integer

    Procedure ToggleLineChanged
        Integer iLine
        
        Get Current_Line to iLine
        Send LineChangedMark iLine
    End_Procedure

    Function CM_IsModified Returns Integer
      Integer iRet
      Get EditorMessage SCI_GETMODIFY 0 0 to iRet
      Function_Return iRet
    End_Function
//
// Does not seem to exist in Scintilla
//
//    Function CM_SetModified Integer bModified Returns Integer

    Function CM_EnableOvertype Integer bEnable Returns Integer
      Integer iRet
      Get EditorMessage SCI_SETOVERTYPE bEnable 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_IsOvertypeEnabled Returns Integer
      Integer iRet
      Get EditorMessage SCI_GETOVERTYPE 0 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_EnableCaseSensitive Integer bEnable Returns Integer
      Integer iFlags
      Integer iRet
      Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
      If (bEnable) Begin
        //
        Move (iFlags iOr SCFIND_MATCHCASE) To iFlags
      End
      Else Begin
        Move (iFlags iAnd (iNot(SCFIND_MATCHCASE))) To iFlags
      End
      Get EditorMessage SCI_SETSEARCHFLAGS iFlags 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_IsCaseSensitiveEnabled Returns Integer
      Integer iFlags
      Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
      Move (iFlags iAnd SCFIND_MATCHCASE) To iFlags
      Function_Return (iFlags<>0)
    End_Function
    
    // Weird codemax feature, not in scintilla
    // If TRUE, subsequent Find/Replace operations will format the Replace text such that it follows
    // the same case pattern of the Find text:
    //Function CM_EnablePreserveCase Integer bEnable Returns Integer
    //    Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEPRESERVECASE,  ( bEnable ), 0 ) )
    //End_Function
    //Function CM_IsPreserveCaseEnabled Returns Integer
    //    Function_Return (SendMessage(Window_Handle(Self), CMM_ISPRESERVECASEENABLED, 0, 0 ) )
    //End_Function
    
    // An application sends CMM_ENABLEWHOLEWORD to enable or disable whole word searching during a find or find and replace operation
    Function CM_EnableWholeWord Integer bEnable Returns Integer
      Integer iFlags
      Integer iRet
      //
      Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
      If (bEnable) Begin
        //
        Move (iFlags iOr SCFIND_WHOLEWORD) To iFlags
      End
      Else Begin
        Move (iFlags iAnd (iNot(SCFIND_WHOLEWORD))) To iFlags
      End
      Get EditorMessage SCI_SETSEARCHFLAGS iFlags 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_IsWholeWordEnabled Returns Integer
      Integer iFlags
      Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
      Move (iFlags iAnd SCFIND_WHOLEWORD) To iFlags
      Function_Return (iFlags<>0)
    End_Function
    
    
    Function CM_EnableRegExp Integer bEnable Returns Integer
      Integer iFlags
      Integer iRet
      //
      Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
      If (bEnable) Begin
        //
        Move (iFlags iOr SCFIND_REGEXP) To iFlags
      End
      Else Begin
        Move (iFlags iAnd (iNot(SCFIND_REGEXP))) To iFlags
      End
      Get EditorMessage SCI_SETSEARCHFLAGS iFlags 0 to iRet // CMM_ENABLEREGEXP
      Function_Return iRet
    End_Function
    
    Function CM_IsRegExpEnabled Returns Integer
      Integer iFlags
      Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags // CMM_ISREGEXPENABLED
      Move (iFlags iAnd SCFIND_REGEXP) To iFlags
      Function_Return (iFlags<>0)
    End_Function
    
    // An application sends CMM_SETTOPINDEX to set the topmost visible line in a specific view.
    // This might be the same as SCI_SETFIRSTVISIBLELINE(int displayLine) but not completely clear to me now.
    //Function CM_SetTopIndex Integer nView Integer nLine Returns Integer
    //    Function_Return (SendMessage(Window_Handle(Self), CMM_SETTOPINDEX,  ( nView ), ( nLine ) ) )
    //End_Function
    //Function CM_GetTopIndex Integer nView Returns Integer
    //    Function_Return (SendMessage(Window_Handle(Self), CMM_GETTOPINDEX,  ( nView ), 0 ) )
    //End_Function
    
    // SCI_LINESONSCREEN
    Function CM_GetVisibleLineCount Integer nView Integer bFullyVisible Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_GETVISIBLELINECOUNT,  ( nView ), ( bFullyVisible ) ) )
    End_Function
    
    // An application sends CMM_ENABLECRLF to enable or disable the inclusion of carriage returns when
    // multiple lines of text are retrieved from the edit buffer
    // bEnable - If TRUE, multiple lines of text retrieved from the edit buffer are delimited by a
    //  carriage return (\r) and a linefeed (\n). If FALSE, lines are delimited by only a linefeed (\n).
    //  The default setting is TRUE.
    Function CM_EnableCRLF Integer bEnable Returns Integer
      Integer eMode
      Integer iRet
      
      If (bEnable) Begin
        Move SC_EOL_CRLF to eMode
        Set psEOLChar    to CS_CRLF
      End
      Else Begin
        Move SC_EOL_LF   To eMode
        Set psEOLChar    to CS_LF
      End
      Send EditorMessage SCI_SETEOLMODE eMode
      Function_Return CME_SUCCESS
    End_Function
    
    // The return value is TRUE if multiple lines of text retrieved from the edit buffer are delimited by
    // a carriage return (\r) and a linefeed (\n). The return value is FALSE if lines are delimited by
    // only a linefeed (\n). The default setting is TRUE.
    Function CM_IsCRLFEnabled Returns Boolean
      Integer eMode
      Boolean bEnabled
      Move False to bEnabled
      Get EditorMessage SCI_GETEOLMODE to eMode
      If (eMode=SC_EOL_CRLF) Move True to bEnabled
      Function_Return True
    End_Function
//
// Removed - SetFontOwnership is a codemax concept
//
//    Function CM_SetFontOwnership Integer bEnable Returns Integer
//    Function CM_GetFontOwnership Returns Integer

    Function CM_GetCurrentView Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTVIEW, 0, 0 ) )
    End_Function
    // SVN
    Function CM_SetCurrentView Integer nLine Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_SETCURRENTVIEW, nLine, 0 ) )
    End_Function
    // SVN
    Function CM_GetViewCount Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_GETVIEWCOUNT, 0, 0 ) )
    End_Function
    Function CM_ShowScrollBar Integer bHorz  Integer bShow Returns Integer
      Integer iRet
      If (bHorz) Begin
        Send EditorMessage SCI_SETHSCROLLBAR bShow
      End
      Else Begin
        Send EditorMessage SCI_SETVSCROLLBAR bShow
      End
      Function_Return iRet
    End_Function
    Function CM_HasScrollBar Integer bHorz Returns Integer
      Integer iRet
      If (bHorz) Begin
        Get EditorMessage SCI_GETHSCROLLBAR 0 0 to iRet
      End
      Else Begin
        Get EditorMessage SCI_GETVSCROLLBAR 0 0 to iRet
      End
      Function_Return iRet
    End_Function
    
    Function CM_GetSelFromPoint Integer xClient Integer yClient Returns Integer
      Integer iLine iCol
      Integer iPos

      Get EditorMessage SCI_POSITIONFROMPOINT xClient yClient to iPos
      If (iPos>-1) Begin
        Get EditorMessage SCI_LINEFROMPOSITION iPos 0 to iLine
        Get EditorMessage SCI_GETCOLUMN        iPos 0 to iCol
        
        Set piSelStartLine                              to iLine
        Set piSelStartCol                               to iCol
        Set piSelEndLine                                to iLine
        Set piSelEndCol                                 to iCol
      End
      Function_Return iPos
    End_Function
    
    Procedure SC_LineCut
      Send EditorMessage SCI_LINECUT
    End_Procedure
    
    Procedure SC_UppercaseSelection
      Send EditorMessage SCI_UPPERCASE
    End_Procedure
    
    Procedure SC_LowercaseSelection
      Send EditorMessage SCI_LOWERCASE
    End_Procedure
    
    // An application sends CMM_SELECTLINE to select a line of text in the edit buffer
    // bMakeVisible
    // If TRUE, the line will be scrolled into view if necessary. If FALSE, the line will never be scrolled.
    //
    Function CM_SelectLine Integer iLine Integer bMakeVisible Returns Integer
      Integer iAnchor
      Integer iCaret
      Integer iRet
      
      Get EditorMessage SCI_POSITIONFROMLINE iLine 0 to iAnchor
      Get EditorMessage SCI_GETLINEENDPOSITION iline 0 to iCaret
      If (bMakeVisible) Begin
        Get EditorMessage SCI_SETSEL iAnchor iCaret to iRet
      End
      Else Begin
        Send EditorMessage SCI_SETSELECTIONSTART iAnchor
        Send EditorMessage SCI_SETSELECTIONEND   iCaret
      End
      Function_Return CME_SUCCESS
    End_Function
    Function CM_HitTest Integer xClient Integer yClient Returns Integer
      Integer iPos
      Integer iRet
      
      Move CM_NOWHERE to iRet
      Get EditorMessage SCI_CHARPOSITIONFROMPOINT xClient yClient to iPos
      If (iPos>-1) Begin
        Move CM_EDITSPACE To iRet
      End
      Function_Return (65536*iRet)
    End_Function
    Function CM_EnableDragDrop Integer bEnable Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEDRAGDROP,  ( bEnable ), 0 ) )
    End_Function
    Function CM_IsDragDropEnabled Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISDRAGDROPENABLED, 0, 0 ) )
    End_Function

//
// ToDo: Currently no support for splitter screen
//
//    Function CM_EnableSplitter Integer bHorz Integer bEnable Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESPLITTER,  ( bHorz ), ( bEnable ) ) )
//    End_Function
//    Function CM_IsSplitterEnabled Integer bHorz Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_ISSPLITTERENABLED,  ( bHorz ), 0 ) )
//    End_Function
    Function CM_EnableColumnSel Integer bEnable Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLECOLUMNSEL,  ( bEnable ), 0 ) )
    End_Function
    Function CM_IsColumnSelEnabled Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISCOLUMNSELENABLED, 0, 0 ) )
    End_Function
    Function CM_EnableGlobalProps Integer bEnable Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEGLOBALPROPS,  ( bEnable ), 0 ) )
    End_Function
    Function CM_IsGlobalPropsEnabled Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISGLOBALPROPSENABLED, 0, 0 ) )
    End_Function
    Function CM_SetDlgParent Integer hWndParent Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_SETDLGPARENT,  ( hWndParent ), 0 ) )
    End_Function
    Function CM_EnableSelBounds Integer bEnable Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLESELBOUNDS,  ( bEnable ), 0 ) )
    End_Function
    Function CM_IsSelBoundsEnabled Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISSELBOUNDSENABLED, 0, 0 ) )
    End_Function
//
// Removed - FontStyles is a codemax concept
//
//    Function CM_SetFontStyles String sFontStyles Returns Integer
//    Function CM_GetFontStyles Returns String

//
// Not Used in the Hammer
//
//    Function CM_SetItemData Integer nLine Integer lParam Returns Integer
//    Function CM_GetItemData Integer nLine Returns Integer
//
    Function CM_SetLineStyle Integer nLine Integer dwStyle Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_SETLINESTYLE,  ( nLine ), ( dwStyle ) ) )
    End_Function
    Function CM_GetLineStyle Integer nLine Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_GETLINESTYLE,  ( nLine ), 0 ) )
    End_Function
    Procedure LineChangedMark Integer iLine
      Boolean  bChanged
      Handle   hMarkers
      Handle   hChangedMark
      
      Get EditorMessage SCI_MARKERGET iLine 0 to hMarkers
      If ((hMarkers iAnd SC_MASK_CHANGEDLINEUNSAVED)=0) Begin
        Get CM_IsModified to bChanged
        If (bChanged) Begin
          If (hMarkers iAnd SC_MASK_CHANGEDLINE) Begin
            // There is a saved change line marker. We have to remove it or we won't see our current changed line mark
            Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINESAVED
          End
          Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_CHANGEDLINE to hChangedMark
        End
      End
      Else Begin  // if the line has marker we need to check if the user brought the line back to original state so
                  // that we can remove the line. This code needs to be fast, so we start by comparing length.
        If (Length(CM_GetLine(Self,iLine))=Length(psLineOnEnter(Self))) Begin
          If (CM_GetLine(Self,iLine)=psLineOnEnter(Self)) Begin // again we want speed, so don't copy to local variables
            Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
          End
        End
      End
    End_Procedure
    
    //
    // Enumerates through all of the Changed Line markers in the document and sets them as saved
    // changed line markers
    //
    Procedure MarkChangedLinesAsSaved
      Integer iLine
      Handle  hMark
      
      Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_CHANGEDLINEUNSAVED to iLine
      While (iLine>-1)
        Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_CHANGEDLINE
        Get  EditorMessage SCI_MARKERADD    iLine SC_MARKNUM_CHANGEDLINESAVED   to hMark
        Get  EditorMessage SCI_MARKERNEXT  (iLine+1) SC_MASK_CHANGEDLINEUNSAVED to iLine
      Loop
    End_Procedure

    Function CM_SetBookmark Integer nLine Integer bEnable Returns Integer
      Handle   hMarkers
      Handle   hBookMark
      
      Get EditorMessage SCI_MARKERGET nLine 0 to hMarkers
      If (bEnable) Begin
        If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)=false) Begin
          Get EditorMessage SCI_MARKERADD nLine SC_MARKNUM_BOOKMARK to hBookMark
        End
      End
      Else Begin
        If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
          Send EditorMessage SCI_MARKERDELETE nLine SC_MARKNUM_BOOKMARK
        End
      End
      Function_Return CME_SUCCESS
    End_Function
    Function CM_GetBookmark Integer nLine Returns Integer
      Boolean bHasBookMark
      Handle hMarkers
      
      Move False to bHasBookMark
      Get EditorMessage SCI_MARKERGET nLine 0 to hMarkers
      If (IsFlagIn(SC_MASK_BOOKMARK,hMarkers)) Begin
        Move True To bHasBookMark
      End
      Function_Return bHasBookMark
    End_Function
    
    Procedure BookmarkToggle
      Boolean bHasBookmark
      Integer iLine
      Integer iVoid
      
      Get Current_Line to iLine
      If (iLine>-1) Begin
        Get CM_GetBookmark iLine to bHasBookmark
        Get CM_SetBookmark iLine (not(bHasBookmark)) to iVoid
      End
    End_Procedure
    
    Procedure BookmarkNext
      Integer iLine
      Integer iLineStart
      Get Current_Line to iLineStart
      Get EditorMessage SCI_MARKERNEXT (iLineStart+1) SC_MASK_BOOKMARK to iLine
      If (iLine>-1) Begin
        Send EditorMessage SCI_GOTOLINE iLine
      End
    End_Procedure
    
    Procedure BookmarkPrevious
      Integer iLine
      Integer iLineStart
      Get Current_Line to iLineStart
      Get EditorMessage SCI_MARKERPREVIOUS (iLineStart-1) SC_MASK_BOOKMARK to iLine
      If (iLine>-1) Begin
        Send EditorMessage SCI_GOTOLINE iLine
      End
    End_Procedure
    
    Procedure BookmarkJumpToFirst
      Integer iLine
      Integer iLineStart
      
      Move 0 to iLineStart
      Get EditorMessage SCI_MARKERNEXT iLineStart SC_MASK_BOOKMARK to iLine
      If (iLine>-1) Begin
        Send EditorMessage SCI_GOTOLINE iLine
      End
    End_Procedure
    
    Procedure BookmarkJumpToLast
      Integer iLine
      Integer iLineStart
      
      Get CM_GetLineCount to iLineStart
      Get EditorMessage SCI_MARKERPREVIOUS iLineStart SC_MASK_BOOKMARK to iLine
      If (iLine>-1) Begin
        Send EditorMessage SCI_GOTOLINE iLine
      End
    End_Procedure
    
    Procedure BookmarkClearAll
      Integer iLine
      Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
      While (iLine>-1)
        Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_BOOKMARK
        Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
      Loop
    End_Procedure
    
    Function CM_SetAllBookmarks Integer iCountNotUsed String sData Returns Integer
      Integer   iCount
      Integer   iItem
      Integer   iLine
      Integer   iVoid
      Integer[] Bookmarks

      Move (ConvertAsciiToIntegerArray(sData)) To Bookmarks
      Move (SizeOfArray(Bookmarks)) To iCount
      If (iCount>0) Begin
        For iItem From 0 To (iCount-1)
          Move Bookmarks[iItem] To iLine
          If (iLine>0) Begin
            Get CM_SetBookmark iLine True to iVoid
          End
        Loop
      End
      Function_Return CME_SUCCESS
    End_Function
    
    Function SC_AllBookmarksToIntegerArray Returns Integer[]
      Integer iLine
      Integer[] Bookmarks
      
      Move (ResizeArray(Bookmarks,0)) To Bookmarks
      Get EditorMessage SCI_MARKERNEXT 0 SC_MASK_BOOKMARK to iLine
      While (iLine>-1)
        Move iLine To Bookmarks[SizeOfArray(Bookmarks)]
        Get EditorMessage SCI_MARKERNEXT (iLine+1) SC_MASK_BOOKMARK to iLine
      Loop
      Function_Return Bookmarks
    End_Function
    
    Function CM_GetAllBookmarks Returns String
      String sData
      Integer[] Bookmarks

      Get SC_AllBookmarksToIntegerArray to Bookmarks
      Get ConvertIntegerArrayToAscii Bookmarks to sData
      Function_Return sData
    End_Function
    
    //
    // We're only offering On/Off, the iStart and iMode options are ignored.
    //
    Function CM_SetLineNumbering Integer bEnable Integer iStart Integer iMode Returns Integer
      Integer iMarginWidth
      Integer iDigits
      Integer iLineCount
      String  sMaxLine

      If (bEnable) Begin
        // figure out the width we need based on max line count
        Get CM_GetLineCount to iLineCount
        If (iLineCount>999) Begin
          Move (Length(Trim(iLineCount))) To iDigits
          Move ("_"+repeat("9",iDigits)+Character(0)) To sMaxLine
        End
        Else Begin  // so if it is called at that time then hardwire a fixed width
          Move 3 To iDigits // we don't count the "_" offset, this is our default, we don't get lower as 3
          Move ("_999"+Character(0)) To sMaxLine
        End
        Set piMarginLineNumberDigits to iDigits
        Get EditorMessage SCI_TEXTWIDTH STYLE_LINENUMBER (AddressOf(sMaxLine)) to iMarginWidth
        Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS iMarginWidth
        Send EditorMessage SCI_SETMARGINMASKN  MARGIN_LINE_NUMBERS SC_MASK_MARGIN
      End
      Else Begin
        Send EditorMessage SCI_SETMARGINWIDTHN MARGIN_LINE_NUMBERS 0
      End
      Function_Return CME_SUCCESS
    End_Function
    //
    // Returns 0 if not enabled or CM_DECIMAL if it is
    //
    Function CM_GetLineNumbering Returns Integer
      Integer iRet iWidth

      Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS 0 to iWidth
      If (iWidth>0) Begin
        Move CM_DECIMAL To iRet
      End
      Else Begin
        Move 0 To iRet
      End
      Function_Return iRet
    End_Function
    Function CM_PosFromChar Integer iLine Integer iCol Returns Integer
        Integer     iRet iX iY
        Local_BUFFER      sRect pRect tRect_Size
        Local_CM_POSITION sPos  pPos LINE= iLine COL= iCol
        Move (SendMessage(Window_Handle(Self), CMM_POSFROMCHAR,  ( pPos ), ( pRect ) ) )    to iRet
            // Only if the call succeded.
        If iRet Begin
                // Start Point.
            GetBuff from sRect  At tRECT.Left   to iX
            GetBuff from sRect  At tRECT.top    to iY
            Set piPosStartX                     to iX
            Set piPosStartY                     to iY
                // End Point.
            GetBuff from sRect  At tRECT.Right  to iX
            GetBuff from sRect  At tRECT.bottom to iY
            Set piPosEndX                       to iX
            Set piPosEndY                       to iY
        End

        Function_Return iRet
    End_Function
    Function CM_EnableHideSel Integer bEnable Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLEHIDESEL,  ( bEnable ), 0 ) )
    End_Function
    Function CM_IsHideSelEnabled Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISHIDESELENABLED, 0, 0 ) )
    End_Function
    
    //
    // If a line is already highlighted then this will remove the highlight
    //
    Procedure ResetHighlightedLine
      Handle  hMarker
      Integer iLine
      // Is there already a highlighted line? If so first delete the highlight on that line
      Get phMarkerLineHighLight to hMarker
      If (hMarker<>0) Begin
        Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker 0 to iLine
        If (iLine>-1) Begin
          Send EditorMessage SCI_MARKERDELETE iLine SC_MARKNUM_LINEHIGHLIGHT
        End
        Set phMarkerLineHighLight to 0
      End
    End_Procedure
    
    Function CM_SetHighlightedLine Integer iLine Returns Integer
      Handle  hMarker
      
      If (iLine>0) Begin
        Send ResetHighlightedLine
        Get EditorMessage SCI_MARKERADD iLine SC_MARKNUM_LINEHIGHLIGHT to hMarker
        Set phMarkerLineHighLight to hMarker
      End
      Function_Return CME_SUCCESS
    End_Function
    //
    // An application sends CMM_GETHIGHLIGHTEDLINE to retrieve the index of the currently highlighted line.
    // The highlighted line can be used for marking the currently executing line when used in a debugger
    // application
    // Return Values
    // The zero-based index of the line that is currently highlighted.
    // If no line is highlighted, the return value is -1.
    Function CM_GetHighlightedLine Returns Integer
      Handle  hMarker
      Integer iLine

      Move -1 To iLine
      Get phMarkerLineHighLight to hMarker
      If (hMarker<>0) Begin
        Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker 0 to iLine
      End
      Function_Return iLine
    End_Function
    Function CM_EnableNormalizeCase Integer bEnable Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ENABLENORMALIZECASE,  ( bEnable ), 0 ) )
    End_Function
    Function CM_IsNormalizeCaseEnabled Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_ISNORMALIZECASEENABLED, 0, 0 ) )
    End_Function
    Function CM_SetDivider Integer nLine Integer bEnable Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_SETDIVIDER,  ( nLine ), ( bEnable ) ) )
    End_Function
    Function CM_GetDivider Integer nLine Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_GETDIVIDER,  ( nLine ), 0 ) )
    End_Function

    //
    // An application sends CMM_ENABLEOVERTYPECARET to control the size of the text caret when in overtype mode.
    Function CM_EnableOvertypeCaret Integer bEnable Returns Integer
      Integer iRet
      Integer eCaretStyle
      //
      If (bEnable) Begin
        Move CARETSTYLE_BLOCK To eCaretStyle
      End
      Else Begin
        Move CARETSTYLE_LINE  To eCaretStyle
      End
      Get EditorMessage SCI_SETCARETSTYLE eCaretStyle 0 to iRet
      Function_Return iRet
    End_Function
    Function CM_IsOvertypeCaretEnabled Returns Integer
      Boolean bEnabled
      Integer eCaretStyle
      //
      Move False to bEnabled
      Get EditorMessage SCI_SETCARETSTYLE 0 0 to eCaretStyle  // CMM_ISOVERTYPECARETENABLED
      If (eCaretStyle=CARETSTYLE_BLOCK) Begin
        Move True To bEnabled
      End
      Function_Return bEnabled
    End_Function
    // An application sends CMM_SETFINDTEXT to change the text used in the most current search operation.
    Function CM_SetFindText String szText  Returns Integer
      Move (CString(szText)) To szText
      Set psSearchText to szText
      Function_Return CME_SUCCESS
    End_Function
    Function CM_GetFindText Returns String
      String szText
      Get psSearchText to szText
      Move (szText+Character(0)) to szText // check if it makes sense to make this a zero terminated string
      Function_Return szText
    End_Function
    Function CM_SetReplaceText String szText Returns Integer
        Local_Buffer szText pszText
        Function_Return (SendMessage(Window_Handle(Self), CMM_SETREPLACETEXT, 0, ( pszText ) ) )
    End_Function
    Function CM_GetReplaceText String szText Returns String
        Integer iRet
        Local_Buffer szText pszText CM_MAX_FINDREPL_TEXT
        Move (SendMessage(Window_Handle(Self), CMM_GETREPLACETEXT, 0, ( pszText ) ) )   to iRet
        Function_Return szText
    End_Function

//    Function CM_SetMarginImages Integer nLine  Integer byImages Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_SETMARGINIMAGES,  ( nLine ), ( byImages ) ) )
//    End_Function
//    Function CM_GetMarginImages Integer nLine Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_GETMARGINIMAGES,  ( nLine ), 0 ) )
//    End_Function
//    Function CM_AboutBox Returns Integer
//        Function_Return (SendMessage(Window_Handle(Self), CMM_ABOUTBOX, 0, 0 ) )
//    End_Function
    Function CM_Print Handle hDC Integer dwFlags Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_PRINT,  ( hDC ), ( dwFlags ) ) )
    End_Function
    Function CM_SetCaretPos Integer nLine Integer nCol Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_SETCARETPOS,  ( nLine ), ( nCol ) ) )
    End_Function
    Function CM_ViewColToBufferCol Integer nLine Integer nViewCol  Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_VIEWCOLTOBUFFERCOL,  ( nLine ), ( nViewCol ) ) )
    End_Function
    Function CM_BufferColToViewCol Integer nLine Integer nBufferCol Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_BUFFERCOLTOVIEWCOL,  ( nLine ), ( nBufferCol ) ) )
    End_Function
    Function CM_SetBorderStyle Integer dwStyle Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_SETBORDERSTYLE,  ( dwStyle ), 0 ) )
    End_Function
    Function CM_GetBorderStyle Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_GETBORDERSTYLE, 0, 0 ) )
    End_Function
    // SVN
    Function CM_GetCurrentToken Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_GETCURRENTTOKEN, 0, 0 ) )
    End_Function
    Function CM_UpdateControlPositions Returns Integer
        Function_Return (SendMessage(Window_Handle(Self), CMM_UPDATECONTROLPOSITIONS, 0, 0 ) )
    End_Function
    // SVN

// The whole font handling is completely different in scintilla.
//
//        // Gets the font (Ascii Charactered string of the LOGFONT Structure!)
//    Function CM_GetFont Returns String
//    End_Function
//        // Sets the font
//    Function CM_SetFont String slf Returns Integer
//    End_Function




    //_ADDITION_METHODS_for_an_easier_use.._________________


// ToDo: Out of Scope - Splitting window support in scintilla is not as natural. It can be done
// but for the moment I consider it out of scope. The documentation has this to say about it:
//
// The system is arranged in this way so that you can work with many documents in a single Scintilla
// window and so you can display a single document in multiple windows (for use with splitter windows).
//
//        // Tiling windows...
//    Procedure SplitWindowHorizontal
//        Integer iRet iPos
//        Move (CM_GetSplitterPos(Self,True))         to iPos
//        If iPos Eq 0 Move (Low(GuiSize(Self)))      to iPos
//        Else         Move 0                         to iPos
//        Move (iPos/2)                               to iPos
//        Move (CM_SetSplitterPos(Self,True,iPos))    to iRet
//    End_Procedure
//    Function isSplittedHorizonztal Returns Integer
//        Function_Return (CM_GetSplitterPos(Self,True) Ne 0)
//    End_Function
//    Procedure SplitWindowVertical
//        Integer iRet iPos
//        Move (CM_GetSplitterPos(Self,False))        to iPos
//        If iPos Eq 0 Move (Hi(GuiSize(Self)))       to iPos
//        Else         Move 0                         to iPos
//        Move (iPos/2)                               to iPos
//        Move (CM_SetSplitterPos(Self,False,iPos))   to iRet
//    End_Procedure
//    Function isSplittedVertical Returns Integer
//        Function_Return (CM_GetSplitterPos(Self,False) Ne 0)
//    End_Function
//        // Is a special usage for the splitter window.
//        // gren werden immer angepasst!
//    Procedure DuplicateWindow
//        If not (isSplittedHorizonztal(Self))     Send SplitWindowHorizontal
//        Else If not (isSplittedVertical(Self))   Send SplitWindowVertical
//    End_Procedure
//        // If all 4 sub windows are used. no more is possible.
//    Function isDuplicatePossible Returns Integer
//        If (isSplittedHorizonztal(Self)) If (isSplittedVertical(Self)) Function_Return 0
//        Function_Return 1
//    End_Function
//        // Check if some of the splitters are set.
//    Function isWindowDuplicated Returns Integer
//        If (isSplittedHorizonztal(Self)) Function_Return 1
//        If (isSplittedVertical(Self))    Function_Return 1
//        Function_Return 0
//    End_Function

        // Removes all Splitter windows and
    Procedure CloseWindow
//        If (isSplittedVertical(Self))           Send SplitWindowVertical
//        Else If (isSplittedHorizonztal(Self))   Send SplitWindowHorizontal
    End_Procedure
        // Select All
    Procedure SelectAll
        Send EditorMessage SCI_SELECTALL
    End_Procedure

        // Select this line...
    Procedure SelectLine
        Integer iRet
        Get CM_ExecuteCmd CMD_SELECTLINE 0 to iRet
    End_Procedure
        // Deletes this line...
    Procedure DeleteLine
        Integer iRet
        Get CM_ExecuteCmd CMD_LINEDELETE 0 to iRet
    End_Procedure



    Procedure MoveLineUp
      Send EditorMessage SCI_MOVESELECTEDLINESUP
    End_Procedure

    Procedure MoveLineDown
      Send EditorMessage SCI_MOVESELECTEDLINESDOWN
    End_Procedure

    Procedure DuplicateSelection
      Send EditorMessage SCI_SELECTIONDUPLICATE
    End_Procedure


        // Find...
    Procedure Find
      Integer iFlags
      Integer iCaretPos
      Integer iPos
      Integer iLen
      Integer iLine
      Integer iVoid
      String  sSearchText
      tFindOptions FindOptions

      Send EditorMessage SCI_TARGETWHOLEDOCUMENT
      //
      Get CM_GetCurrentWord to sSearchText // set text to search by what is under the cursor
      
      Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
      Move sSearchText                    To FindOptions.sSearchText
      Move (iFlags iAnd SCFIND_WHOLEWORD) To FindOptions.bWordMatch
      Move (iFlags iAnd SCFIND_MATCHCASE) To FindOptions.bMatchCase
      Move (iFlags iAnd SCFIND_REGEXP)    To FindOptions.bRegExp
      
      Send RequestDetails of oFindDialog (&FindOptions)
      If (FindOptions.bStartFind) Begin
        // First update any changed search flags
        Move 0 to iFlags
        Move (If(FindOptions.bWordMatch,iFlags iOr SCFIND_WHOLEWORD,iFlags)) To iFlags
        Move (If(FindOptions.bMatchCase,iFlags iOr SCFIND_MATCHCASE,iFlags)) To iFlags
        Move (If(FindOptions.bRegExp   ,iFlags iOr SCFIND_REGEXP   ,iFlags)) To iFlags
        Send EditorMessage SCI_SETSEARCHFLAGS iFlags
        
        Move FindOptions.sSearchText To sSearchText
        Set psSearchText to sSearchText
        Move (Length(sSearchText)) To iLen
        If (iLen>0) Begin
          Get EditorMessage SCI_SEARCHINTARGET iLen (AddressOf(sSearchText)) to iPos
          If (iPos > -1) Begin
            If (FindOptions.bMarkAll=false) Begin
              Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
            End
            Else Begin  // Mark All logic
              Move iPos To iCaretPos
              While (iPos>-1)
                // set bookmark for found position
                Get EditorMessage SCI_LINEFROMPOSITION iPos 0 to iLine
                Get CM_SetBookmark iLine True to iVoid
                // find next
                Send EditorMessage SCI_SETCURRENTPOS (iPos+iLen)
                Send EditorMessage SCI_SEARCHANCHOR
                Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
              Loop
              If (iCaretPos>-1) Begin
                // select first found
                Send EditorMessage SCI_SETSEL (iCaretPos+iLen) iCaretPos
              End
            End
          End
        End
      End
      
      //
      // There's an alternative interface that works like this, not seeing why this would be more
      // convenient.
      //
      //Integer iStartPos
      //Integer iEndPos
      //Sci_TextToFind ft
      //
      //Move 0 To iStartPos
      //Move 100 to iEndPos
      //Move iStartPos To ft.chrg.cpMin
      //Move iEndPos   To ft.chrg.cpMax
      //Move (sSearchText+Character(0)) To sSearchText
      //Move (AddressOf(sSearchText)) To ft.pszText
      //Get EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
      //Get EditorMessage SCI_FINDTEXT iFlags (AddressOf(ft)) to iRet
      //If (iRet > -1) Begin
      //  Send none
      //End
    End_Procedure
    
        // Find next
    Procedure FindNext
      Integer iCaretPos
      Integer iFlags
      Integer iLen
      Integer iPos
      Integer iStartPos
      String  sSearchText

      Get psSearchText to sSearchText
      Move (Length(sSearchText)) To iLen
      If (iLen>0) Begin
        Move (sSearchText+character(0)) To sSearchText
        Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iCaretPos
        Move (iCaretPos+iLen) To iStartPos
        Send EditorMessage SCI_SETCURRENTPOS iStartPos
        
        Send EditorMessage SCI_SEARCHANCHOR
        Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
        Get  EditorMessage SCI_SEARCHNEXT iFlags (AddressOf(sSearchText)) to iPos
        If (iPos>-1) Begin
          Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
        End
        Else Begin
          Send EditorMessage SCI_SETCURRENTPOS iCaretPos // not found, don't move cursor (and thus selection)
        End
      End
    End_Procedure
        // Find next
    Procedure FindPrevious
      Integer iCaretPos
      Integer iFlags
      Integer iLen
      Integer iPos
      Integer iStartPos
      String  sSearchText

      Get psSearchText to sSearchText
      Move (Length(sSearchText)) To iLen
      If (iLen>0) Begin
        Move (sSearchText+character(0)) To sSearchText
        //Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iCaretPos
        //Move (iCaretPos+iLen) To iStartPos
        //Send EditorMessage SCI_SETCURRENTPOS iStartPos
        
        Send EditorMessage SCI_SEARCHANCHOR
        Get  EditorMessage SCI_GETSEARCHFLAGS 0 0 to iFlags
        Get  EditorMessage SCI_SEARCHPREV iFlags (AddressOf(sSearchText)) to iPos
        If (iPos>-1) Begin
          Send EditorMessage SCI_SETSEL (iPos+iLen) iPos
        End
      End
    End_Procedure
        // Replace
    Procedure Replace
        Integer iRet
        Get CM_ExecuteCmd CMD_FindReplace 0 to iRet
    End_Procedure
        // Goto line...
    // CMD_GOTOLINE - Moves to a user-specified line.
    // ( int ) The zero-based line number to jump to. If -1, the user is prompted.
    Procedure GotoLine Integer iNrEx
      Integer iLine
      
      If NUM_Arguments Gt 0 Move iNrEx    to iLine
      Else Begin
        Winput "Enter a line:" iLine // eeks winput
      End
      Send EditorMessage SCI_GOTOLINE iLine
    End_Procedure

        // Fills the position of the cursor in pixels into Properties.
        // - getting the curren postion in Line / Col
        // - Retrieving this Position in Pixesl with CM_PosFromChar
        // - Retrieving the absolute position of the Window
        // =  ABSOLUTE CURSOR POSITION in the Edit.
    Procedure FillCurrentPosition
        Integer       iRet iX iY
        Move (CM_GetSel(Self,False))                                        to iRet
        Move (CM_PosFromChar(Self,piSelEndLine(Self),piSelEndCol(Self)))    to iRet
        Set piAbsPosYEnd    to (Hi (Absolute_GuiOriginEx(Self))+piPosEndY(Self))
        Set piAbsPosXEnd    to (Low(Absolute_GuiOriginEx(Self))+piPosEndX(Self))
        Set piAbsPosYStart  to (Hi (Absolute_GuiOriginEx(Self))+piPosStartY(Self))
        Set piAbsPosXStart  to (Low(Absolute_GuiOriginEx(Self))+piPosStartX(Self))
    End_Procedure


        // Delivers the current line.
    Function Current_Item Returns Integer
        Integer iRet
        Get CM_GetSel False                 to iRet
        Function_Return (piSelEndLine(Self))
    End_Function
    //  As I'm a bit thick, let's create a function with that name to make my life easier
    Function Current_Line Returns Integer
        Integer iRet
        Get CM_GetSel False                 to iRet
        Function_Return (piSelEndLine(Self))
    End_Function
        // For VDF closer access.    - number of lines.
    Function Item_Count Returns Integer
        Function_Return (CM_GetLineCount(Self))
    End_Function
        // Value of the line with the given LineNr.
    Function Value Integer iItem Returns String
        If iItem Eq -99  Move (Current_Item(Self)) to iItem
        Function_Return (CM_GetLine(Self,iItem))
    End_Function
        // Sets the value of a given line. (For compatibility with VDF)
    Procedure Set Value Integer iItem String sValue
        Integer iRet iPos iC iCol iLine
        
        Get CM_GetSel False                to iRet
        Get piSelEndCol                    to iCol
        Get piSelEndLine                   to iLine
        If iItem Eq -99  Get Current_Item  to iItem
        Get CM_SelectLine iItem False      to iRet // select line up to EOL character
        Get CM_DeleteSel                   to iRet
        Get CM_InsertText sValue iItem 0   to iRet
        If (iLine <> iItem) Begin
          Get CM_SetSel iLine iCol iLine iCol False  to iRet
        End
    End_Procedure


        // Inserts the Sting into the current Position.
    Procedure Insert String sValue
        Integer iRet
        Get CM_GetSel False to iRet
        Move (CM_InsertText(Self,sValue,piSelEndLine(Self),piSelEndCol(Self))) to iRet
    End_Procedure
        // This is en advanced set value which automatically indents the new
        // value text as far as the text in the line was, or if empty the text of the line before.
    Procedure Set ValueSmart Integer iLine String sVal
        Integer iPos
        String sValOld
        Get value item iLine    to sValOld
        If (Trim(sValOld)) Eq "" If iLine Gt 0 Get Value item (iLine-1) to sValOld
        If (Trim(sValOld)) Ne "" Begin
            For iPos from 1 to (Length(sValOld))

                If (Mid(sValOld,1,iPos)) Ne " " Break
            End

            Move (LTrim(sVal))      to sVal
            Move (Append(Repeat(" ",iPos-1),sVal))  to sVal
        End

        Set value item iLine                        to sVal
    End_Procedure

        // To determine if an object is a cCodeMaxEdit
    Function iscWinMaxEdit Returns Integer
        Function_Return 1
    End_Function

    //____NOTIFICATION_TRAPPING..._____________________________________________
    // all of the followinf procedures and functions are sent by the
    // procedure Notify - which is caused by WM_Notify message.

        // Key capturing...

        // Blocks iKeyCode
    Procedure BlockKey Integer iKeyCode Integer iExtKey Integer iFlag
        If iExtKey Eq CM_KEY_NOEXT Set psBlockedKeysNo    to (Overstrike(String(iFlag),psBlockedKeysNo   (Self),iKeyCode))
        If iExtKey Eq CM_KEY_SHIFT Set psBlockedKeysShift to (Overstrike(String(iFlag),psBlockedKeysShift(Self),iKeyCode))
        If iExtKey Eq CM_KEY_ALT   Set psBlockedKeysAlt   to (Overstrike(String(iFlag),psBlockedKeysAlt  (Self),iKeyCode))
        If iExtKey Eq CM_KEY_CTRL  Set psBlockedKeysCtrl  to (Overstrike(String(iFlag),psBlockedKeysCtrl (Self),iKeyCode))
    End_Procedure
    Function isKeyBlocked Integer iKeyCode Integer iExtKey Returns Integer
        If iExtKey Eq CM_KEY_NOEXT  Function_Return (Mid(psBlockedKeysNo   (Self),1,iKeyCode))
        If iExtKey Eq CM_KEY_SHIFT  Function_Return (Mid(psBlockedKeysShift(Self),1,iKeyCode))
        If iExtKey Eq CM_KEY_ALT    Function_Return (Mid(psBlockedKeysAlt  (Self),1,iKeyCode))
        If iExtKey Eq CM_KEY_CTRL   Function_Return (Mid(psBlockedKeysCtrl (Self),1,iKeyCode))
        Function_Return 0
    End_Function


        // Like Block Key but the Blocked key is reset with onKeyUp.
    Procedure BlockKeyOnce Integer iKeyCode Integer iExtKey Integer iFlag
        If iExtKey Eq CM_KEY_NOEXT Set psBlockedKeysNoOnce    to (Overstrike(String(iFlag),psBlockedKeysNoOnce   (Self),iKeyCode))
        If iExtKey Eq CM_KEY_SHIFT Set psBlockedKeysShiftOnce to (Overstrike(String(iFlag),psBlockedKeysShiftOnce(Self),iKeyCode))
        If iExtKey Eq CM_KEY_ALT   Set psBlockedKeysAltOnce   to (Overstrike(String(iFlag),psBlockedKeysAltOnce  (Self),iKeyCode))
        If iExtKey Eq CM_KEY_CTRL  Set psBlockedKeysCtrlOnce  to (Overstrike(String(iFlag),psBlockedKeysCtrlOnce (Self),iKeyCode))
    End_Procedure
    Function isKeyBlockedOnce Integer iKeyCode Integer iExtKey Returns Integer
        If iExtKey Eq CM_KEY_NOEXT  Function_Return (Mid(psBlockedKeysNoOnce   (Self),1,iKeyCode))
        If iExtKey Eq CM_KEY_SHIFT  Function_Return (Mid(psBlockedKeysShiftOnce(Self),1,iKeyCode))
        If iExtKey Eq CM_KEY_ALT    Function_Return (Mid(psBlockedKeysAltOnce  (Self),1,iKeyCode))
        If iExtKey Eq CM_KEY_CTRL   Function_Return (Mid(psBlockedKeysCtrlOnce (Self),1,iKeyCode))
        Function_Return 0
    End_Function

    Procedure onCMKeyUp Integer iKeyCode Integer iKeyExt
    End_Procedure
    Procedure onCMKeyDown Integer iKeyCode Integer iKeyExt
    End_Procedure
    Procedure onCMKeyPress Integer iKeyCode Integer iKeyExt
    End_Procedure
    
    //
    // We apparently can't use WM_KEYDOWN event, but our higher class depends on that. So from a keypress we now
    // simulate that by only watching the specific keys that are handled. While hackish, this appears to work.
    //
    Procedure SimulateOnKeyDown
      Integer iKeyCode iKeyExt iRet
      Move 0 To iKeyCode
      Move 0 To iKeyExt
      If (GetKeyState(VK_HOME)) Move VK_HOME To iKeyCode
      Else If (GetKeyState(VK_END)) Move VK_END To iKeyCode
      Else If (GetKeyState(VK_RETURN)) Move VK_RETURN To iKeyCode
      If (GetKeyState(VK_CONTROL)) Move CM_KEY_CTRL To iKeyExt
      Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
    End_Procedure
    Procedure DoKeyAction Integer iChar  Pointer lParam
      Integer iKeyCode iKeyExt iRet iBlocked
      Boolean bHasCallTip
//        Local_BUFFER_CPY sKeyData pKeyData CM_KEYDATA pCM_KeyData
//        GetBuff from sKeyData At CM_KeyData.nKeyCode        to iKeyCode
//        GetBuff from sKeyData At CM_KeyData.nKeyModifier    to iKeyExt
//        If (iMode=CMN_KEYUP   ) Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
//        If (iMode=CMN_KEYDOWN ) Get Msg_onCMKeyDown    iKeyCode iKeyExt  to iRet
//        If (iMode=CMN_KEYPRESS) Get Msg_onCMKeyPress   iKeyCode iKeyExt  to iRet

      Send SimulateOnKeyDown
      Get Msg_onCMKeyPress   iChar iKeyExt  to iRet
      
      If (pbCodeTipRequest(Self)=False) Begin
        Get EditorMessage SCI_CALLTIPACTIVE 0 0 to bHasCallTip
        If (bHasCallTip) Begin
          Set pbCodetipRequest to True // code tip is still on the screen, keep calculating to see if it has to be deactivated.
        End
      End

//            // Blocks keystrokes. (only with every ExtKey, dont need this at the moment)
//        If (isKeyBlocked(Self,iKeyCode,iKeyExt)) Begin
//            Procedure_Return 1
//        End
//            // Same as above but the Key blocking is released with KeyUp -> Block Key only once!
//        If (isKeyBlockedOnce(Self,iKeyCode,iKeyExt)) Begin
//            If (iMode=CMN_KEYUP) Send BlockKeyOnce iKeyCode iKeyExt False   // Reset Key.
//            Procedure_Return 1
//        End
      Procedure_Return iRet
    End_Procedure
    
    Procedure onKeyUp Integer iKey
      Boolean bHasCodeList
      Integer iRet iKeyCode iKeyExt
      Move iKey To iKeyCode
      Forward Send onKeyUp iKey
      Get Msg_onCMKeyUp      iKeyCode iKeyExt  to iRet
      If (pbIsCodelistActive(Self)) Begin
        Get EditorMessage SCI_AUTOCACTIVE 0 0 to bHasCodeList
        If (bHasCodeList=False) Begin
          Send DoCodeListCancel 0
        End
      End
    End_Procedure
    

    Procedure Key Integer iKey
      Integer iKeyCode iKeyExt iRet
      If iKey Eq 2166 Send OnBeforePaste // Paste Ctrl+V
      If iKey Eq 2168 Send OnBeforeCut   // Cut Ctrl+X
      Forward Send Key iKey
      If iKey Eq 2166 Send OnAfterPaste  // Paste Ctrl+V
      If iKey Eq 2168 Send OnAfterCut    // Cut Ctrl+X
    End_Procedure

    Procedure onDrawLine Handle hDC Integer iTop Integer iLeft Integer iBottom Integer iRight Integer iColLeft Integer iColRight Integer iLine Pointer pItemData Integer iStyle
        Integer iRet
        Local_Buffer sTxt pTxt 20
        Move "Michis TestText"  to sTxt
        GetAddress of sTxt      to pTxt
        Move (TextOut(hDC,iLeft,iTop,pTxt,15)) to iRet
        Showln "iRet: " iRet

        Procedure_Return
        Showln "hDC "   hDC
        Showln "iTop "  iTop
        Showln "iLeft " iLeft
        Showln "iBottom " iBottom
        Showln "iRight " iRight
        Showln "iColLeft " iColLeft
        Showln "iColRight " iColRight
        Showln "iLine " iLine
        Showln "pItemData " pItemData
        Showln "iStyle " iStyle
    End_Procedure
    Procedure DoDrawline Pointer pCM_DrawLineData
//        Local_BUFFER_CPY sDrawData pDrawData CM_DRAWLINEDATA pCM_DrawLineData
        Integer iTop iBottom iLeft iRight iColLeft iColRight iLine iStyle
        Pointer pItemData
//        Handle  hDC
//        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.top    to iTop
//        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.bottom to iBottom
//        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Left   to iLeft
//        GetBuff from sDrawData At CM_DRAWLINEDATA.rcLine.Right  to iRight
//
//        GetBuff from sDrawData At CM_DRAWLINEDATA.hDC           to hDC
//        GetBuff from sDrawData At CM_DRAWLINEDATA.nLeftCol      to iColLeft
//        GetBuff from sDrawData At CM_DRAWLINEDATA.nRightCol     to iColRight
//
//        GetBuff from sDrawData At CM_DRAWLINEDATA.nLine         to iLine
//        GetBuff from sDrawData At CM_DRAWLINEDATA.lParam        to pItemData
//
//        GetBuff from sDrawData At CM_DRAWLINEDATA.dwStyle       to iStyle
//        Send onDrawLine hDC iTop iLeft iBottom iRight iColLeft iColRight iLine pItemData iStyle
    End_Procedure


        // Trap buffer modification...
    Procedure DoModifiedChange
        Send onModifiedChange (CM_IsModified(Self))
    End_Procedure
    Procedure onModifiedChange Integer bModified
    End_Procedure
        // Property change notification...
    Procedure onPropsChange
    End_Procedure
    
    Function IsBraceCharacter Integer iChar Returns Boolean
      Boolean bIsBraceChar
      String  sChar
      
      Move False to bIsBraceChar
      Move (Character(iChar)) To sChar
      If (sChar="(" or sChar="[" or sChar="<" or sChar=">" or sChar="]" or sChar=")") Begin
        Move True to bIsBraceChar
      End
      Function_Return bIsBraceChar
    End_Function

        // Selection has changed. (Position is included!)
    Procedure onSelChange
    End_Procedure
    
    //
    // Ordinary method to swap the contents of 2 integer variables
    //
    Procedure SwapIntegerVariables Integer ByRef iLine1 Integer ByRef iLine2
      Integer iTemp
      Move iLine1 To iTemp
      Move iLine2 To iLine1
      Move iTemp  To iLine2
    End_Procedure
    
    Function IsValidBraceMatch Integer iPos Integer iMatchPos Returns Boolean
      Boolean bIsValid
      Integer iLoop
      Integer iLine
      Integer iMatchLine
      String  sLine
      
      Move False to bIsValid
      If (iMatchPos<>INVALID_POSITION) Begin
        // check if the matched brace is on the same line
        Get EditorMessage SCI_LINEFROMPOSITION iPos      0 to iLine
        Get EditorMessage SCI_LINEFROMPOSITION iMatchPos 0 to iMatchLine
        If (iLine=iMatchLine) Begin
          Move True To bIsValid
        End
        Else Begin
          // not on the same line, so can only be valid if the line ends with a ;
          If (iLine>iMatchLine) Send SwapIntegerVariables (&iLine) (&iMatchLine)
          Move True To bIsValid
          For iLoop from iLine to (iMatchLine-1)
            Get Value iLoop to sLine
            Move (Rtrim(sLine)) To sLine
            If (Right(sLine,1)<>";") Begin
              Move False To bIsValid
              Move iMatchLine To iLoop // stop
            End
          Loop
        End
      End
      Function_Return bIsValid
    End_Function
    
    Procedure ShowMatchingBraces Integer iPos
      Integer iChar
      Integer imaxReStyle
      Integer iMatchPos
      Boolean bMatchPreviousChar
      Boolean bIsMatch
      Boolean bIsBraceChar
      // get the char
      Move True to bMatchPreviousChar // this seems to make more sense as you see match while you type
      Move False to bIsBraceChar
      If (iPos>0 and bMatchPreviousChar) Begin
        Move (iPos-1) To iPos
      End
      Get EditorMessage SCI_GETCHARAT iPos 0 to iChar
      Get IsBraceCharacter iChar to bIsBraceChar
      If (bIsBraceChar) Begin
        Move 0 to imaxReStyle
        Get EditorMessage SCI_BRACEMATCH iPos imaxReStyle to iMatchPos
        Get IsValidBraceMatch iPos iMatchPos to bIsMatch
        If (bIsMatch) Begin
          Send EditorMessage SCI_BRACEHIGHLIGHT iPos iMatchPos
        End
        Else Begin
          Send EditorMessage SCI_BRACEBADLIGHT iPos
        End
        Set pbBraceHighLightState to True
      End
      Else Begin
        If (pbBraceHighLightState(Self)) Begin
          // remove the highlight
          Send EditorMessage SCI_BRACEHIGHLIGHT -1 -1
          Set pbBraceHighLightState to False
        End
      End
    End_Procedure
    
    //
    // Navigation, the cursor changed lines event
    //
    Procedure onLineChanged Integer iLineOld Integer iLineNew
    End_Procedure
    
    //
    // Navigation, called when the cursor changes lines
    //
    Procedure LineChanged Integer iLineOld Integer iLineNew
      Handle  hMarker
      Integer iLine
      
      Get phMarkerLineHighLight to hMarker
      If (hMarker<>0) Begin
        Get EditorMessage SCI_MARKERLINEFROMHANDLE hMarker 0 to iLine
        If (iLine<>iLineNew) Begin
          Send ResetHighlightedLine
        End
      End
      If (iLineOld<>iLineNew) Begin
        Set psLineOnEnter to (CM_GetLine(Self,iLineNew))
      End
      Send onLineChanged iLineOld iLineNew
    End_Procedure
    
    Procedure onNavigate Integer iPos
      Integer iLineOld
      Integer iLineNew
      Boolean bShowMatchingBraces
      
      Get piSelEndLine to iLineOld
      Get pbShowMatchingBraces to bShowMatchingBraces
      If (bShowMatchingBraces) Begin
        Send ShowMatchingBraces iPos
      End
      Send onSelChange
      Get piSelEndLine to iLineNew
      If (iLineOld<>iLineNew) Begin
        Send LineChanged iLineOld iLineNew
      End
    End_Procedure
    
    //
    // Is called when the user has inserted or deleted text, so effectively when our document
    // line count changes.
    //
    Procedure LineCountChanged
      Integer iOldDigits
      Integer iNewDigits
      Integer iMinDigits
      Integer iLineCount
      Integer iVoid
      Integer iWidth

      Get EditorMessage SCI_GETMARGINWIDTHN MARGIN_LINE_NUMBERS 0 to iWidth
      If (iWidth<>0) Begin  // we have a line number margin, how many lines?
        Get Item_Count to iLineCount // the margin width is determined based on number of digits
        Move 3 To iMinDigits         // we set a minimum digits width of 3 digits
        Get piMarginLineNumberDigits    To iOldDigits
        Move (Length(Trim(iLineCount))) To iNewDigits
        If (inewDigits<iMinDigits) Move iMinDigits to iNewDigits
        If (iOldDigits<>iNewDigits) Begin
          Get CM_SetLineNumbering True 0 0 to iVoid  // by enabling line numbering we tell the logic to update the width
        End
      End
    End_Procedure
    
        // Insert mode / Overwrite mode
    Procedure onOvertypeChange
    End_Procedure
        // Registered Commands handling
    Procedure DoRegisteredCmd Pointer pCM_RegisteredCmdData
//        Local_BUFFER_CPY sData pData CM_REGISTEREDCMDDATA pCM_RegisteredCmdData
        Integer iCmd
//        GetBuff from sData At CM_REGISTEREDCMDDATA.wCmd to iCmd
//        Send onRegisteredCmd iCmd
    End_Procedure
        // Need to be overwritten to implement the code for the command (Procedure calls)
    Procedure onRegisteredCmd Integer iCmd
    End_Procedure
    
    Procedure RegisterKeyBindingToClear String sKey
      String[] KeyBindings
      
      Get psClearKeyBindings to KeyBindings
      Move sKey To KeyBindings[SizeOfArray(KeyBindings)]
      Set psClearKeyBindings to KeyBindings
    End_Procedure
    
    Procedure RemoveSCIKeyBinding String sKey
      Integer iModKeys
      Integer iKey
      String  sKeyDefine
      //
      Move 0 To iModKeys
      Move sKey To sKeyDefine
      Move (Replaces(" ",sKey,"")) To sKey // in Sci we can have "Ctrl + F" so get rid of the space characters
      Move (Uppercase(sKey)) To sKey
      If (pos("CTRL+",sKey)<>0) Begin
        Move (iModKeys iOr SCMOD_CTRL)   To iModKeys
        Move (Replace("CTRL+",sKey,""))  To sKey
      End
      If (Pos("ALT+",sKey)<>0) Begin
        Move (iModKeys iOr SCMOD_ALT)    To iModKeys
        Move (Replace("ALT+",sKey,""))   To sKey
      End
      If (Pos("SHIFT+",sKey)<>0) Begin
        Move (iModKeys iOr SCMOD_SHIFT)  To iModKeys
        Move (Replace("SHIFT+",sKey,"")) To sKey
      End
      If (Length(sKey)=1) Begin
        Move (Ascii(sKey)) To iKey
      End
      Else Begin
        Case Begin  // It isn't clear to me if SCI uses VK_xxx keys, but it seems so
          Case (sKey="F1")
            Move VK_F1 To iKey
            Case break
          Case (sKey="F2")
            Move VK_F2 To iKey
            Case break
          Case (sKey="F3")
            Move VK_F3 To iKey
            Case break
          Case (sKey="F4")
            Move VK_F4 To iKey
            Case break
          Case (sKey="F5")
            Move VK_F5 To iKey
            Case break
          Case (sKey="F6")
            Move VK_F6 To iKey
            Case break
          Case (sKey="F7")
            Move VK_F7 To iKey
            Case break
          Case (sKey="F8")
            Move VK_F8 To iKey
            Case break
          Case (sKey="F9")
            Move VK_F9 To iKey
            Case break
          Case (sKey="F10")
            Move VK_F10 To iKey
            Case break
          Case (sKey="F11")
            Move VK_F11 To iKey
            Case break
          Case (sKey="F12")
            Move VK_F12 To iKey
            Case break
          Case (sKey="ENTER")
            Move SCK_RETURN To iKey
          Case (sKey="DOWN")
            Move SCK_DOWN To iKey
          Case (sKey="UP")
            Move SCK_UP To iKey
        Case End
      End
      If (iKey<>0) Begin
        Send EditorMessage SCI_CLEARCMDKEY ((65536*(iModKeys))+iKey)
      End
      Else Begin
        Send none
        // might be handy for debugging, or just annoying :) so use send none instead
        //Send Info_Box ("Scintilla unknown key to clear "+sKeyDefine)
      End
    End_Procedure
    
    Procedure ClearRegisteredKeyBindings
      Integer iKey
      Integer iCount
      String[] KeyBindings
      
      Get psClearKeyBindings to KeyBindings
      Move (SizeOfArray(KeyBindings)) To iCount
      If (iCount>0) Begin
        For iKey from 0 to (iCount-1)
          Send RemoveSCIKeyBinding KeyBindings[iKey]
        Loop
        //Send EditorMessage SCI_CLEARALLCMDKEYS
      End
      // each scintilla window can run this 1 time only
      Move (ResizeArray(KeyBindings,0)) To KeyBindings
      Set psClearKeyBindings to KeyBindings
    End_Procedure
        // Is sent when the end of the files was reached.
    Procedure onFindWrapping
    End_Procedure
    Procedure DoFindWrapping
        Integer iRet
        Indicate Found False     // Sets the std. Found Indicator.
        Get Msg_onFindWrapping    to iRet
        If iRet Procedure_Return iRet
        If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrap Begin
            Procedure_Return 1
        End
        If (piFindWrapMode(Self)) Eq FindWrapMode_NoWrapMsg Begin
            If (Window_Handle(Self)) Eq (GetFocus()) Send Info_Box "Not Found!"                  // Not so pretty but prevents object from loosing the focus.
            Procedure_Return 1
        End
        If (piFindWrapMode(Self)) Eq FindWrapMode_WrapSilent Procedure_Return 0
        If (piFindWrapMode(Self)) Eq FindWrapMode_WrapAsk Begin
            Get YesNo_Box "End of file reached restart from the beginning?"     to iRet
            If iRet Eq MBR_Yes Procedure_Return 0
            Else               Procedure_Return 1
        End
    End_Procedure

    // Should be overwrited, returns True if Ok or false if failed
    Function CM_InitCodeList Handle hCodeList Returns Integer
        Function_Return 0
    End_Function
    // This procedure should Set codetip text etc...
    Procedure OnCodeTip
    End_Procedure
    Procedure OnCodeTipInitialize
    End_Procedure
    Procedure OnCodeTipUpdate
    End_Procedure
    Procedure OnCodeTipCancel
    End_Procedure
    Function DoCodeListInit Handle hCodeList Returns Integer
        Function_Return 0
    End_Function
    Procedure CM_CodeListItemSelected String sItem Integer iRefVal
    End_Procedure
    
    Function LoadAutoCompleteImage String sBitmap Integer iType Returns Boolean
      Boolean bOK
      Pointer pImage
      UInteger uSize uWidth uHeight 
      UInteger iErr iVoid
      String  sFileName
      String  sError
      
      Move False to bOK
      Move (sBitmap+Character(0)) To sFileName
      Move 0 To uWidth
      Move 0 To uHeight
      Move 0 To uSize
      Move 0 To pImage
      //Move (SciLoadPngAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight),AddressOf(uSize))) To iErr
      Move (SciLoadImageAsRGBA(AddressOf(sFileName),AddressOf(pImage),AddressOf(uWidth),AddressOf(uHeight))) To iErr
      If (iErr=0) Begin
        //Send Info_Box ("Image Width= "+Trim(uWidth)+" Height= "+Trim(uHeight)+" Size = "+Trim(uSize))
        Send EditorMessage SCI_RGBAIMAGESETWIDTH  uWidth
        Send EditorMessage SCI_RGBAIMAGESETHEIGHT uHeight
        Send EditorMessage SCI_REGISTERRGBAIMAGE  iType pImage
        Move (SciFreeRGBAImage(pImage)) To iVoid
        Move True to bOK
      End
      Else Begin
        Get SciLoadImageErrorText iErr to sError
        Send Info_Box (sError+"\nImage: "+sFileName+"\nNote that only uncompressed 24 bits and 32 bits bmp files are supported.") "Error loading CodeList image"
      End
      
      Function_Return bOK
    End_Function
    
    //
    // Scintilla calls the codelist feature autocomplete.
    // When this is called the array phoCodelistHandler has our list that we want to display
    // sWord is the word to select on
    //
    Procedure ShowAutoComplete String sWord
      Boolean bAutoCompleteActive
      Boolean bHasBmp
      Handle  hoArray
      Integer iChar
      Integer iItem
      Integer iCount
      String  sItem
      String  sBitmap
      String  sList
      String  sSelect
      
      //Get EditorMessage SCI_AUTOCACTIVE 0 0 to bAutoCompleteActive  // doesn't work already gone before recursion
      Get pbIsCodelistActive to bAutoCompleteActive
      If (bAutoCompleteActive=False) Begin
        Send EditorMessage SCI_AUTOCSETIGNORECASE True
        Send EditorMessage SCI_AUTOCSETCASEINSENSITIVEBEHAVIOUR SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE
        //Send EditorMessage SCI_AUTOCSETORDER SC_ORDER_PERFORMSORT // we sort on our end as we need to know the item number
        Send EditorMessage SCI_AUTOCSETSEPARATOR (Ascii("|"))
        Send EditorMessage SCI_CLEARREGISTEREDIMAGES
        Move "" To sList
        Get phoCodelistHandler to hoArray
        Send SortAscending of hoArray  // Our list MUST be ascending order or the autocomplete won't work!
        Get Codelist_Item_Count of hoArray to iCount
        For iItem from 0 To (iCount-1)
          Get Codelist_value  of hoArray Item iItem To sItem
          Get Codelist_bitmap of hoArray item iItem to sBitmap
          Move False to bHasBmp
          If (sBitmap<>"") Begin  // bitmap exists and found
            Get LoadAutoCompleteImage sBitmap (iItem+1) to bHasBmp 
          End
          If (bHasBmp) Begin
            Move (sList+sItem+"?"+Trim(iItem+1)+"|") To sList  
          End
          Else Move (sList+sItem+"|") To sList  // separator character is pipe symbol
        Loop
        Move (Length(sWord)) To iChar
        Send EditorMessage SCI_AUTOCSHOW iChar (AddressOf(sList))
        Move (String(sWord)+Character(0)) To sSelect
        Send EditorMessage SCI_AUTOCSELECT 0 (AddressOf(sSelect))
      End
    End_Procedure

    //
    // Takes care of the argument highlighting
    //
    Procedure GetCodetipProperties Pointer pCM_CodeTipData
        Integer iRet
        Integer iType
        Integer iPos
        Integer iArg
        Integer iSelectedArg
        Integer iHighlightStart
        Integer iHighlightEnd
        String  sTip
        
        Move 0 To iHighLightStart
        Move 0 To iHighLightEnd
        Get psCodeTipCurrent to sTip
        Move (Pos(Character(10),sTip)) To iPos
        If (iPos>0) Move (Left(sTip,iPos-1)) To sTip // first line has the expression/function/method, next line is the description
        Get piCodeTipArgument to iSelectedArg
        Get piCodeTipType to iType
        If (iType=C_TIPTYPE_EXPRESSION) Begin
          Move (Pos("(",sTip)) To iPos // start first argument
          Move 0 To iArg
          While (iPos>0)
            
            If (iSelectedArg=iArg) Move (iPos+1) To iHighLightStart
            Move (Pos(",",sTip,iPos+1)) To iPos
            If (iHighLightStart<>0) Begin
              If (iPos=0) Move (Pos(")",sTip,iHighlightStart)) To iPos
              If (iPos<>0) Begin
                Move (iPos-1) To iHighLightEnd
                Move 0 To iPos
              End
            End
            Increment iArg
          Loop
          If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
            Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
          End
          Else Begin
            Send EditorMessage SCI_CALLTIPSETHLT 0 0
          End
        End
        Else If (iType=C_TIPTYPE_FUNCTION) Begin
          // function foo string sBar Integer iVoid Returns integer
          Move (Pos(" ",sTip)) To iPos // start function name
          Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above function
          Move 0 To iArg
          While (iPos>0)
            
            If (iSelectedArg=iArg) Move iPos To iHighLightStart
            Move (Pos(" ",sTip,iPos+1)) To iPos
            Move (Pos(" ",sTip,iPos+1)) To iPos
            If (iHighLightStart<>0) Begin
              If (iPos=0) Move (Length(sTip)+1) To iPos
              If (iPos<>0) Begin
                Move (iPos-1) To iHighLightEnd
                Move 0 To iPos
              End
            End
            Increment iArg
          Loop
          If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
            Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
          End
          Else Begin
            Send EditorMessage SCI_CALLTIPSETHLT 0 0
          End
        End
        Else If (iType=C_TIPTYPE_PROCEDURE) Begin
          // procedure foo string sBar Integer iVoid Returns integer
          // procedure foo string sBar Integer iVoid
          // procedure set foo string sBar Integer iVoid
          Move (Pos(" ",sTip)) To iPos // start procedure name or set
          If (Mid(lowercase(sTip),3,iPos+1)="set") Begin
            Move (Pos(" ",sTip,iPos+1)) To iPos // at start procedure name
          End
          Move (Pos(" ",sTip,iPos+1)) To iPos // at "string" from above method
          Move 0 To iArg
          While (iPos>0)
            
            If (iSelectedArg=iArg) Move iPos To iHighLightStart
            Move (Pos(" ",sTip,iPos+1)) To iPos
            Move (Pos(" ",sTip,iPos+1)) To iPos
            If (iHighLightStart<>0) Begin
              If (iPos=0) Move (Length(sTip)+1) To iPos
              If (iPos<>0) Begin
                Move (iPos-1) To iHighLightEnd
                Move 0 To iPos
              End
            End
            Increment iArg
          Loop
          If (iHighlightStart<>0 and iHighLightEnd<>0) Begin
            Send EditorMessage SCI_CALLTIPSETHLT iHighLightStart iHighlightEnd
          End
          Else Begin
            Send EditorMessage SCI_CALLTIPSETHLT 0 0
          End
        End
    End_Procedure

    // Get the Codetipdata Structure and set the according properties.
    // 12.2.2003 BP
    Procedure SetCodetipProperties Pointer pCM_CodeTipData
        Integer iRet
        // not doing anythign anymore
    End_Procedure

    // Codetip requested: return the type of Codetip to display or CM_TIPSTYLE_NONE to not displaying a codetip
    // 12.2.2003 BP
    Procedure DoCodeTip             Integer lParam
      Boolean bCallTipActive
      Integer iOk
      Integer iPos
      Integer iChar
      String  sTip
      
      Get EditorMessage SCI_CALLTIPACTIVE 0 0 to bCallTipActive // calltip active on screen
      If (bCallTipActive) Begin
        If (piCodeTipType(Self)=C_TIPTYPE_EXPRESSION) Begin
          Get EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
          Get EditorMessage SCI_GETCHARAT (iPos-1) 0 to iChar
          If (iChar=Ascii(")")) Begin
            Send DoCodeTipCancel 0
          End
          Else Send DoCodeTipUpdate 0
        End
        Else Send DoCodeTipUpdate 0
      End
      Else Begin
        // ToDo:
        // how about I initialize it here to make sure?
        //
        Get msg_OnCodeTip to iOk
        //If (iOk) Procedure_Return (piCodeTipStyle(Self))
        //Procedure_Return CM_TIPSTYLE_NONE
        If (iOk) Begin
          Get psCodeTipCurrent to sTip
          Move (Replaces("//",sTip,"\n")) To sTip // display description on a new line
          Move (Replaces("\n",sTip,Character(10))) To sTip
          Get  EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
          Send EditorMessage SCI_CALLTIPSHOW iPos (AddressOf(sTip))
        End
      End
    End_Procedure
    // Codetip is to be displayed: return TRUE if changes applied to the codetip structure or FALSE if not
    // 12.2.2003 BP
    Procedure DoCodeTipInitialize   Integer lParam
        Integer iOk
        Send SetCodetipProperties lParam
        Get msg_OnCodeTipInitialize to iOk
        If (iOk) Begin
            Send GetCodetipProperties lParam
            Procedure_Return 1
        End
        Procedure_Return 0
    End_Procedure
    // Codetip is to be removed: return FALSE if the codetip should be removed or TRUE if to codetip should remain visible
    // 12.2.2003 BP
    Procedure DoCodeTipCancel       Integer lParam
      Integer iOk
      //
      Send EditorMessage SCI_CALLTIPCANCEL
      // Reset CodeTip Properties
      Set piCodeTipHandle            to  0
      Set piCodeTipHighlightedStart  to -1
      Set piCodeTipHighlightedEnd    to -1
      Set piCodeTipArgument          to -1
      Set piCodeTipFuncCount         to  0
      Set piCodeTipCurrFunc          to  0
      //
      Set psCodeTipCurrent           to ""
      Set piCodeTipCurrLine          to -1
      Get msg_OnCodeTipCancel to iOk
      Procedure_Return iOk
    End_Procedure
    // Codetip is to be updated (position, values...): return TRUE if changes applied to the codetip structure or FALSE if not
    // 12.2.2003 BP
    Procedure DoCodeTipUpdate       Integer lParam
      Integer iOk
      Send SetCodetipProperties lParam
      Get msg_OnCodeTipUpdate to iOk
      If (iOk) Begin
          Send GetCodetipProperties lParam
          Procedure_Return 1
      End
      Procedure_Return 0
    End_Procedure
    
    Procedure Request_Cancel
      Boolean bCodeListActive
      
      Get pbIsCodelistActive to bCodeListActive
      If (bCodeListActive) Begin
        Send EditorMessage SCI_AUTOCCANCEL
        Send DoCodeListCancel 0
      End
    End_Procedure

    // BP CodeList Support
    // DoCodeList: Notification that a Codelist is requested
    // Connect the VDF-Codelist Object to the delivered codelist handle, adjust some features
    // and fill in the requested lines.
    Procedure DoCodeList            Integer lParam
      Integer iRet
      Handle hCodeList

      If (not(phoCodeListHandler(Self))) Procedure_Return False

      Move 0 To hCodeList
      Get DoCodeListInit hCodeList to iRet
      If (iRet) Procedure_Return True
      Procedure_Return False
    End_Procedure

    Procedure OnCodelistCancel
    End_Procedure

    // DoCodelistCancel
    // Notification that the listview was canceled without selecting a value
    Procedure DoCodeListCancel      Integer lParam
      Send OnCodelistCancel
      Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
      Set pbIsCodelistActive To False
      Procedure_Return False // return FALSE to remove the listview from screen
    End_Procedure


    // DoCodelistSelMade
    // Notification that a item was selected within the listview
    // Originally called DoCodelistSelMade, renamed as we have different parameters
    Procedure DoAutoCompleteSelection Address aText
      String sCodelistdata sItem
      String  sText
      Pointer pCodelistdata
      Integer iRet iItem iRefVal iRetVal
      Handle hCodelist

      If (not(phoCodeListHandler(Self))) Procedure_Return False
      
      If (aText<>0) Move aText To sText
      Else Move "" To sText
      If (sText<>"") Begin
        Send EditorMessage SCI_AUTOCCANCEL // we handle insertion of the value by ourself
        Move sText to sItem // we still need the iRefVal as it is a helper variable for finding the relevant parts
        Get Codelist_find_item of (phoCodeListHandler(Self)) sText To iItem
        If iItem Ne -1 Begin
          Get Codelist_value of (phoCodelistHandler(Self)) iItem to sItem  // get the item text of the selected item
          Get piRefValue of (phoCodelistHandler(Self)) to iRefVal
          Get msg_CM_CodeListItemSelected sItem iRefVal to iRetVal
        End
      End
      Send Codelist_disconnect to (phoCodelistHandler(Self)) // disconnect the vdf-object
    End_Procedure
    
    // To be filled in at higher class
    Function TranslateCharacter Integer iKey Returns Integer
    End_Function
    
    // To be filled in at higher class
    Function ShouldTranslateCharacter Integer iKeyCode Returns Boolean
    End_Function  

    
    Procedure doCharacterTranslation Address aText Integer iLength
      Boolean bTranslateChar
      Integer iKey
      Integer iNewKey
      String  sText
      String  sNewChar
      
      If (pbFileLoading(Self)=false) Begin // don't translate text when loading from disk
        If (aText<>0) Move aText To sText
        Else Move "" To sText
        If (sText<>"" and iLength=1) Begin
          Move (Ascii(sText)) To iKey
          Get ShouldTranslateCharacter iKey to bTranslateChar
          If (bTranslateChar) Begin
            Get TranslateCharacter iKey to iNewKey
            If (iNewKey<>0) Begin
              Move (Character(iNewKey)) To sNewChar
              Send EditorMessage SCI_CHANGEINSERTION 1 (AddressOf(sNewChar))
            End  
          End
        End
      End
    End_Procedure

    // BP

    Procedure onBeforeFloatingMenu
    End_Procedure
    Procedure onAfterFloatingMenu
    End_Procedure

        // Is sent when a WM_Notify with NM_RCLICK occusrs.
        // I use it to implement the Popup of the floating_poup_menu.
    Procedure DoRightClick Integer lParam
        If (Floating_Menu_Object(Self)) Ne 0 Begin
            Set phoServedObject of (Floating_menu_object(Self)) to Self
            Send OnBeforeFloatingMenu
            Send Popup  to (Floating_Menu_Object(Self))
            Send OnAfterFloatingMenu
            Procedure_Return 1
        End
    End_Procedure

    Procedure onSetFocus
    End_Procedure
    Procedure onKillFocus
    End_Procedure
    Procedure onChange
    End_Procedure


    Procedure OnCharAdded
    End_Procedure
    
    Procedure OnStyleNeeded
    End_Procedure
    
    Procedure OnSavePointReached
    End_Procedure
    
    Procedure OnSavePointLeft
    End_Procedure
    
    Procedure OnDoubleClick
      //Send Info_Box "double click"
    End_Procedure
    
    Procedure OnModified
    End_Procedure
    
    Procedure OnMarginClick Integer iMargin Integer iLine
      Case Begin
        Case (iMargin=MARGIN_CODE_FOLDING)
          Send EditorMessage SCI_TOGGLEFOLD iLine
          Case Break
      Case End
    End_Procedure
    
    Procedure OnMarginRightClick
    End_Procedure


    Procedure Notify Integer wParam Integer lParam
        Integer iRet
        Integer iCode
        Integer iLine
        Integer iPos
        tSCNotification SCNotify
        
        Move 0 To SCNotify.line // variable exists and is initialized
        Move (CopyMemory(AddressOf(SCNotify),lParam,SizeOfType(tSCNotification))) to iRet
        Move SCNotify.Nmhdr.uCode  to iCode

        // Trap Events...________________________
        Move 0 to iRet
        
        Case Begin
            Case (iCode=SCN_STYLENEEDED)
              Send OnStyleNeeded
              Case Break
            Case (iCode=SCN_CHARADDED)
              Send OnCharAdded
              Get Msg_onChange                    to iRet
              Get Msg_DoKeyAction SCNotify.ch lParam    to iRet
              Case Break
            Case (iCode=SCN_SAVEPOINTREACHED   )
              Send OnSavePointReached
              Get Msg_DoModifiedChange            to iRet
              Case Break
            Case (iCode=SCN_SAVEPOINTLEFT      )
              Send OnSavePointLeft
              Get Msg_DoModifiedChange            to iRet
              Case Break
            Case (iCode=SCN_MODIFYATTEMPTRO    )
              //Send Info_Box "Document cannot be changed, it is readonly"
              Case Break
            Case (iCode=SCN_KEY                )  //  Used on GTK+ because of some problems with keyboard focus and is not sent by the Windows version.
              //Get Msg_DoKeyAction iCode lParam    to iRet
              Send none
              Case Break
            Case (iCode=SCN_DOUBLECLICK        )
              Send OnDoubleClick
              Case Break
            Case (iCode=SCN_UPDATEUI           )
              If (SCNotify.updated iAnd (SC_UPDATE_SELECTION+SC_UPDATE_V_SCROLL)) Begin
                Get EditorMessage SCI_GETCURRENTPOS 0 0 to iPos
                Send onNavigate iPos
              End
              Case Break
            Case (iCode=SCN_MODIFIED           )
              Send OnModified
              If (SCNotify.modificationType iAnd (SC_MOD_INSERTTEXT+SC_MOD_DELETETEXT)) Begin
                Send LineCountChanged
                If ((SCNotify.modificationType iAnd SC_STARTACTION)=0) Begin
                  If (SCNotify.modificationType iAnd (SC_PERFORMED_REDO+SC_PERFORMED_UNDO+SC_PERFORMED_USER)) Begin
                    Get Msg_onChange                    to iRet
                  End
                End
                
              End
              If (SCNotify.modificationType = SC_MOD_INSERTCHECK) Begin
                Send doCharacterTranslation SCNotify.Text SCNotify.length
              End
              Case Break
            Case (iCode=SCN_MACRORECORD        )
              Case Break
            Case (iCode=SCN_MARGINCLICK        )
              Get EditorMessage SCI_LINEFROMPOSITION SCNotify.position 0 to iLine
              Send OnMarginClick SCNotify.margin iLine
              Case Break
            Case (iCode=SCN_NEEDSHOWN          )
              Case Break
            Case (iCode=SCN_PAINTED            )
              Case Break
            Case (iCode=SCN_USERLISTSELECTION  )
              Case Break
            Case (iCode=SCN_URIDROPPED         )
              Case Break
            Case (iCode=SCN_DWELLSTART         )
              Case Break
            Case (iCode=SCN_DWELLEND           )
              Case Break
            Case (iCode=SCN_ZOOM               )
              Case Break
            Case (iCode=SCN_HOTSPOTCLICK       )
              Case Break
            Case (iCode=SCN_HOTSPOTDOUBLECLICK )
              Case Break
            Case (iCode=SCN_CALLTIPCLICK       )
              Case Break
            Case (iCode=SCN_AUTOCSELECTION     )
              Get Msg_DoAutoCompleteSelection SCNotify.Text to iRet
              Case Break
            Case (iCode=SCN_INDICATORCLICK     )
              Case Break
            Case (iCode=SCN_INDICATORRELEASE   )
              Case Break
            Case (iCode=SCN_AUTOCCANCELLED     )
              Send DoCodeListCancel 0
              Case Break
            Case (iCode=SCN_AUTOCCHARDELETED   )
              Send none
              Case Break
            Case (iCode=SCN_HOTSPOTRELEASECLICK)
              Case Break
            Case (iCode=SCN_FOCUSIN            )
              Get Msg_onSetFocus                  to iRet
              Case Break
            Case (iCode=SCN_FOCUSOUT           )
              Get Msg_onKillFocus                 to iRet
              Case Break
            Case (iCode=SCN_AUTOCCOMPLETED     )
              // Only called when using built-in selection method, we do it manually
              Case Break
            Case (iCode=SCN_MARGINRIGHTCLICK   )
              Send OnMarginRightClick
              Case Break
            Case (iCode=SCEN_CHANGE            )
              Send none
              Case Break
            Case (iCode=SCEN_SETFOCUS          )
              Case Break
            Case (iCode=SCEN_KILLFOCUS         )
              Case Break
        Case End

        //// SVN CodeTip Support
        //If iCode Eq CMN_CODETIPINITIALIZE   Get Msg_DoCodeTipInitialize lParam to iRet
        //If iCode Eq CMN_CODETIPCANCEL       Get Msg_DoCodeTipCancel     lParam to iRet
        //If iCode Eq CMN_CODETIPUPDATE       Get Msg_DoCodeTipUpdate     lParam to iRet
        //// SVN
        //
        //If iCode Eq CMN_PROPSCHANGE         Get Msg_onPropsChange               to iRet
        //If iCode Eq CMN_OVERTYPECHANGE      Get Msg_onOvertypeChange            to iRet
        //If iCode Eq CMN_REGISTEREDCMD       Get Msg_DoRegisteredCmd   lParam    to iRet
        //If iCode Eq CMN_FINDWRAPPED         Get Msg_DoFindWrapping              to iRet
        //If iCode Eq CMN_DRAWLINE            Get Msg_DoDrawLine        lParam    to iRet
        Procedure_Return iRet
    End_Procedure

        // Delivers line and row (complex) from the given position
        // -> Position local to the Edit!
    Function LineRowFromRelativePosition Integer iY Integer iX  Returns Integer
        Integer iLine iCol iRet
        If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin
            Get CM_GetSelFromPoint iX iY        to iRet
            Move (piSelStartLine(Self))         to iLine
            Move (piSelStartCol (Self))         to iCol
            Function_Return (MAKEWPARAM(iCol,iLine))
        End
        Else Function_Return -1
    End_Function

        // Same as above but uses absolute Screen coordinates.
    Function LineRowFromAbsolutePosition Integer iY Integer iX  Returns Integer
        Integer iPY iPX
        Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
        Move (Low(iPy))                     to iPx
        Move (Hi(iPy))                      to iPy
        Move (iY-iPy)                       to iY
        Move (iX-iPx)                       to iX
        Function_Return (LineRowFromRelativePosition(Self,iY,iX))
    End_Function

        // Delivers the Line and Col under the Mouse Cursor.
    Function LineRowUnderMouseCursor Returns Integer
        Integer iX iY iRet
        Local_Buffer  sPoint pPoint tPoint_Size
        Move (GetCursorPos(pPoint))     to iRet
        GetBuff from sPoint At tPoint.x to iX
        GetBuff from sPoint At tPoint.y to iY
        Function_Return (LineRowFromAbsolutePosition(Self,iY,iX))
    End_Function


        // To find the Scope for Inserting a Text.
    Function GetScopeAboveFromLine Integer iLine Returns Integer
        Integer iEnde
        String  sLine sRet
        Move "" To sLine
        Move 0  To iEnde
        Repeat
            If (Trim(sLine)) Ne "" Move 1               to iEnde
            If iLine Lt 0          Move 1               to iEnde
            If not iEnde Get value item iLine           to sLine
            Decrement iLine
        Until (iEnde)
        If (sLine<>"") Function_Return (Pos(Trim(sLine),sLine)-1)
        Else Function_Return 0
    End_Function


        // Inserts a Text at this Position.
        // Understands commands like:
        //  \n  ... New Line
        //  \t  ... Keep ScopeLevel
        //  \s  ... New Line and InsertColumn
    Procedure InsertTextAtPosition Integer iLine Integer iCol String sTxt
        Integer iRet iScopeCol
        String  sCR
        Append sCR (Character(13)) (Character(10))
        If (Left(sTxt,2)) Eq "\s" Move iCol              to iScopeCol
        Else Get GetScopeAboveFromLine iLine             to iScopeCol
        Move (Replaces("\n",sTxt,sCR))                   to sTxt               // TO insert a new Line.
        Move (Replaces("\t",sTxt,Repeat(" ",iScopeCol))) to sTxt               // To keep the scope level.
        If (Left(sTxt,2)) Eq "\s" Begin                                        // Insert in new line.
            Move (Replace("\s",sTxt,Append("",Repeat(" ",iCol))))   to sTxt    // TO insert a new Line.
            Move 0                                                  to iCol
        End
        Move (CM_InsertText(Self,sTxt,iLine,iCol))                  to iRet
    End_Procedure

        // Tries to insert a text after the character with the given relativ
        // position (USed fro Drag and Drop)
    Procedure Request_InsertTextAfterPosRel Integer iY Integer iX String sTxt
        Integer iRet iLine iCol
        String  sCR
        If (Hi(CM_HitTest(Self,iX,iY))) Eq CM_EDITSPACE Begin // Only if the Koord. are over the editspace.
            Get CM_GetSelFromPoint iX iY    to iRet
            If iRet Begin
                Move (piSelStartLine(Self))         to iLine
                Move (piSelStartCol (Self))         to iCol
                Send InsertTextAtPosition iLine iCol sTxt
            End
        End
    End_Procedure




        // Tries to insert a text after the character with the given absolut
        // position (USed fro Drag and Drop)
    Procedure Request_InsertTextAfterPosAbs Integer iY Integer iX String sTxt
        Integer iPY iPX
        Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
        Move (Low(iPy))                     to iPx
        Move (Hi(iPy))                      to iPy
        Move (iY-iPy)                       to iY
        Move (iX-iPx)                       to iX
        Send Request_InsertTextAfterPosRel iY iX sTxt
    End_Procedure
        // Inserts text under the mous cursor position.
    Procedure Request_InserTextUnderMouseCursor String sTxt
        Integer iRet iX iY
        Local_Buffer sPoint pPoint tPoint_Size
        Move (GetCursorPos(pPoint))     to iRet
        GetBuff from sPoint At tPoint.x to iX
        GetBuff from sPoint At tPoint.y to iY
        Send Request_InsertTextAfterPosAbs iY iX sTxt
    End_Procedure

    Function HitTestCurrentMouse Returns Integer
        Integer iRet iX iY iPy iPx
        Local_Buffer sPoint pPoint tPoint_Size
        Move (GetCursorPos(pPoint))     to iRet
        GetBuff from sPoint At tPoint.x to iX
        GetBuff from sPoint At tPoint.y to iY
        Move (Absolute_GUIOriginEx(Self))   to iPy // Get the absolute Position of the Window.
        Move (Low(iPy))                     to iPx
        Move (Hi(iPy))                      to iPy
        Move (iY-iPy)                       to iY
        Move (iX-iPx)                       to iX
        Function_Return (Hi(CM_HitTest(Self,iX,iY)))
    End_Function

        // Should Start the Properties.
    Procedure Properties
        Integer iRet
        //Move (CM_ExecuteCmd(Self,CMD_PROPERTIES,0)) to iRet
        //Send Info_Box "Start configuration screen for editor component"
        Send PopupEditorSettingsDialog Self
    End_Procedure

End_Class

Define CM_NewFileName   For "Untitled"  // sometimes ver useful.